<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:12:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d3ce5.25479059_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:1;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d52b5.70379995_2\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:2;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d5331.33577257_3\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:3;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d5371.93796205_4\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:4;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d53a3.92968304_5\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:5;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d57d5.20114186_6\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:6;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d5814.52615111_7\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:7;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d5856.99186176_8\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:8;a:5:{i:0;s:33:\"tcpfunc_58dc766f5d5887.05792674_9\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:9;a:5:{i:0;s:34:\"tcpfunc_58dc766f5d5d05.07017115_10\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:10;a:5:{i:0;s:34:\"tcpfunc_58dc766f5d5d51.83976666_11\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:11;a:5:{i:0;s:34:\"tcpfunc_58dc766f5d5d81.10276411_12\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:18:\"RGraph.common.core\";i:3;N;i:4;a:12:{s:33:\"tcpfunc_58dc766f5d3ce5.25479059_1\";s:117516:\"\$tpl_funcs['tcpfunc_58dc766f5d3ce5.25479059_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d3ce5.25479059_1']=recall_named_function('58dc766f5d42d8.33088903','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n\\\\n// Module pattern\\\\n(function (win, doc, undefined)\\\\n{\\\\n    var RG  = RGraph,\\\\n        ua  = navigator.userAgent,\\\\n        ma  = Math;\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Initialise the various objects\\\\n    */\\\\n    RG.Highlight      = {};\\\\n    RG.Registry       = {};\\\\n    RG.Registry.store = [];\\\\n    RG.Registry.store['chart.event.handlers']       = [];\\\\n    RG.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips\\\\n    RG.Background     = {};\\\\n    RG.background     = {};\\\\n    RG.objects        = [];\\\\n    RG.Resizing       = {};\\\\n    RG.events         = [];\\\\n    RG.cursor         = [];\\\\n    RG.Effects        = RG.Effects || {};\\\\n    RG.cache          = [];\\\\n\\\\n    RG.ObjectRegistry                    = {};\\\\n    RG.ObjectRegistry.objects            = {};\\\\n    RG.ObjectRegistry.objects.byUID      = [];\\\\n    RG.ObjectRegistry.objects.byCanvasID = [];\\\\n    RG.OR                                = RG.ObjectRegistry;\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Some \\\\\\\"constants\\\\\\\". The ua variable is navigator.userAgent (definedabove)\\\\n    */\\\\n    RG.PI       = ma.PI;\\\\n    RG.HALFPI   = RG.PI / 2;\\\\n    RG.TWOPI    = RG.PI * 2;\\\\n\\\\n    RG.ISFF     = ua.indexOf('Firefox') != -1;\\\\n    RG.ISOPERA  = ua.indexOf('Opera') != -1;\\\\n    RG.ISCHROME = ua.indexOf('Chrome') != -1;\\\\n    RG.ISSAFARI = ua.indexOf('Safari') != -1 && !RG.ISCHROME;\\\\n    RG.ISWEBKIT = ua.indexOf('WebKit') != -1;\\\\n\\\\n    RG.ISIE   = ua.indexOf('Trident') > 0 || navigator.userAgent.indexOf('MSIE') > 0;\\\\n    RG.ISIE6  = ua.indexOf('MSIE 6') > 0;\\\\n    RG.ISIE7  = ua.indexOf('MSIE 7') > 0;\\\\n    RG.ISIE8  = ua.indexOf('MSIE 8') > 0;\\\\n    RG.ISIE9  = ua.indexOf('MSIE 9') > 0;\\\\n    RG.ISIE10 = ua.indexOf('MSIE 10') > 0;\\\\n    RG.ISOLD  = RGraph.ISIE6 || RGraph.ISIE7 || RGraph.ISIE8; // MUST be here\\\\n    \\\\n    RG.ISIE11UP = ua.indexOf('MSIE') == -1 && ua.indexOf('Trident') > 0;\\\\n    RG.ISIE10UP = RG.ISIE10 || RG.ISIE11UP;\\\\n    RG.ISIE9UP  = RG.ISIE9 || RG.ISIE10UP;\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns five values which are used as a nice scale\\\\n    * \\\\n    * @param  max int    The maximum value of the graph\\\\n    * @param  obj object The graph object\\\\n    * @return     array   An appropriate scale\\\\n    */\\\\n    RG.getScale = function (max, obj)\\\\n    {\\\\n        /**\\\\n        * Special case for 0\\\\n        */\\\\n        if (max == 0) {\\\\n            return ['0.2', '0.4', '0.6', '0.8', '1.0'];\\\\n        }\\\\n\\\\n        var original_max = max;\\\\n\\\\n        /**\\\\n        * Manually do decimals\\\\n        */\\\\n        if (max <= 1) {\\\\n            if (max > 0.5) {\\\\n                return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];\\\\n\\\\n            } else if (max >= 0.1) {\\\\n                return obj.Get('chart.scale.round') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];\\\\n\\\\n            } else {\\\\n\\\\n                var tmp = max;\\\\n                var exp = 0;\\\\n\\\\n                while (tmp < 1.01) {\\\\n                    exp += 1;\\\\n                    tmp *= 10;\\\\n                }\\\\n\\\\n                var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];\\\\n\\\\n\\\\n                if (max <= ('5e-' + exp)) {\\\\n                    ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];\\\\n                }\\\\n\\\\n                return ret;\\\\n            }\\\\n        }\\\\n\\\\n        // Take off any decimals\\\\n        if (String(max).indexOf('.') > 0) {\\\\n            max = String(max).replace(/\\\\\\\\.\\\\\\\\d+\\\\\\\$/, '');\\\\n        }\\\\n\\\\n        var interval = ma.pow(10, Number(String(Number(max)).length - 1));\\\\n        var topValue = interval;\\\\n\\\\n        while (topValue < max) {\\\\n            topValue += (interval / 2);\\\\n        }\\\\n\\\\n        // Handles cases where the max is (for example) 50.5\\\\n        if (Number(original_max) > Number(topValue)) {\\\\n            topValue += (interval / 2);\\\\n        }\\\\n\\\\n        // Custom if the max is greater than 5 and less than 10\\\\n        if (max < 10) {\\\\n            topValue = (Number(original_max) <= 5 ? 5 : 10);\\\\n        }\\\\n        \\\\n        /**\\\\n        * Added 02/11/2010 to create \\\\\\\"nicer\\\\\\\" scales\\\\n        */\\\\n        if (obj && typeof(obj.Get('chart.scale.round')) == 'boolean' && obj.Get('chart.scale.round')) {\\\\n            topValue = 10 * interval;\\\\n        }\\\\n\\\\n        return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns an appropriate scale. The return value is actualy an object consisting of:\\\\n    *  scale.max\\\\n    *  scale.min\\\\n    *  scale.scale\\\\n    * \\\\n    * @param  obj object  The graph object\\\\n    * @param  prop object An object consisting of configuration properties\\\\n    * @return     object  An object containg scale information\\\\n    */\\\\n    RG.getScale2 = function (obj, opt)\\\\n    {\\\\n        var ca           = obj.canvas,\\\\n            co           = obj.context,\\\\n            prop         = obj.properties,\\\\n            numlabels    = typeof opt['ylabels.count'] == 'number' ? opt['ylabels.count'] : 5,\\\\n            units_pre    = typeof opt['units.pre'] == 'string' ? opt['units.pre'] : '',\\\\n            units_post   = typeof opt['units.post'] == 'string' ? opt['units.post'] : '',\\\\n            max          = Number(opt['max']),\\\\n            min          = typeof opt['min'] == 'number' ? opt['min'] : 0,\\\\n            strict       = opt['strict'],\\\\n            decimals     = Number(opt['scale.decimals']), // Sometimes the default is null\\\\n            point        = opt['scale.point'], // Default is a string in all chart libraries so no need to cast it\\\\n            thousand     = opt['scale.thousand'], // Default is a string in all chart libraries so no need to cast it\\\\n            original_max = max,\\\\n            round        = opt['scale.round'],\\\\n            scale        = {max:1,labels:[],values:[]}\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Special case for 0\\\\n        * \\\\n        * ** Must be first **\\\\n        */\\\\n        if (!max) {\\\\n\\\\n            var max   = 1;\\\\n\\\\n            for (var i=0; i<numlabels; ++i) {\\\\n\\\\n                var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);\\\\n\\\\n                scale.labels.push(units_pre + label + units_post);\\\\n                scale.values.push(parseFloat(label))\\\\n            }\\\\n\\\\n        /**\\\\n        * Manually do decimals\\\\n        */\\\\n        } else if (max <= 1 && !strict) {\\\\n\\\\n            var arr = [\\\\n                1,0.5,\\\\n                0.10,0.05,\\\\n                0.010,0.005,\\\\n                0.0010,0.0005,\\\\n                0.00010,0.00005,\\\\n                0.000010,0.000005,\\\\n                0.0000010,0.0000005,\\\\n                0.00000010,0.00000005,\\\\n                0.000000010,0.000000005,\\\\n                0.0000000010,0.0000000005,\\\\n                0.00000000010,0.00000000005,\\\\n                0.000000000010,0.000000000005,\\\\n                0.0000000000010,0.0000000000005\\\\n            ], vals = [];\\\\n\\\\n\\\\n\\\\n            for (var i=0; i<arr.length; ++i) {\\\\n                if (max > arr[i]) {\\\\n                    i--;\\\\n                    break;\\\\n                }\\\\n            }\\\\n\\\\n\\\\n            scale.max = arr[i]\\\\n            scale.labels = [];\\\\n            scale.values = [];\\\\n        \\\\n            for (var j=0; j<numlabels; ++j) {\\\\n                \\\\n                var value = ((((arr[i] - min) / numlabels) * (j + 1)) + min).toFixed(decimals);\\\\n\\\\n                scale.values.push(value);\\\\n                scale.labels.push(RG.numberFormat(obj, value, units_pre, units_post));\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n        } else if (!strict) {\\\\n\\\\n            /**\\\\n            * Now comes the scale handling for integer values\\\\n            */\\\\n\\\\n            // This accomodates decimals by rounding the max up to the next integer\\\\n            max = ma.ceil(max);\\\\n\\\\n            var interval = ma.pow(10, ma.max(1, Number(String(Number(max) - Number(min)).length - 1)) );\\\\n\\\\n            var topValue = interval;\\\\n\\\\n            while (topValue < max) {\\\\n                topValue += (interval / 2);\\\\n            }\\\\n\\\\n            // Handles cases where the max is (for example) 50.5\\\\n            if (Number(original_max) > Number(topValue)) {\\\\n                topValue += (interval / 2);\\\\n            }\\\\n\\\\n            // Custom if the max is greater than 5 and less than 10\\\\n            if (max <= 10) {\\\\n                topValue = (Number(original_max) <= 5 ? 5 : 10);\\\\n            }\\\\n    \\\\n    \\\\n            // Added 02/11/2010 to create \\\\\\\"nicer\\\\\\\" scales\\\\n            if (obj && typeof(round) == 'boolean' && round) {\\\\n                topValue = 10 * interval;\\\\n            }\\\\n\\\\n            scale.max = topValue;\\\\n\\\\n            // Now generate the scale. Temporarily set the objects chart.scale.decimal and chart.scale.point to those\\\\n            //that we've been given as the number_format functuion looks at those instead of using argumrnts.\\\\n            var tmp_point    = prop['chart.scale.point'];\\\\n            var tmp_thousand = prop['chart.scale.thousand'];\\\\n\\\\n            obj.Set('chart.scale.thousand', thousand);\\\\n            obj.Set('chart.scale.point', point);\\\\n\\\\n\\\\n            for (var i=0; i<numlabels; ++i) {\\\\n                scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals), units_pre, units_post) );\\\\n                scale.values.push(((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals));\\\\n            }\\\\n\\\\n            obj.Set('chart.scale.thousand', tmp_thousand);\\\\n            obj.Set('chart.scale.point', tmp_point);\\\\n        \\\\n        } else if (typeof(max) == 'number' && strict) {\\\\n\\\\n            /**\\\\n            * ymax is set and also strict\\\\n            */\\\\n            for (var i=0; i<numlabels; ++i) {\\\\n                scale.labels.push(RG.numberFormat(\\\\n                    obj,\\\\n                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals),\\\\n                    units_pre,\\\\n                    units_post\\\\n                ));\\\\n\\\\n                scale.values.push(\\\\n                    ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals)\\\\n                );\\\\n            }\\\\n            \\\\n            // ???\\\\n            scale.max = max;\\\\n        }\\\\n\\\\n        \\\\n        scale.units_pre  = units_pre;\\\\n        scale.units_post = units_post;\\\\n        scale.point      = point;\\\\n        scale.decimals   = decimals;\\\\n        scale.thousand   = thousand;\\\\n        scale.numlabels  = numlabels;\\\\n        scale.round      = Boolean(round);\\\\n        scale.min        = min;\\\\n\\\\n        //\\\\n        // Convert all of the scale values to numbers\\\\n        //\\\\n        for (var i=0; i<scale.values.length; ++i) {\\\\n            scale.values[i] = parseFloat(scale.values[i]);\\\\n        }\\\\n\\\\n        return scale;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    //\\\\n    // Converts an the truthy values to falsey values and vice-versa\\\\n    //\\\\n    RG.arrayInvert = function (arr)\\\\n    {\\\\n        for (var i=0,len=arr.length; i<len; ++i) {\\\\n            arr[i] = !arr[i];\\\\n        }\\\\n\\\\n        return arr;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    //\\\\n    // An array_trim function that removes the empty elements off\\\\n    //both ends\\\\n    //\\\\n    RG.arrayTrim = function (arr)\\\\n    {\\\\n        var out = [], content = false;\\\\n\\\\n        // Trim the start\\\\n        for (var i=0; i<arr.length; i++) {\\\\n        \\\\n            if (arr[i]) {\\\\n                content = true;\\\\n            }\\\\n        \\\\n            if (content) {\\\\n                out.push(arr[i]);\\\\n            }\\\\n        }\\\\n        \\\\n        // Reverse the array and trim the start again\\\\n        out = RG.arrayReverse(out);\\\\n\\\\n        var out2 = [], content = false ;\\\\n        for (var i=0; i<out.length; i++) {\\\\n        \\\\n            if (out[i]) {\\\\n                content = true;\\\\n            }\\\\n        \\\\n            if (content) {\\\\n                out2.push(out[i]);\\\\n            }\\\\n        }\\\\n        \\\\n        // Now reverse the array and return it\\\\n        out2 = RG.arrayReverse(out2);\\\\n\\\\n        return out2;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Makes a clone of an object\\\\n    * \\\\n    * @param obj val The object to clone\\\\n    */\\\\n    RG.arrayClone =\\\\n    RG.array_clone = function (obj)\\\\n    {\\\\n        if(obj === null || typeof obj !== 'object') {\\\\n            return obj;\\\\n        }\\\\n\\\\n        var temp = [];\\\\n\\\\n        for (var i=0,len=obj.length;i<len; ++i) {\\\\n\\\\n            if (typeof obj[i]  === 'number') {\\\\n                temp[i] = (function (arg) {return Number(arg);})(obj[i]);\\\\n            \\\\n            } else if (typeof obj[i]  === 'string') {\\\\n                temp[i] = (function (arg) {return String(arg);})(obj[i]);\\\\n            \\\\n            } else if (typeof obj[i] === 'function') {\\\\n                temp[i] = obj[i];\\\\n            \\\\n            } else {\\\\n                temp[i] = RG.arrayClone(obj[i]);\\\\n            }\\\\n        }\\\\n\\\\n        return temp;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns the maximum numeric value which is in an array. This function IS NOT\\\\n    * recursive\\\\n    * \\\\n    * @param  array arr The array (can also be a number, in which case it's returned as-is)\\\\n    * @param  int       Whether to ignore signs (ie negative/positive)\\\\n    * @return int       The maximum value in the array\\\\n    */\\\\n    RG.arrayMax =\\\\n    RG.array_max = function (arr)\\\\n    {\\\\n        var max = null,\\\\n            ma  = Math\\\\n        \\\\n        if (typeof arr === 'number') {\\\\n            return arr;\\\\n        }\\\\n        \\\\n        if (RG.isNull(arr)) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        for (var i=0,len=arr.length; i<len; ++i) {\\\\n            if (typeof arr[i] === 'number') {\\\\n\\\\n                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];\\\\n                \\\\n                if (typeof max === 'number') {\\\\n                    max = ma.max(max, val);\\\\n                } else {\\\\n                    max = val;\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        return max;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns the minimum numeric value which is in an array\\\\n    * \\\\n    * @param  array arr The array (can also be a number, in which case it's returned as-is)\\\\n    * @param  int       Whether to ignore signs (ie negative/positive)\\\\n    * @return int       The minimum value in the array\\\\n    */\\\\n    RG.arrayMin = function (arr)\\\\n    {\\\\n        var max = null,\\\\n            min = null,\\\\n            ma  = Math;\\\\n        \\\\n        if (typeof arr === 'number') {\\\\n            return arr;\\\\n        }\\\\n        \\\\n        if (RG.isNull(arr)) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        for (var i=0,len=arr.length; i<len; ++i) {\\\\n            if (typeof arr[i] === 'number') {\\\\n\\\\n                var val = arguments[1] ? ma.abs(arr[i]) : arr[i];\\\\n                \\\\n                if (typeof min === 'number') {\\\\n                    min = ma.min(min, val);\\\\n                } else {\\\\n                    min = val;\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        return min;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns the maximum value which is in an array\\\\n    * \\\\n    * @param  array arr The array\\\\n    * @param  int   len The length to pad the array to\\\\n    * @param  mixed     The value to use to pad the array (optional)\\\\n    */\\\\n    RG.arrayPad =\\\\n    RG.array_pad = function (arr, len)\\\\n    {\\\\n        if (arr.length < len) {\\\\n            var val = arguments[2] ? arguments[2] : null;\\\\n            \\\\n            for (var i=arr.length; i<len; i+=1) {\\\\n                arr[i] = val;\\\\n            }\\\\n        }\\\\n        \\\\n        return arr;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * An array sum function\\\\n    * \\\\n    * @param  array arr The  array to calculate the total of\\\\n    * @return int       The summed total of the arrays elements\\\\n    */\\\\n    RG.arraySum =\\\\n    RG.array_sum = function (arr)\\\\n    {\\\\n        // Allow integers\\\\n        if (typeof arr === 'number') {\\\\n            return arr;\\\\n        }\\\\n        \\\\n        // Account for null\\\\n        if (RG.is_null(arr)) {\\\\n            return 0;\\\\n        }\\\\n\\\\n        var i, sum, len = arr.length;\\\\n\\\\n        for(i=0,sum=0;i<len;sum+=arr[i++]);\\\\n\\\\n        return sum;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Takes any number of arguments and adds them to one big linear array\\\\n    * which is then returned\\\\n    * \\\\n    * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays\\\\n    */\\\\n    RG.arrayLinearize =\\\\n    RG.array_linearize = function ()\\\\n    {\\\\n        var arr  = [],\\\\n            args = arguments\\\\n\\\\n        for (var i=0,len=args.length; i<len; ++i) {\\\\n\\\\n            if (typeof args[i] === 'object' && args[i]) {\\\\n                for (var j=0,len2=args[i].length; j<len2; ++j) {\\\\n                    var sub = RG.array_linearize(args[i][j]);\\\\n                    \\\\n                    for (var k=0,len3=sub.length; k<len3; ++k) {\\\\n                        arr.push(sub[k]);\\\\n                    }\\\\n                }\\\\n            } else {\\\\n                arr.push(args[i]);\\\\n            }\\\\n        }\\\\n\\\\n        return arr;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Takes one off the front of the given array and returns the new array.\\\\n    * \\\\n    * @param array arr The array from which to take one off the front of array \\\\n    * \\\\n    * @return array The new array\\\\n    */\\\\n    RG.arrayShift =\\\\n    RG.array_shift = function(arr)\\\\n    {\\\\n        var ret = [];\\\\n        \\\\n        for(var i=1,len=arr.length; i<len; ++i) {\\\\n            ret.push(arr[i]);\\\\n        }\\\\n        \\\\n        return ret;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Reverses the order of an array\\\\n    * \\\\n    * @param array arr The array to reverse\\\\n    */\\\\n    RG.arrayReverse =\\\\n    RG.array_reverse = function (arr)\\\\n    {\\\\n        if (!arr) {\\\\n            return;\\\\n        }\\\\n\\\\n        var newarr=[];\\\\n\\\\n        for(var i=arr.length - 1; i>=0; i-=1) {\\\\n            newarr.push(arr[i]);\\\\n        }\\\\n        \\\\n        return newarr;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns the absolute value of a number. You can also pass in an\\\\n    * array and it will run the abs() function on each element. It\\\\n    * operates recursively so sub-arrays are also traversed.\\\\n    * \\\\n    * @param array arr The number or array to work on\\\\n    */\\\\n    RG.abs = function (value)\\\\n    {\\\\n        if (typeof value === 'string') {\\\\n            value = parseFloat(value) || 0;\\\\n        }\\\\n\\\\n        if (typeof value === 'number') {\\\\n            return ma.abs(value);\\\\n        }\\\\n\\\\n        if (typeof value === 'object') {\\\\n            for (i in value) {\\\\n                if (   typeof i === 'string'\\\\n                    || typeof i === 'number'\\\\n                    || typeof i === 'object') {\\\\n\\\\n                    value[i] = RG.abs(value[i]);\\\\n                }\\\\n            }\\\\n            \\\\n            return value;\\\\n        }\\\\n        \\\\n        return 0;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Clears the canvas by setting the width. You can specify a colour if you wish.\\\\n    * \\\\n    * @param object canvas The canvas to clear\\\\n    * @param mixed         Usually a color string to use to clear the canvas\\\\n    *                      with - could also be a gradient object\\\\n    */\\\\n    RG.clear =\\\\n    RG.Clear = function (ca)\\\\n    {\\\\n        var obj   = ca.__object__,\\\\n            co    = ca.getContext('2d'),\\\\n            color = arguments[1] || (obj && obj.get('clearto'))\\\\n\\\\n        if (!ca) {\\\\n            return;\\\\n        }\\\\n        \\\\n        RG.fireCustomEvent(obj, 'onbeforeclear');\\\\n\\\\n        /**\\\\n        * Set the CSS display: to none for DOM text\\\\n        */\\\\n        if (RG.text2.domNodeCache && RG.text2.domNodeCache[ca.id]) {\\\\n            for (var i in RG.text2.domNodeCache[ca.id]) {\\\\n                \\\\n                var el = RG.text2.domNodeCache[ca.id][i];\\\\n    \\\\n                if (el && el.style) {\\\\n                    el.style.display = 'none';\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        /**\\\\n        * Can now clear the canvas back to fully transparent\\\\n        */\\\\n        if (   !color\\\\n            || (color && color === 'rgba(0,0,0,0)' || color === 'transparent')\\\\n            ) {\\\\n\\\\n            co.clearRect(-100,-100,ca.width + 200, ca.height + 200);\\\\n            \\\\n            // Reset the globalCompositeOperation\\\\n            co.globalCompositeOperation = 'source-over';\\\\n\\\\n        } else if (color) {\\\\n            RG.path2(co, 'fs % fr -100 -100 % %',\\\\n                color,\\\\n                ca.width + 200,\\\\n                ca.height + 200\\\\n            );\\\\n        \\\\n        } else {\\\\n            RG.path2(co, 'fs % fr -100 -100 % %',\\\\n                obj.get('clearto'),\\\\n                ca.width + 200,\\\\n                ca.height + 200\\\\n            );\\\\n        }\\\\n        \\\\n        //if (RG.ClearAnnotations) {\\\\n            //RG.ClearAnnotations(ca.id);\\\\n        //}\\\\n        \\\\n        /**\\\\n        * This removes any background image that may be present\\\\n        */\\\\n        if (RG.Registry.Get('chart.background.image.' + ca.id)) {\\\\n            var img = RG.Registry.Get('chart.background.image.' + ca.id);\\\\n            img.style.position = 'absolute';\\\\n            img.style.left     = '-10000px';\\\\n            img.style.top      = '-10000px';\\\\n        }\\\\n        \\\\n        /**\\\\n        * This hides the tooltip that is showing IF it has the same canvas ID as\\\\n        * that which is being cleared\\\\n        */\\\\n        if (RG.Registry.Get('chart.tooltip') && obj && !obj.get('chart.tooltips.nohideonclear')) {\\\\n            RG.HideTooltip(ca);\\\\n            //RG.Redraw();\\\\n        }\\\\n\\\\n\\\\n\\\\n        //\\\\n        // Hide all DOM text by positioning it outside the canvas\\\\n        //\\\\n        //for (i in RG.cache) {\\\\n        //    if (typeof i === 'string' && i.indexOf('-text-') > 0) {\\\\n        //        RG.cache[i].style.left = '-100px';\\\\n        //        RG.cache[i].style.top  = '-100px';\\\\n        //    }\\\\n        //}\\\\n\\\\n        /**\\\\n        * Set the cursor to default\\\\n        */\\\\n        ca.style.cursor = 'default';\\\\n\\\\n        RG.FireCustomEvent(obj, 'onclear');\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws the title of the graph\\\\n    * \\\\n    * @param object  canvas The canvas object\\\\n    * @param string  text   The title to write\\\\n    * @param integer gutter The size of the gutter\\\\n    * @param integer        The center X point (optional - if not given it will be generated from the canvas width)\\\\n    * @param integer        Size of the text. If not given it will be 14\\\\n    * @param object         An optional object which has canvas and context properties to use instead of those on\\\\n    *                       the obj argument (so as to enable caching)\\\\n    */\\\\n    RG.drawTitle =\\\\n    RG.DrawTitle = function (obj, text, gutterTop)\\\\n    {\\\\n        var ca = canvas  = obj.canvas,\\\\n            co = context = obj.context,\\\\n            prop         = obj.properties\\\\n            gutterLeft   = prop['chart.gutter.left'],\\\\n            gutterRight  = prop['chart.gutter.right'],\\\\n            gutterTop    = gutterTop,\\\\n            gutterBottom = prop['chart.gutter.bottom'],\\\\n            size         = arguments[4] ? arguments[4] : 12,\\\\n            bold         = prop['chart.title.bold'],\\\\n            italic       = prop['chart.title.italic'],\\\\n            centerx      = (arguments[3] ? arguments[3] : ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft),\\\\n            keypos       = prop['chart.key.position'],\\\\n            vpos         = prop['chart.title.vpos'],\\\\n            hpos         = prop['chart.title.hpos'],\\\\n            bgcolor      = prop['chart.title.background'],\\\\n            x            = prop['chart.title.x'],\\\\n            y            = prop['chart.title.y'],\\\\n            halign       = 'center',\\\\n            valign       = 'center'\\\\n\\\\n        // Account for 3D effect by faking the key position\\\\n        if (obj.type == 'bar' && prop['chart.variant'] == '3d') {\\\\n            keypos = 'gutter';\\\\n        }\\\\n\\\\n        co.beginPath();\\\\n        co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Vertically center the text if the key is not present\\\\n        */\\\\n        if (keypos && keypos != 'gutter') {\\\\n            var valign = 'center';\\\\n\\\\n        } else if (!keypos) {\\\\n            var valign = 'center';\\\\n\\\\n       } else {\\\\n            var valign = 'bottom';\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        // if chart.title.vpos is a number, use that\\\\n        if (typeof prop['chart.title.vpos'] === 'number') {\\\\n            vpos = prop['chart.title.vpos'] * gutterTop;\\\\n\\\\n            if (prop['chart.xaxispos'] === 'top') {\\\\n                vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);\\\\n            }\\\\n\\\\n        } else {\\\\n            vpos = gutterTop - size - 5;\\\\n\\\\n            if (prop['chart.xaxispos'] === 'top') {\\\\n                vpos = ca.height  - gutterBottom + size + 5;\\\\n            }\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // if chart.title.hpos is a number, use that. It's multiplied with the (entire) canvas width\\\\n        if (typeof hpos === 'number') {\\\\n            centerx = hpos * ca.width;\\\\n        }\\\\n\\\\n        /**\\\\n        * Now the chart.title.x and chart.title.y settings override (is set) the above\\\\n        */\\\\n        if (typeof x === 'number') centerx = x;\\\\n        if (typeof y === 'number') vpos    = y;\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Horizontal alignment can now (Jan 2013) be specified\\\\n        */\\\\n        if (typeof prop['chart.title.halign'] === 'string') {\\\\n            halign = prop['chart.title.halign'];\\\\n        }\\\\n        \\\\n        /**\\\\n        * Vertical alignment can now (Jan 2013) be specified\\\\n        */\\\\n        if (typeof prop['chart.title.valign'] === 'string') {\\\\n            valign = prop['chart.title.valign'];\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        \\\\n        // Set the colour\\\\n        if (typeof prop['chart.title.color'] !== null) {\\\\n            var oldColor = co.fillStyle\\\\n            var newColor = prop['chart.title.color'];\\\\n            co.fillStyle = newColor ? newColor : 'black';\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Default font is Arial\\\\n        */\\\\n        var font = prop['chart.text.font'];\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Override the default font with chart.title.font\\\\n        */\\\\n        if (typeof prop['chart.title.font'] === 'string') {\\\\n            font = prop['chart.title.font'];\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draw the title\\\\n        */\\\\n\\\\n        var ret = RG.text2(obj, {\\\\n            font:font,\\\\n            size:size,\\\\n            x:centerx,\\\\n            y:vpos,\\\\n            text:text,\\\\n            valign:valign,\\\\n            halign:halign,\\\\n            bounding:bgcolor != null,\\\\n            'bounding.fill':bgcolor,\\\\n            'bold':bold,\\\\n            italic: italic,\\\\n            tag:'title',\\\\n            marker: false\\\\n        });\\\\n\\\\n        // Reset the fill colour\\\\n        co.fillStyle = oldColor;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Gets the mouse X/Y coordinates relative to the canvas\\\\n    * \\\\n    * @param object e The event object. As such this method should be used in an event listener.\\\\n    */\\\\n    RG.getMouseXY = function(e)\\\\n    {\\\\n        // This is necessary foe IE9\\\\n        if (!e.target) {\\\\n            return;\\\\n        }\\\\n\\\\n        var el      = e.target;\\\\n        var ca      = el;\\\\n        var caStyle = ca.style;\\\\n        var offsetX = 0;\\\\n        var offsetY = 0;\\\\n        var x;\\\\n        var y;\\\\n        var borderLeft  = parseInt(caStyle.borderLeftWidth) || 0;\\\\n        var borderTop   = parseInt(caStyle.borderTopWidth) || 0;\\\\n        var paddingLeft = parseInt(caStyle.paddingLeft) || 0\\\\n        var paddingTop  = parseInt(caStyle.paddingTop) || 0\\\\n        var additionalX = borderLeft + paddingLeft;\\\\n        var additionalY = borderTop + paddingTop;\\\\n\\\\n\\\\n        if (typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            if (!RG.ISIE && !RG.ISOPERA) {\\\\n                x = e.offsetX - borderLeft - paddingLeft;\\\\n                y = e.offsetY - borderTop - paddingTop;\\\\n            \\\\n            } else if (RG.ISIE) {\\\\n                x = e.      offsetX - paddingLeft;\\\\n                y = e.offsetY - paddingTop;\\\\n            \\\\n            } else {\\\\n                x = e.offsetX;\\\\n                y = e.offsetY;\\\\n            }   \\\\n\\\\n        } else {\\\\n\\\\n            if (typeof el.offsetParent !== 'undefined') {\\\\n                do {\\\\n                    offsetX += el.offsetLeft;\\\\n                    offsetY += el.offsetTop;\\\\n                } while ((el = el.offsetParent));\\\\n            }\\\\n\\\\n            x = e.pageX - offsetX - additionalX;\\\\n            y = e.pageY - offsetY - additionalY;\\\\n\\\\n            x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));\\\\n            y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));\\\\n\\\\n            //x += (parseInt(caStyle.borderLeftWidth) || 0);\\\\n            //y += (parseInt(caStyle.borderTopWidth) || 0);\\\\n        }\\\\n\\\\n        // We return a javascript array with x and y defined\\\\n        return [x, y];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function returns a two element array of the canvas x/y position in\\\\n    * relation to the page\\\\n    * \\\\n    * @param object canvas\\\\n    */\\\\n    RG.getCanvasXY = function (canvas)\\\\n    {\\\\n        var x  = 0;\\\\n        var y  = 0;\\\\n        var el = canvas; // !!!\\\\n\\\\n        do {\\\\n\\\\n            x += el.offsetLeft;\\\\n            y += el.offsetTop;\\\\n            \\\\n            // ACCOUNT FOR TABLES IN wEBkIT\\\\n            if (el.tagName.toLowerCase() == 'table' && (RG.ISCHROME || RG.ISSAFARI)) {\\\\n                x += parseInt(el.border) || 0;\\\\n                y += parseInt(el.border) || 0;\\\\n            }\\\\n\\\\n            el = el.offsetParent;\\\\n\\\\n        } while (el && el.tagName.toLowerCase() != 'body');\\\\n\\\\n\\\\n        var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;\\\\n        var paddingTop  = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;\\\\n        var borderLeft  = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;\\\\n        var borderTop   = canvas.style.borderTopWidth  ? parseInt(canvas.style.borderTopWidth) : 0;\\\\n\\\\n        if (navigator.userAgent.indexOf('Firefox') > 0) {\\\\n            x += parseInt(document.body.style.borderLeftWidth) || 0;\\\\n            y += parseInt(document.body.style.borderTopWidth) || 0;\\\\n        }\\\\n\\\\n        return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns\\\\n    * false. If it is then the element that is fixed is returned (it may be a parent of the canvas).\\\\n    * \\\\n    * @return Either false or the fixed positioned element\\\\n    */\\\\n    RG.isFixed = function (canvas)\\\\n    {\\\\n        var obj = canvas;\\\\n        var i = 0;\\\\n\\\\n        while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {\\\\n\\\\n            if (obj.style.position == 'fixed') {\\\\n                return obj;\\\\n            }\\\\n            \\\\n            obj = obj.offsetParent;\\\\n        }\\\\n\\\\n        return false;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Registers a graph object (used when the canvas is redrawn)\\\\n    * \\\\n    * @param object obj The object to be registered\\\\n    */\\\\n    RG.register =\\\\n    RG.Register = function (obj)\\\\n    {\\\\n        // Checking this property ensures the object is only registered once\\\\n        if (!obj.Get('chart.noregister')) {\\\\n            // As of 21st/1/2012 the object registry is now used\\\\n            RGraph.ObjectRegistry.Add(obj);\\\\n            obj.Set('chart.noregister', true);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Causes all registered objects to be redrawn\\\\n    * \\\\n    * @param string An optional color to use to clear the canvas\\\\n    */\\\\n    RG.redraw =\\\\n    RG.Redraw = function ()\\\\n    {\\\\n        var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;\\\\n\\\\n        // Get all of the canvas tags on the page\\\\n        var tags = document.getElementsByTagName('canvas');\\\\n\\\\n        for (var i=0,len=tags.length; i<len; ++i) {\\\\n            if (tags[i].__object__ && tags[i].__object__.isRGraph) {\\\\n                \\\\n                // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects\\\\n                if (!tags[i].noclear) {\\\\n                    RGraph.clear(tags[i], arguments[0] ? arguments[0] : null);\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        // Go through the object registry and redraw *all* of the canvas'es that have been registered\\\\n        for (var i=0,len=objectRegistry.length; i<len; ++i) {\\\\n            if (objectRegistry[i]) {\\\\n                var id = objectRegistry[i][0];\\\\n                objectRegistry[i][1].Draw();\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Causes all registered objects ON THE GIVEN CANVAS to be redrawn\\\\n    * \\\\n    * @param canvas object The canvas object to redraw\\\\n    * @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas\\\\n    */\\\\n    RG.redrawCanvas =\\\\n    RG.RedrawCanvas = function (ca)\\\\n    {\\\\n        var objects = RG.ObjectRegistry.getObjectsByCanvasID(ca.id);\\\\n\\\\n        /**\\\\n        * First clear the canvas\\\\n        */\\\\n        if (!arguments[1] || (typeof arguments[1] === 'boolean' && !arguments[1] == false) ) {\\\\n            var color = arguments[2] || ca.__object__.get('clearto') || 'transparent';\\\\n            RG.clear(ca, color);\\\\n        }\\\\n\\\\n        /**\\\\n        * Now redraw all the charts associated with that canvas\\\\n        */\\\\n        for (var i=0,len=objects.length; i<len; ++i) {\\\\n            if (objects[i]) {\\\\n                if (objects[i] && objects[i].isRGraph) { // Is it an RGraph object ??\\\\n                    objects[i].Draw();\\\\n                }\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function draws the background for the bar chart, line chart and scatter chart.\\\\n    * \\\\n    * @param  object obj The graph object\\\\n    */\\\\n    RG.Background.draw =\\\\n    RG.background.draw =\\\\n    RG.background.Draw = function (obj)\\\\n    {\\\\n        var ca   = obj.canvas,\\\\n            co   = obj.context,\\\\n            prop = obj.properties,\\\\n            height       = 0,\\\\n            gutterLeft   = obj.gutterLeft,\\\\n            gutterRight  = obj.gutterRight,\\\\n            gutterTop    = obj.gutterTop,\\\\n            gutterBottom = obj.gutterBottom,\\\\n            variant      = prop['chart.variant']\\\\n                \\\\n\\\\n            co.fillStyle = prop['chart.text.color'];\\\\n            \\\\n            // If it's a bar and 3D variant, translate\\\\n            if (variant == '3d') {\\\\n                co.save();\\\\n                co.translate(prop['chart.variant.threed.offsetx'], -1 * prop['chart.variant.threed.offsety']);\\\\n            }\\\\n    \\\\n            // X axis title\\\\n            if (typeof prop['chart.title.xaxis'] === 'string' && prop['chart.title.xaxis'].length) {\\\\n            \\\\n                var size = prop['chart.text.size'] + 2;\\\\n                var font = prop['chart.text.font'];\\\\n                var bold = prop['chart.title.xaxis.bold'];\\\\n    \\\\n                if (typeof(prop['chart.title.xaxis.size']) == 'number') {\\\\n                    size = prop['chart.title.xaxis.size'];\\\\n                }\\\\n    \\\\n                if (typeof(prop['chart.title.xaxis.font']) == 'string') {\\\\n                    font = prop['chart.title.xaxis.font'];\\\\n                }\\\\n                \\\\n                var hpos = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;\\\\n                var vpos = ca.height - gutterBottom + 25;\\\\n                \\\\n                if (typeof prop['chart.title.xaxis.pos'] === 'number') {\\\\n                    vpos = ca.height - (gutterBottom * prop['chart.title.xaxis.pos']);\\\\n                }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n                // Specifically specified X/Y positions\\\\n                if (typeof prop['chart.title.xaxis.x'] === 'number') {\\\\n                    hpos = prop['chart.title.xaxis.x'];\\\\n                }\\\\n    \\\\n                if (typeof prop['chart.title.xaxis.y'] === 'number') {\\\\n                    vpos = prop['chart.title.xaxis.y'];\\\\n                }\\\\n    \\\\n    \\\\n    \\\\n                RG.text2(prop['chart.text.accessible'] ? obj.context : co,  {\\\\n					font:font,\\\\n					size:size,\\\\n					x:hpos,\\\\n					y:vpos,\\\\n					text:prop['chart.title.xaxis'],\\\\n					halign:'center',\\\\n					valign:'center',\\\\n					bold:bold,\\\\n                    color: prop['chart.title.xaxis.color'] || 'black',\\\\n					tag: 'title xaxis'\\\\n				});\\\\n            }\\\\n    \\\\n            // Y axis title\\\\n            if (typeof(prop['chart.title.yaxis']) == 'string' && prop['chart.title.yaxis'].length) {\\\\n    \\\\n                var size  = prop['chart.text.size'] + 2;\\\\n                var font  = prop['chart.text.font'];\\\\n                var angle = 270;\\\\n                var bold  = prop['chart.title.yaxis.bold'];\\\\n                var color = prop['chart.title.yaxis.color'];\\\\n    \\\\n                if (typeof(prop['chart.title.yaxis.pos']) == 'number') {\\\\n                    var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;\\\\n                } else {\\\\n                    var yaxis_title_pos = ((gutterLeft - 25) / gutterLeft) * gutterLeft;\\\\n                }\\\\n    \\\\n                if (typeof prop['chart.title.yaxis.size'] === 'number') {\\\\n                    size = prop['chart.title.yaxis.size'];\\\\n                }\\\\n    \\\\n                if (typeof prop['chart.title.yaxis.font'] === 'string') {\\\\n                    font = prop['chart.title.yaxis.font'];\\\\n                }\\\\n    \\\\n                if (   prop['chart.title.yaxis.align'] == 'right'\\\\n                    || prop['chart.title.yaxis.position'] == 'right'\\\\n                    || (obj.type === 'hbar' && prop['chart.yaxispos'] === 'right' && typeof prop['chart.title.yaxis.align'] === 'undefined' && typeof prop['chart.title.yaxis.position'] === 'undefined')\\\\n                   ) {\\\\n    \\\\n                    angle = 90;\\\\n                    yaxis_title_pos = prop['chart.title.yaxis.pos'] ? (ca.width - gutterRight) + (prop['chart.title.yaxis.pos'] * gutterRight) :\\\\n                                                                       ca.width - gutterRight + prop['chart.text.size'] + 5;\\\\n                } else {\\\\n                    yaxis_title_pos = yaxis_title_pos;\\\\n                }\\\\n                \\\\n                var y = ((ca.height - gutterTop - gutterBottom) / 2) + gutterTop;\\\\n                \\\\n                // Specifically specified X/Y positions\\\\n                if (typeof prop['chart.title.yaxis.x'] === 'number') {\\\\n                    yaxis_title_pos = prop['chart.title.yaxis.x'];\\\\n                }\\\\n    \\\\n                if (typeof prop['chart.title.yaxis.y'] === 'number') {\\\\n                    y = prop['chart.title.yaxis.y'];\\\\n                }\\\\n\\\\n                co.fillStyle = color;\\\\n                RG.text2(prop['chart.text.accessible'] ? obj.context : co,  {\\\\n					'font':font,\\\\n					'size':size,\\\\n					'x':yaxis_title_pos,\\\\n					'y':y,\\\\n					'valign':'center',\\\\n					'halign':'center',\\\\n					'angle':angle,\\\\n					'bold':bold,\\\\n					'text':prop['chart.title.yaxis'],\\\\n					'tag':'title yaxis',\\\\n                    accessible: false\\\\n				});\\\\n            }\\\\n    \\\\n            /**\\\\n            * If the background color is spec ified - draw that. It's a rectangle that fills the\\\\n            * entire area within the gutters\\\\n            */\\\\n            var bgcolor = prop['chart.background.color'];\\\\n            if (bgcolor) {\\\\n                co.fillStyle = bgcolor;\\\\n                co.fillRect(gutterLeft + 0.5, gutterTop + 0.5, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Draw horizontal background bars\\\\n            */\\\\n            var numbars   = (prop['chart.ylabels.count'] || 5);\\\\n            var barHeight = (ca.height - gutterBottom - gutterTop) / numbars;\\\\n\\\\n            co.beginPath();\\\\n                co.fillStyle   = prop['chart.background.barcolor1'];\\\\n                co.strokeStyle = co.fillStyle;\\\\n                height = (ca.height - gutterBottom);\\\\n\\\\n                for (var i=0; i<numbars; i+=2) {\\\\n                    co.rect(gutterLeft,\\\\n                        (i * barHeight) + gutterTop,\\\\n                        ca.width - gutterLeft - gutterRight,\\\\n                        barHeight\\\\n                    );\\\\n                }\\\\n            co.fill();\\\\n\\\\n\\\\n\\\\n            co.beginPath();\\\\n                co.fillStyle   = prop['chart.background.barcolor2'];\\\\n                co.strokeStyle = co.fillStyle;\\\\n        \\\\n                for (var i=1; i<numbars; i+=2) {\\\\n                    co.rect(\\\\n                        gutterLeft,\\\\n                        (i * barHeight) + gutterTop,\\\\n                        ca.width - gutterLeft - gutterRight,\\\\n                        barHeight\\\\n                    );\\\\n                }\\\\n            \\\\n            co.fill();\\\\n            \\\\n            // Close any errantly open path\\\\n            co.beginPath();\\\\n\\\\n\\\\n\\\\n\\\\n            //\\\\n            // The background grid is cached\\\\n            //\\\\n            var func = function (obj, cacheCanvas, cacheContext)\\\\n            {\\\\n                // Draw the background grid\\\\n                if (prop['chart.background.grid']) {\\\\n                \\\\n                    prop['chart.background.grid.autofit.numhlines'] += 0.0001;\\\\n    \\\\n                    // If autofit is specified, use the .numhlines and .numvlines along with the width to work\\\\n                    // out the hsize and vsize\\\\n                    if (prop['chart.background.grid.autofit']) {\\\\n    \\\\n                        /**\\\\n                        * Align the grid to the tickmarks\\\\n                        */\\\\n                        if (prop['chart.background.grid.autofit.align']) {\\\\n    \\\\n                            // Align the horizontal lines\\\\n                            if (obj.type === 'hbar') {\\\\n                                obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\\\\n                            }\\\\n    \\\\n                            // Align the vertical lines for the line\\\\n                            if (obj.type === 'line') {\\\\n                                if (typeof prop['chart.background.grid.autofit.numvlines'] === 'number') {\\\\n                                    // Nada\\\\n                                } else if (prop['chart.labels'] && prop['chart.labels'].length) {\\\\n                                    obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);\\\\n                                } else {\\\\n                                    obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);\\\\n                                }\\\\n                            } else if (obj.type === 'waterfall') {\\\\n                                obj.set(\\\\n                                    'backgroundGridAutofitNumvlines',\\\\n                                    obj.data.length + (prop['chart.total'] ? 1 : 0)\\\\n                                );\\\\n\\\\n                            // Align the vertical lines for the bar, Scatter\\\\n                            } else if ( (\\\\n                                obj.type === 'bar' ||\\\\n                                obj.type === 'scatter'\\\\n                                )\\\\n                                \\\\n                                && (\\\\n                                       (prop['chart.labels'] && prop['chart.labels'].length)\\\\n                                    || obj.type === 'bar'\\\\n                                   )\\\\n                            ) {\\\\n    \\\\n                                var len = (prop['chart.labels'] && prop['chart.labels'].length) || obj.data.length;\\\\n    \\\\n    \\\\n                                obj.set({\\\\n                                    backgroundGridAutofitNumvlines: len\\\\n                                });\\\\n    \\\\n                            // Gantt\\\\n                            } else if (obj.type === 'gantt') {\\\\n    \\\\n                                if (typeof obj.get('chart.background.grid.autofit.numvlines') === 'number') {\\\\n                                    // Nothing to do here\\\\n                                } else {\\\\n                                    obj.set('chart.background.grid.autofit.numvlines', prop['chart.xmax']);\\\\n                                }\\\\n    \\\\n                                obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\\\\n                            \\\\n                            // HBar\\\\n                            } else if (obj.type === 'hbar' && RG.isNull(prop['chart.background.grid.autofit.numhlines']) ) {\\\\n                                obj.set('chart.background.grid.autofit.numhlines', obj.data.length);\\\\n                            }\\\\n                        }\\\\n    \\\\n                        var vsize = ((cacheCanvas.width - gutterLeft - gutterRight)) / prop['chart.background.grid.autofit.numvlines'];\\\\n                        var hsize = (cacheCanvas.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];\\\\n    \\\\n                        obj.Set('chart.background.grid.vsize', vsize);\\\\n                        obj.Set('chart.background.grid.hsize', hsize);\\\\n                    }\\\\n    \\\\n                    co.beginPath();\\\\n                    cacheContext.lineWidth   = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;\\\\n                    cacheContext.strokeStyle = prop['chart.background.grid.color'];\\\\n\\\\n                    // Dashed background grid\\\\n                    if (prop['chart.background.grid.dashed'] && typeof cacheContext.setLineDash == 'function') {\\\\n                        cacheContext.setLineDash([3,5]);\\\\n                    }\\\\n                    \\\\n                    // Dotted background grid\\\\n                    if (prop['chart.background.grid.dotted'] && typeof cacheContext.setLineDash == 'function') {\\\\n                        cacheContext.setLineDash([1,3]);\\\\n                    }\\\\n                    \\\\n                    co.beginPath();\\\\n        \\\\n        \\\\n                    // Draw the horizontal lines\\\\n                    if (prop['chart.background.grid.hlines']) {\\\\n                        height = (cacheCanvas.height - gutterBottom)\\\\n                        var hsize = prop['chart.background.grid.hsize'];\\\\n                        for (y=gutterTop; y<=height; y+=hsize) {\\\\n                            cacheContext.moveTo(gutterLeft, ma.round(y));\\\\n                            cacheContext.lineTo(ca.width - gutterRight, ma.round(y));\\\\n                        }\\\\n                    }\\\\n        \\\\n                    if (prop['chart.background.grid.vlines']) {\\\\n                        // Draw the vertical lines\\\\n                        var width = (cacheCanvas.width - gutterRight);\\\\n                        var vsize = prop['chart.background.grid.vsize'];\\\\n\\\\n                        for (x=gutterLeft; ma.round(x)<=width; x+=vsize) {\\\\n                            cacheContext.moveTo(ma.round(x), gutterTop);\\\\n                            cacheContext.lineTo(ma.round(x), ca.height - gutterBottom);\\\\n                        }\\\\n                    }\\\\n        \\\\n                    if (prop['chart.background.grid.border']) {\\\\n                        // Make sure a rectangle, the same colour as the grid goes around the graph\\\\n                        cacheContext.strokeStyle = prop['chart.background.grid.color'];\\\\n                        cacheContext.strokeRect(ma.round(gutterLeft), ma.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);\\\\n                    }\\\\n                }\\\\n    \\\\n                cacheContext.stroke();\\\\n    \\\\n    \\\\n    \\\\n                // Necessary to ensure the grids drawn before continuing\\\\n                cacheContext.beginPath();\\\\n                cacheContext.closePath();\\\\n            }\\\\n            \\\\n            // Now a cached draw in newer browsers\\\\n            RG.cachedDraw(obj, obj.uid + '_background', func);\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            // If it's a bar and 3D variant, translate\\\\n            if (variant == '3d') {\\\\n                co.restore();\\\\n            }\\\\n\\\\n            // Reset the line dash\\\\n            if (typeof co.setLineDash == 'function') {\\\\n                co.setLineDash([1,0]);\\\\n            }\\\\n    \\\\n            co.stroke();\\\\n\\\\n\\\\n\\\\n        // Draw the title if one is set\\\\n        if ( typeof(obj.properties['chart.title']) == 'string') {\\\\n\\\\n            var prop = obj.properties;\\\\n\\\\n            RG.drawTitle(\\\\n                obj,\\\\n                prop['chart.title'],\\\\n                obj.gutterTop,\\\\n                null,\\\\n                prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2,\\\\n                obj\\\\n            );\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Formats a number with thousand seperators so it's easier to read\\\\n    * \\\\n    * @param  integer obj The chart object\\\\n    * @param  integer num The number to format\\\\n    * @param  string      The (optional) string to prepend to the string\\\\n    * @param  string      The (optional) string to append to the string\\\\n    * @return string      The formatted number\\\\n    */\\\\n    RG.numberFormat =\\\\n    RG.number_format = function (obj, num)\\\\n    {\\\\n        var ca   = obj.canvas;\\\\n        var co   = obj.context;\\\\n        var prop = obj.properties;\\\\n\\\\n        var i;\\\\n        var prepend = arguments[2] ? String(arguments[2]) : '';\\\\n        var append  = arguments[3] ? String(arguments[3]) : '';\\\\n        var output  = '';\\\\n        var decimal = '';\\\\n        var decimal_seperator  = typeof prop['chart.scale.point'] == 'string' ? prop['chart.scale.point'] : '.';\\\\n        var thousand_seperator = typeof prop['chart.scale.thousand'] == 'string' ? prop['chart.scale.thousand'] : ',';\\\\n        RegExp.\\\\\\\$1   = '';\\\\n        var i,j;\\\\n\\\\n        if (typeof prop['chart.scale.formatter'] === 'function') {\\\\n            return prop['chart.scale.formatter'](obj, num);\\\\n        }\\\\n\\\\n        // Ignore the preformatted version of \\\\\\\"1e-2\\\\\\\"\\\\n        if (String(num).indexOf('e') > 0) {\\\\n            return String(prepend + String(num) + append);\\\\n        }\\\\n\\\\n        // We need then number as a string\\\\n        num = String(num);\\\\n        \\\\n        // Take off the decimal part - we re-append it later\\\\n        if (num.indexOf('.') > 0) {\\\\n            var tmp = num;\\\\n            num     = num.replace(/\\\\\\\\.(.*)/, ''); // The front part of the number\\\\n            decimal = tmp.replace(/(.*)\\\\\\\\.(.*)/, '\\\\\\\$2'); // The decimal part of the number\\\\n        }\\\\n\\\\n        // Thousand seperator\\\\n        //var seperator = arguments[1] ? String(arguments[1]) : ',';\\\\n        var seperator = thousand_seperator;\\\\n        \\\\n        /**\\\\n        * Work backwards adding the thousand seperators\\\\n        */\\\\n        var foundPoint;\\\\n        for (i=(num.length - 1),j=0; i>=0; j++,i--) {\\\\n            var character = num.charAt(i);\\\\n            \\\\n            if ( j % 3 == 0 && j != 0) {\\\\n                output += seperator;\\\\n            }\\\\n            \\\\n            /**\\\\n            * Build the output\\\\n            */\\\\n            output += character;\\\\n        }\\\\n        \\\\n        /**\\\\n        * Now need to reverse the string\\\\n        */\\\\n        var rev = output;\\\\n        output = '';\\\\n        for (i=(rev.length - 1); i>=0; i--) {\\\\n            output += rev.charAt(i);\\\\n        }\\\\n\\\\n        // Tidy up\\\\n        //output = output.replace(/^-,/, '-');\\\\n        if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {\\\\n            output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);\\\\n        }\\\\n\\\\n        // Reappend the decimal\\\\n        if (decimal.length) {\\\\n            output =  output + decimal_seperator + decimal;\\\\n            decimal = '';\\\\n            RegExp.\\\\\\\$1 = '';\\\\n        }\\\\n\\\\n        // Minor bugette\\\\n        if (output.charAt(0) == '-') {\\\\n            output = output.replace(/-/, '');\\\\n            prepend = '-' + prepend;\\\\n        }\\\\n\\\\n        return prepend + output + append;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws horizontal coloured bars on something like the bar, line or scatter\\\\n    */\\\\n    RG.drawBars =\\\\n    RG.DrawBars = function (obj)\\\\n    {\\\\n        var prop  = obj.properties;\\\\n        var co    = obj.context;\\\\n        var ca    = obj.canvas;\\\\n        var hbars = prop['chart.background.hbars'];\\\\n\\\\n        if (hbars === null) {\\\\n            return;\\\\n        }\\\\n\\\\n        /**\\\\n        * Draws a horizontal bar\\\\n        */\\\\n        co.beginPath();\\\\n\\\\n        for (i=0,len=hbars.length; i<len; ++i) {\\\\n        \\\\n            var start  = hbars[i][0];\\\\n            var length = hbars[i][1];\\\\n            var color  = hbars[i][2];\\\\n            \\\\n\\\\n            // Perform some bounds checking\\\\n            if(RG.is_null(start))start = obj.scale2.max\\\\n            if (start > obj.scale2.max) start = obj.scale2.max;\\\\n            if (RG.is_null(length)) length = obj.scale2.max - start;\\\\n            if (start + length > obj.scale2.max) length = obj.scale2.max - start;\\\\n            if (start + length < (-1 * obj.scale2.max) ) length = (-1 * obj.scale2.max) - start;\\\\n\\\\n            if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < (obj.scale2.max * -2)) {\\\\n                length = obj.scale2.max * -2;\\\\n            }\\\\n\\\\n\\\\n            /**\\\\n            * Draw the bar\\\\n            */\\\\n            var x = prop['chart.gutter.left'];\\\\n            var y = obj.getYCoord(start);\\\\n            var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];\\\\n            var h = obj.getYCoord(start + length) - y;\\\\n\\\\n            // Accommodate Opera :-/\\\\n            if (RG.ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {\\\\n                h *= -1;\\\\n                y = y - h;\\\\n            }\\\\n\\\\n            /**\\\\n            * Account for X axis at the top\\\\n            */\\\\n            if (prop['chart.xaxispos'] == 'top') {\\\\n                y  = ca.height - y;\\\\n                h *= -1;\\\\n            }\\\\n\\\\n            co.fillStyle = color;\\\\n            co.fillRect(x, y, w, h);\\\\n        }\\\\n/*\\\\n\\\\n\\\\n            \\\\n\\\\n\\\\n            // If the X axis is at the bottom, and a negative max is given, warn the user\\\\n            if (obj.Get('chart.xaxispos') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {\\\\n                alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');\\\\n            }\\\\n\\\\n            var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));\\\\n            //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;\\\\n            var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);\\\\n\\\\n            // Account for the X axis being in the center\\\\n            if (obj.Get('chart.xaxispos') == 'center') {\\\\n                ystart /= 2;\\\\n                //height /= 2;\\\\n            }\\\\n            \\\\n            ystart += obj.Get('chart.gutter.top')\\\\n\\\\n            var x = obj.Get('chart.gutter.left');\\\\n            var y = ystart - height;\\\\n            var w = obj.canvas.width - obj.Get('chart.gutter.left') - obj.Get('chart.gutter.right');\\\\n            var h = height;\\\\n\\\\n            // Accommodate Opera :-/\\\\n            if (navigator.userAgent.indexOf('Opera') != -1 && obj.Get('chart.xaxispos') == 'center' && h < 0) {\\\\n                h *= -1;\\\\n                y = y - h;\\\\n            }\\\\n            \\\\n            /**\\\\n            * Account for X axis at the top\\\\n            */\\\\n            //if (obj.Get('chart.xaxispos') == 'top') {\\\\n            //    y  = obj.canvas.height - y;\\\\n            //    h *= -1;\\\\n            //}\\\\n\\\\n            //obj.context.fillStyle = hbars[i][2];\\\\n            //obj.context.fillRect(x, y, w, h);\\\\n        //}\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws in-graph labels.\\\\n    * \\\\n    * @param object obj The graph object\\\\n    */\\\\n    RG.drawInGraphLabels =\\\\n    RG.DrawInGraphLabels = function (obj)\\\\n    {\\\\n        var ca      = obj.canvas;\\\\n        var co      = obj.context;\\\\n        var prop    = obj.properties;\\\\n        var labels  = prop['chart.labels.ingraph'];\\\\n        var labels_processed = [];\\\\n\\\\n        // Defaults\\\\n        var fgcolor   = 'black';\\\\n        var bgcolor   = 'white';\\\\n        var direction = 1;\\\\n\\\\n        if (!labels) {\\\\n            return;\\\\n        }\\\\n\\\\n        /**\\\\n        * Preprocess the labels array. Numbers are expanded\\\\n        */\\\\n        for (var i=0,len=labels.length; i<len; i+=1) {\\\\n            if (typeof labels[i] === 'number') {\\\\n                for (var j=0; j<labels[i]; ++j) {\\\\n                    labels_processed.push(null);\\\\n                }\\\\n            } else if (typeof labels[i] === 'string' || typeof labels[i] === 'object') {\\\\n                labels_processed.push(labels[i]);\\\\n            \\\\n            } else {\\\\n                labels_processed.push('');\\\\n            }\\\\n        }\\\\n\\\\n        /**\\\\n        * Turn off any shadow\\\\n        */\\\\n        RG.noShadow(obj);\\\\n\\\\n        if (labels_processed && labels_processed.length > 0) {\\\\n\\\\n            for (var i=0,len=labels_processed.length; i<len; i+=1) {\\\\n                if (labels_processed[i]) {\\\\n                    var coords = obj.coords[i];\\\\n                    \\\\n                    if (coords && coords.length > 0) {\\\\n                        var x      = (obj.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0]);\\\\n                        var y      = (obj.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]);\\\\n                        var length = typeof labels_processed[i][4] === 'number' ? labels_processed[i][4] : 25;\\\\n    \\\\n                        co.beginPath();\\\\n                        co.fillStyle   = 'black';\\\\n                        co.strokeStyle = 'black';\\\\n                        \\\\n    \\\\n                        if (obj.type === 'bar') {\\\\n                        \\\\n                            /**\\\\n                            * X axis at the top\\\\n                            */\\\\n                            if (obj.Get('chart.xaxispos') == 'top') {\\\\n                                length *= -1;\\\\n                            }\\\\n    \\\\n                            if (prop['chart.variant'] == 'dot') {\\\\n                                co.moveTo(ma.round(x), obj.coords[i][1] - 5);\\\\n                                co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);\\\\n                                \\\\n                                var text_x = ma.round(x);\\\\n                                var text_y = obj.coords[i][1] - 5 - length;\\\\n                            \\\\n                            } else if (prop['chart.variant'] == 'arrow') {\\\\n                                co.moveTo(ma.round(x), obj.coords[i][1] - 5);\\\\n                                co.lineTo(ma.round(x), obj.coords[i][1] - 5 - length);\\\\n                                \\\\n                                var text_x = ma.round(x);\\\\n                                var text_y = obj.coords[i][1] - 5 - length;\\\\n                            \\\\n                            } else {\\\\n    \\\\n                                co.arc(ma.round(x), y, 2.5, 0, 6.28, 0);\\\\n                                co.moveTo(ma.round(x), y);\\\\n                                co.lineTo(ma.round(x), y - length);\\\\n\\\\n                                var text_x = ma.round(x);\\\\n                                var text_y = y - length;\\\\n                            }\\\\n\\\\n                            co.stroke();\\\\n                            co.fill();\\\\n                            \\\\n    \\\\n                        } else {\\\\n\\\\n                            if (\\\\n                                typeof labels_processed[i] == 'object' &&\\\\n                                typeof labels_processed[i][3] == 'number' &&\\\\n                                labels_processed[i][3] == -1\\\\n                               ) {\\\\n\\\\n                                co.moveTo(ma.round(x), y + 5);\\\\n                                co.lineTo(ma.round(x), y + 5 + length);\\\\n                                \\\\n                                co.stroke();\\\\n                                co.beginPath();                                \\\\n                                \\\\n                                // This draws the arrow\\\\n                                co.moveTo(ma.round(x), y + 5);\\\\n                                co.lineTo(ma.round(x) - 3, y + 10);\\\\n                                co.lineTo(ma.round(x) + 3, y + 10);\\\\n                                co.closePath();\\\\n                                \\\\n                                var text_x = x;\\\\n                                var text_y = y + 5 + length;\\\\n                            \\\\n                            } else {\\\\n                                \\\\n                                var text_x = x;\\\\n                                var text_y = y - 5 - length;\\\\n\\\\n                                co.moveTo(ma.round(x), y - 5);\\\\n                                co.lineTo(ma.round(x), y - 5 - length);\\\\n                                \\\\n                                co.stroke();\\\\n                                co.beginPath();\\\\n                                \\\\n                                // This draws the arrow\\\\n                                co.moveTo(ma.round(x), y - 5);\\\\n                                co.lineTo(ma.round(x) - 3, y - 10);\\\\n                                co.lineTo(ma.round(x) + 3, y - 10);\\\\n                                co.closePath();\\\\n                            }\\\\n                        \\\\n                            co.fill();\\\\n                        }\\\\n\\\\n                        // Taken out on the 10th Nov 2010 - unnecessary\\\\n                        //var width = context.measureText(labels[i]).width;\\\\n                        \\\\n                        co.beginPath();\\\\n                            \\\\n                            // Fore ground color\\\\n                            co.fillStyle = (typeof labels_processed[i] === 'object' && typeof labels_processed[i][1] === 'string') ? labels_processed[i][1] : 'black';\\\\n\\\\n                            RG.text2(obj,{\\\\n                                'font':prop['chart.text.font'],\\\\n                                'size':prop['chart.text.size'],\\\\n                                'x':text_x,\\\\n                                'y':text_y + (obj.properties['chart.text.accessible'] ? 2 : 0),\\\\n                                'text': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][0] === 'string') ? labels_processed[i][0] : labels_processed[i],\\\\n                                'valign': 'bottom',\\\\n                                'halign':'center',\\\\n                                'bounding':true,\\\\n                                'bounding.fill': (typeof labels_processed[i] === 'object' && typeof labels_processed[i][2] === 'string') ? labels_processed[i][2] : 'white',\\\\n                                'tag':'labels ingraph'\\\\n                            });\\\\n                        co.fill();\\\\n                    }\\\\n                }\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function \\\\\\\"fills in\\\\\\\" key missing properties that various implementations lack\\\\n    * \\\\n    * @param object e The event object\\\\n    */\\\\n    RG.fixEventObject =\\\\n    RG.FixEventObject = function (e)\\\\n    {\\\\n        if (RG.ISOLD) {\\\\n            var e = event;\\\\n\\\\n            e.pageX  = (event.clientX + doc.body.scrollLeft);\\\\n            e.pageY  = (event.clientY + doc.body.scrollTop);\\\\n            e.target = event.srcElement;\\\\n            \\\\n            if (!doc.body.scrollTop && doc.documentElement.scrollTop) {\\\\n                e.pageX += parseInt(doc.documentElement.scrollLeft);\\\\n                e.pageY += parseInt(doc.documentElement.scrollTop);\\\\n            }\\\\n        }\\\\n\\\\n        \\\\n        // Any browser that doesn't implement stopPropagation() (MSIE)\\\\n        if (!e.stopPropagation) {\\\\n            e.stopPropagation = function () {window.event.cancelBubble = true;}\\\\n        }\\\\n        \\\\n        return e;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Thisz function hides the crosshairs coordinates\\\\n    */\\\\n    RG.hideCrosshairCoords =\\\\n    RG.HideCrosshairCoords = function ()\\\\n    {\\\\n        var div = RG.Registry.Get('chart.coordinates.coords.div');\\\\n\\\\n        if (   div\\\\n            && div.style.opacity == 1\\\\n            && div.__object__.Get('chart.crosshairs.coords.fadeout')\\\\n           ) {\\\\n            \\\\n            var style = RG.Registry.Get('chart.coordinates.coords.div').style;\\\\n\\\\n            setTimeout(function() {style.opacity = 0.9;}, 25);\\\\n            setTimeout(function() {style.opacity = 0.8;}, 50);\\\\n            setTimeout(function() {style.opacity = 0.7;}, 75);\\\\n            setTimeout(function() {style.opacity = 0.6;}, 100);\\\\n            setTimeout(function() {style.opacity = 0.5;}, 125);\\\\n            setTimeout(function() {style.opacity = 0.4;}, 150);\\\\n            setTimeout(function() {style.opacity = 0.3;}, 175);\\\\n            setTimeout(function() {style.opacity = 0.2;}, 200);\\\\n            setTimeout(function() {style.opacity = 0.1;}, 225);\\\\n            setTimeout(function() {style.opacity = 0;}, 250);\\\\n            setTimeout(function() {style.display = 'none';}, 275);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws the3D axes/background\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.draw3DAxes =\\\\n    RG.Draw3DAxes = function (obj)\\\\n    {\\\\n        var prop = obj.properties,\\\\n            co   = obj.context,\\\\n            ca   = obj.canvas;\\\\n\\\\n        var gutterLeft    = obj.gutterLeft,\\\\n            gutterRight   = obj.gutterRight,\\\\n            gutterTop     = obj.gutterTop,\\\\n            gutterBottom  = obj.gutterBottom,\\\\n            xaxispos      = prop['chart.xaxispos'],\\\\n            graphArea     = ca.height - gutterTop - gutterBottom,\\\\n            halfGraphArea = graphArea / 2,\\\\n            offsetx       = prop['chart.variant.threed.offsetx'],\\\\n            offsety       = prop['chart.variant.threed.offsety'],\\\\n            xaxis         = prop['chart.variant.threed.xaxis'],\\\\n            yaxis         = prop['chart.variant.threed.yaxis']\\\\n        \\\\n\\\\n        //\\\\n        // Draw the 3D Y axis\\\\n        //\\\\n        if (yaxis) {\\\\n            RG.draw3DYAxis(obj);\\\\n        }\\\\n        \\\\n        \\\\n        \\\\n        // X axis\\\\n        if (xaxis) {\\\\n            if (xaxispos === 'center') {\\\\n                RG.path2(\\\\n                    co,\\\\n                    'b m % % l % % l % % l % % c s #aaa f #ddd',\\\\n                    gutterLeft,gutterTop + halfGraphArea,\\\\n                    gutterLeft + offsetx,gutterTop + halfGraphArea - offsety,\\\\n                    ca.width - gutterRight + offsetx,gutterTop + halfGraphArea - offsety,\\\\n                    ca.width - gutterRight,gutterTop + halfGraphArea\\\\n                );\\\\n\\\\n            } else {\\\\n            \\\\n                if (obj.type === 'hbar') {\\\\n                    var xaxisYCoord = obj.canvas.height - obj.properties['chart.gutter.bottom'];\\\\n                } else {\\\\n                    var xaxisYCoord = obj.getYCoord(0);\\\\n                }\\\\n\\\\n                RG.path2(\\\\n                    co,\\\\n                    'm % % l % % l % % l % % c s #aaa f #ddd',\\\\n                    gutterLeft,xaxisYCoord,\\\\n                    gutterLeft + offsetx,xaxisYCoord - offsety,\\\\n                    ca.width - gutterRight + offsetx,xaxisYCoord - offsety,\\\\n                    ca.width - gutterRight,xaxisYCoord\\\\n                );\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws the3D Y axis/background\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.draw3DYAxis = function (obj)\\\\n    {\\\\n        var prop = obj.properties,\\\\n            co   = obj.context,\\\\n            ca   = obj.canvas;\\\\n\\\\n        var gutterLeft    = obj.gutterLeft,\\\\n            gutterRight   = obj.gutterRight,\\\\n            gutterTop     = obj.gutterTop,\\\\n            gutterBottom  = obj.gutterBottom,\\\\n            xaxispos      = prop['chart.xaxispos'],\\\\n            graphArea     = ca.height - gutterTop - gutterBottom,\\\\n            halfGraphArea = graphArea / 2,\\\\n            offsetx       = prop['chart.variant.threed.offsetx'],\\\\n            offsety       = prop['chart.variant.threed.offsety']\\\\n\\\\n        \\\\n        \\\\n        // Y axis\\\\n        // Commented out the if condition because of drawing oddities\\\\n        //if (!prop['chart.noaxes'] && !prop['chart.noyaxis']) {\\\\n\\\\n            if ( (obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'center') {\\\\n                var x = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;\\\\n            } else if ((obj.type === 'hbar' || obj.type === 'bar') && prop['chart.yaxispos'] === 'right') {\\\\n                var x = ca.width - gutterRight;\\\\n            } else {\\\\n                var x = gutterLeft;\\\\n            }\\\\n\\\\n            RG.path2(\\\\n                co,\\\\n                'b m % % l % % l % % l % % s #aaa f #ddd',\\\\n                x,gutterTop,\\\\n                x + offsetx,gutterTop - offsety,\\\\n                x + offsetx,ca.height - gutterBottom - offsety,\\\\n                x,ca.height - gutterBottom\\\\n            );\\\\n        //}\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws a rectangle with curvy corners\\\\n    * \\\\n    * @param co object The context\\\\n    * @param x number The X coordinate (top left of the square)\\\\n    * @param y number The Y coordinate (top left of the square)\\\\n    * @param w number The width of the rectangle\\\\n    * @param h number The height of the rectangle\\\\n    * @param   number The radius of the curved corners\\\\n    * @param   boolean Whether the top left corner is curvy\\\\n    * @param   boolean Whether the top right corner is curvy\\\\n    * @param   boolean Whether the bottom right corner is curvy\\\\n    * @param   boolean Whether the bottom left corner is curvy\\\\n    */\\\\n    RG.strokedCurvyRect = function (co, x, y, w, h)\\\\n    {\\\\n        // The corner radius\\\\n        var r = arguments[5] ? arguments[5] : 3;\\\\n\\\\n        // The corners\\\\n        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;\\\\n        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;\\\\n        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;\\\\n        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;\\\\n\\\\n        co.beginPath();\\\\n\\\\n            // Top left side\\\\n            co.moveTo(x + (corner_tl ? r : 0), y);\\\\n            co.lineTo(x + w - (corner_tr ? r : 0), y);\\\\n            \\\\n            // Top right corner\\\\n            if (corner_tr) {\\\\n                co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, RG.TWOPI, false);\\\\n            }\\\\n\\\\n            // Top right side\\\\n            co.lineTo(x + w, y + h - (corner_br ? r : 0) );\\\\n\\\\n            // Bottom right corner\\\\n            if (corner_br) {\\\\n                co.arc(x + w - r, y - r + h, r, RG.TWOPI, RG.HALFPI, false);\\\\n            }\\\\n\\\\n            // Bottom right side\\\\n            co.lineTo(x + (corner_bl ? r : 0), y + h);\\\\n\\\\n            // Bottom left corner\\\\n            if (corner_bl) {\\\\n                co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\\\\n            }\\\\n\\\\n            // Bottom left side\\\\n            co.lineTo(x, y + (corner_tl ? r : 0) );\\\\n\\\\n            // Top left corner\\\\n            if (corner_tl) {\\\\n                co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\\\\n            }\\\\n\\\\n        co.stroke();\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draws a filled rectangle with curvy corners\\\\n    * \\\\n    * @param context object The context\\\\n    * @param x       number The X coordinate (top left of the square)\\\\n    * @param y       number The Y coordinate (top left of the square)\\\\n    * @param w       number The width of the rectangle\\\\n    * @param h       number The height of the rectangle\\\\n    * @param         number The radius of the curved corners\\\\n    * @param         boolean Whether the top left corner is curvy\\\\n    * @param         boolean Whether the top right corner is curvy\\\\n    * @param         boolean Whether the bottom right corner is curvy\\\\n    * @param         boolean Whether the bottom left corner is curvy\\\\n    */\\\\n    RG.filledCurvyRect = function (co, x, y, w, h)\\\\n    {\\\\n        // The corner radius\\\\n        var r = arguments[5] ? arguments[5] : 3;\\\\n\\\\n        // The corners\\\\n        var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;\\\\n        var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;\\\\n        var corner_br = (arguments[8] || arguments[8] == null) ? true : false;\\\\n        var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;\\\\n\\\\n        co.beginPath();\\\\n\\\\n            // First draw the corners\\\\n\\\\n            // Top left corner\\\\n            if (corner_tl) {\\\\n                co.moveTo(x + r, y + r);\\\\n                co.arc(x + r, y + r, r, RG.PI, RG.PI + RG.HALFPI, false);\\\\n            } else {\\\\n                co.fillRect(x, y, r, r);\\\\n            }\\\\n\\\\n            // Top right corner\\\\n            if (corner_tr) {\\\\n                co.moveTo(x + w - r, y + r);\\\\n                co.arc(x + w - r, y + r, r, RG.PI + RG.HALFPI, 0, false);\\\\n            } else {\\\\n                co.moveTo(x + w - r, y);\\\\n                co.fillRect(x + w - r, y, r, r);\\\\n            }\\\\n\\\\n\\\\n            // Bottom right corner\\\\n            if (corner_br) {\\\\n                co.moveTo(x + w - r, y + h - r);\\\\n                co.arc(x + w - r, y - r + h, r, 0, RG.HALFPI, false);\\\\n            } else {\\\\n                co.moveTo(x + w - r, y + h - r);\\\\n                co.fillRect(x + w - r, y + h - r, r, r);\\\\n            }\\\\n\\\\n            // Bottom left corner\\\\n            if (corner_bl) {\\\\n                co.moveTo(x + r, y + h - r);\\\\n                co.arc(x + r, y - r + h, r, RG.HALFPI, RG.PI, false);\\\\n            } else {\\\\n                co.moveTo(x, y + h - r);\\\\n                co.fillRect(x, y + h - r, r, r);\\\\n            }\\\\n\\\\n            // Now fill it in\\\\n            co.fillRect(x + r, y, w - r - r, h);\\\\n            co.fillRect(x, y + r, r + 1, h - r - r);\\\\n            co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);\\\\n\\\\n        co.fill();\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Hides the zoomed canvas\\\\n    */\\\\n    RG.hideZoomedCanvas =\\\\n    RG.HideZoomedCanvas = function ()\\\\n    {\\\\n        var interval = 10;\\\\n        var frames   = 15;\\\\n\\\\n        if (typeof RG.zoom_image === 'object') {\\\\n            var obj  = RG.zoom_image.obj;\\\\n            var prop = obj.properties;\\\\n        } else {\\\\n            return;\\\\n        }\\\\n\\\\n        if (prop['chart.zoom.fade.out']) {\\\\n            for (var i=frames,j=1; i>=0; --i, ++j) {\\\\n                if (typeof RG.zoom_image === 'object') {\\\\n                    setTimeout(\\\\\\\"RGraph.zoom_image.style.opacity = \\\\\\\" + String(i / 10), j * interval);\\\\n                }\\\\n            }\\\\n\\\\n            if (typeof RG.zoom_background === 'object') {\\\\n                setTimeout(\\\\\\\"RGraph.zoom_background.style.opacity = \\\\\\\" + String(i / frames), j * interval);\\\\n            }\\\\n        }\\\\n\\\\n        if (typeof RG.zoom_image === 'object') {\\\\n            setTimeout(\\\\\\\"RGraph.zoom_image.style.display = 'none'\\\\\\\", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);\\\\n        }\\\\n\\\\n        if (typeof RG.zoom_background === 'object') {\\\\n            setTimeout(\\\\\\\"RGraph.zoom_background.style.display = 'none'\\\\\\\", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Adds an event handler\\\\n    * \\\\n    * @param object obj   The graph object\\\\n    * @param string event The name of the event, eg ontooltip\\\\n    * @param object func  The callback function\\\\n    */\\\\n    RG.addCustomEventListener =\\\\n    RG.AddCustomEventListener = function (obj, name, func)\\\\n    {\\\\n        // Initialise the events array if necessary\\\\n        if (typeof RG.events[obj.uid] === 'undefined') {\\\\n            RG.events[obj.uid] = [];\\\\n        }\\\\n        \\\\n        // Prepend \\\\\\\"on\\\\\\\" if necessary\\\\n        if (name.substr(0, 2) !== 'on') {\\\\n            name = 'on' + name;\\\\n        }\\\\n\\\\n        RG.events[obj.uid].push([obj, name, func]);\\\\n\\\\n        return RG.events[obj.uid].length - 1;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Used to fire one of the RGraph custom events\\\\n    * \\\\n    * @param object obj   The graph object that fires the event\\\\n    * @param string event The name of the event to fire\\\\n    */\\\\n    RG.fireCustomEvent =\\\\n    RG.FireCustomEvent = function (obj, name)\\\\n    {\\\\n        if (obj && obj.isRGraph) {\\\\n        \\\\n            // This allows the eventsMouseout property to work\\\\n            // (for some reason...)\\\\n            if (name.match(/(on)?mouseout/) && typeof obj.properties['chart.events.mouseout'] === 'function') {\\\\n                (obj.properties['chart.events.mouseout'])(obj);\\\\n            }\\\\n        \\\\n            // DOM1 style of adding custom events\\\\n            if (obj[name]) {\\\\n                (obj[name])(obj);\\\\n            }\\\\n            \\\\n            var uid = obj.uid;\\\\n\\\\n            if (   typeof uid === 'string'\\\\n                && typeof RG.events === 'object'\\\\n                && typeof RG.events[uid] === 'object'\\\\n                && RG.events[uid].length > 0) {\\\\n\\\\n                for(var j=0; j<RG.events[uid].length; ++j) {\\\\n                    if (RG.events[uid][j] && RG.events[uid][j][1] === name) {\\\\n                        RG.events[uid][j][2](obj);\\\\n                    }\\\\n                }\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Clears all the custom event listeners that have been registered\\\\n    * \\\\n    * @param    string Limits the clearing to this object ID\\\\n    */\\\\n    RGraph.removeAllCustomEventListeners =\\\\n    RGraph.RemoveAllCustomEventListeners = function ()\\\\n    {\\\\n        var id = arguments[0];\\\\n\\\\n        if (id && RG.events[id]) {\\\\n            RG.events[id] = [];\\\\n        } else {\\\\n            RG.events = [];\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Clears a particular custom event listener\\\\n    * \\\\n    * @param object obj The graph object\\\\n    * @param number i   This is the index that is return by .AddCustomEventListener()\\\\n    */\\\\n    RG.removeCustomEventListener =\\\\n    RG.RemoveCustomEventListener = function (obj, i)\\\\n    {\\\\n        if (   typeof RG.events === 'object'\\\\n            && typeof RG.events[obj.id] === 'object'\\\\n            && typeof RG.events[obj.id][i] === 'object') {\\\\n            \\\\n            RG.events[obj.id][i] = null;\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This draws the background\\\\n    * \\\\n    * @param object obj The graph object\\\\n    */\\\\n    RG.drawBackgroundImage =\\\\n    RG.DrawBackgroundImage = function (obj)\\\\n    {\\\\n        var prop = obj.properties;\\\\n        var ca   = obj.canvas;\\\\n        var co   = obj.context;\\\\n\\\\n        if (typeof prop['chart.background.image'] === 'string') {\\\\n            if (typeof ca.__rgraph_background_image__ === 'undefined') {\\\\n                var img = new Image();\\\\n                img.__object__  = obj;\\\\n                img.__canvas__  = ca;\\\\n                img.__context__ = co;\\\\n                img.src         = obj.Get('chart.background.image');\\\\n                \\\\n                ca.__rgraph_background_image__ = img;\\\\n            } else {\\\\n                img = ca.__rgraph_background_image__;\\\\n            }\\\\n\\\\n            // When the image has loaded - redraw the canvas\\\\n            img.onload = function ()\\\\n            {\\\\n                obj.__rgraph_background_image_loaded__ = true;\\\\n                RG.clear(ca);\\\\n                RG.redrawCanvas(ca);\\\\n            }\\\\n                \\\\n            var gutterLeft   = obj.gutterLeft;\\\\n            var gutterRight  = obj.gutterRight;\\\\n            var gutterTop    = obj.gutterTop;\\\\n            var gutterBottom = obj.gutterBottom;\\\\n            var stretch      = prop['chart.background.image.stretch'];\\\\n            var align        = prop['chart.background.image.align'];\\\\n    \\\\n            // Handle chart.background.image.align\\\\n            if (typeof align === 'string') {\\\\n                if (align.indexOf('right') != -1) {\\\\n                    var x = ca.width - (prop['chart.background.image.w'] || img.width) - gutterRight;\\\\n                } else {\\\\n                    var x = gutterLeft;\\\\n                }\\\\n    \\\\n                if (align.indexOf('bottom') != -1) {\\\\n                    var y = ca.height - (prop['chart.background.image.h'] || img.height) - gutterBottom;\\\\n                } else {\\\\n                    var y = gutterTop;\\\\n                }\\\\n            } else {\\\\n                var x = gutterLeft || 25;\\\\n                var y = gutterTop || 25;\\\\n            }\\\\n\\\\n            // X/Y coords take precedence over the align\\\\n            var x = typeof prop['chart.background.image.x'] === 'number' ? prop['chart.background.image.x'] : x;\\\\n            var y = typeof prop['chart.background.image.y'] === 'number' ? prop['chart.background.image.y'] : y;\\\\n            var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;\\\\n            var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;\\\\n            \\\\n            /**\\\\n            * You can now specify the width and height of the image\\\\n            */\\\\n            if (typeof prop['chart.background.image.w'] === 'number') w  = prop['chart.background.image.w'];\\\\n            if (typeof prop['chart.background.image.h'] === 'number') h = prop['chart.background.image.h'];\\\\n\\\\n            var oldAlpha = co.globalAlpha;\\\\n                co.globalAlpha = prop['chart.background.image.alpha'];\\\\n                co.drawImage(img,x,y,w, h);\\\\n            co.globalAlpha = oldAlpha;\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function determines wshether an object has tooltips or not\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.hasTooltips = function (obj)\\\\n    {\\\\n        var prop = obj.properties;\\\\n\\\\n        if (typeof prop['chart.tooltips'] == 'object' && prop['chart.tooltips']) {\\\\n            for (var i=0,len=prop['chart.tooltips'].length; i<len; ++i) {\\\\n                if (!RG.is_null(obj.Get('chart.tooltips')[i])) {\\\\n                    return true;\\\\n                }\\\\n            }\\\\n        } else if (typeof prop['chart.tooltips'] === 'function') {\\\\n            return true;\\\\n        }\\\\n        \\\\n        return false;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function creates a (G)UID which can be used to identify objects.\\\\n    * \\\\n    * @return string (g)uid The (G)UID\\\\n    */\\\\n    RG.createUID =\\\\n    RG.CreateUID = function ()\\\\n    {\\\\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)\\\\n        {\\\\n            var r = ma.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\\\\n            return v.toString(16);\\\\n        });\\\\n    };\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the new object registry, used to facilitate multiple objects per canvas.\\\\n    * \\\\n    * @param object obj The object to register\\\\n    */\\\\n    RG.OR.add =\\\\n    RG.OR.Add = function (obj)\\\\n    {\\\\n        var uid = obj.uid;\\\\n        var id  = obj.canvas.id;\\\\n\\\\n        /**\\\\n        * Index the objects by UID\\\\n        */\\\\n        RG.ObjectRegistry.objects.byUID.push([uid, obj]);\\\\n        \\\\n        /**\\\\n        * Index the objects by the canvas that they're drawn on\\\\n        */\\\\n        RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Remove an object from the object registry\\\\n    * \\\\n    * @param object obj The object to remove.\\\\n    */\\\\n    RG.OR.remove =\\\\n    RG.OR.Remove = function (obj)\\\\n    {\\\\n        var id  = obj.id;\\\\n        var uid = obj.uid;\\\\n\\\\n        for (var i=0; i<RG.ObjectRegistry.objects.byUID.length; ++i) {\\\\n            if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {\\\\n                RG.ObjectRegistry.objects.byUID[i] = null;\\\\n            }\\\\n        }\\\\n\\\\n\\\\n        for (var i=0; i<RG.ObjectRegistry.objects.byCanvasID.length; ++i) {\\\\n            if (   RG.ObjectRegistry.objects.byCanvasID[i]\\\\n                && RG.ObjectRegistry.objects.byCanvasID[i][1]\\\\n                && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {\\\\n                \\\\n                RG.ObjectRegistry.objects.byCanvasID[i] = null;\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,\\\\n    * or the canvas itself, then only objects pertaining to that canvas are cleared.\\\\n    * \\\\n    * @param mixed   Either a canvas object (as returned by document.getElementById()\\\\n    *                or the ID of a canvas (ie a string)\\\\n    */\\\\n    RG.OR.clear =\\\\n    RG.OR.Clear = function ()\\\\n    {\\\\n        // If an ID is supplied restrict the learing to that\\\\n        if (arguments[0]) {\\\\n            var id      = (typeof arguments[0] === 'object' ? arguments[0].id : arguments[0]);\\\\n            var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);\\\\n\\\\n            for (var i=0,len=objects.length; i<len; ++i) {\\\\n                RG.ObjectRegistry.remove(objects[i]);\\\\n            }\\\\n\\\\n        } else {\\\\n\\\\n            RG.ObjectRegistry.objects            = {};\\\\n            RG.ObjectRegistry.objects.byUID      = [];\\\\n            RG.ObjectRegistry.objects.byCanvasID = [];\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Lists all objects in the ObjectRegistry\\\\n    * \\\\n    * @param boolean ret Whether to return the list or alert() it\\\\n    */\\\\n    RG.OR.list =\\\\n    RG.OR.List = function ()\\\\n    {\\\\n        var list = [];\\\\n\\\\n        for (var i=0,len=RG.ObjectRegistry.objects.byUID.length; i<len; ++i) {\\\\n            if (RG.ObjectRegistry.objects.byUID[i]) {\\\\n                list.push(RG.ObjectRegistry.objects.byUID[i][1].type);\\\\n            }\\\\n        }\\\\n        \\\\n        if (arguments[0]) {\\\\n            return list;\\\\n        } else {\\\\n            \\\\\\\$p(list);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Clears the ObjectRegistry of objects that are of a certain given type\\\\n    * \\\\n    * @param type string The type to clear\\\\n    */\\\\n    RG.OR.clearByType =\\\\n    RG.OR.ClearByType = function (type)\\\\n    {\\\\n        var objects = RG.ObjectRegistry.objects.byUID;\\\\n\\\\n        for (var i=0,len=objects.length; i<len; ++i) {\\\\n            if (objects[i]) {\\\\n                var uid = objects[i][0];\\\\n                var obj = objects[i][1];\\\\n                \\\\n                if (obj && obj.type == type) {\\\\n                    RG.ObjectRegistry.remove(obj);\\\\n                }\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function provides an easy way to go through all of the objects that are held in the\\\\n    * Registry\\\\n    * \\\\n    * @param func function This function is run for every object. Its passed the object as an argument\\\\n    * @param string type Optionally, you can pass a type of object to look for\\\\n    */\\\\n    RG.OR.iterate =\\\\n    RG.OR.Iterate = function (func)\\\\n    {\\\\n        var objects = RGraph.ObjectRegistry.objects.byUID;\\\\n\\\\n        for (var i=0,len=objects.length; i<len; ++i) {\\\\n        \\\\n            if (typeof arguments[1] === 'string') {\\\\n                \\\\n                var types = arguments[1].split(/,/);\\\\n\\\\n                for (var j=0,len2=types.length; j<len2; ++j) {\\\\n                    if (types[j] == objects[i][1].type) {\\\\n                        func(objects[i][1]);\\\\n                    }\\\\n                }\\\\n            } else {\\\\n                func(objects[i][1]);\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Retrieves all objects for a given canvas id\\\\n    * \\\\n    * @patarm id string The canvas ID to get objects for.\\\\n    */\\\\n    RG.OR.getObjectsByCanvasID = function (id)\\\\n    {\\\\n        var store = RG.ObjectRegistry.objects.byCanvasID;\\\\n        var ret = [];\\\\n\\\\n        // Loop through all of the objects and return the appropriate ones\\\\n        for (var i=0,len=store.length; i<len; ++i) {\\\\n            if (store[i] && store[i][0] == id ) {\\\\n                ret.push(store[i][1]);\\\\n            }\\\\n        }\\\\n\\\\n        return ret;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Retrieves the relevant object based on the X/Y position.\\\\n    * \\\\n    * @param  object e The event object\\\\n    * @return object   The applicable (if any) object\\\\n    */\\\\n    RG.OR.firstbyxy =\\\\n    RG.OR.getFirstObjectByXY =\\\\n    RG.OR.getObjectByXY = function (e)\\\\n    {\\\\n        var canvas  = e.target;\\\\n        var ret     = null;\\\\n        var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);\\\\n\\\\n        for (var i=(objects.length - 1); i>=0; --i) {\\\\n\\\\n            var obj = objects[i].getObjectByXY(e);\\\\n\\\\n            if (obj) {\\\\n                return obj;\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Retrieves the relevant objects based on the X/Y position.\\\\n    * NOTE This function returns an array of objects\\\\n    * \\\\n    * @param  object e The event object\\\\n    * @return          An array of pertinent objects. Note the there may be only one object\\\\n    */\\\\n    RG.OR.getObjectsByXY = function (e)\\\\n    {\\\\n        var canvas  = e.target;\\\\n        var ret     = [];\\\\n        var objects = RG.ObjectRegistry.getObjectsByCanvasID(canvas.id);\\\\n\\\\n        // Retrieve objects \\\\\\\"front to back\\\\\\\"\\\\n        for (var i=(objects.length - 1); i>=0; --i) {\\\\n\\\\n            var obj = objects[i].getObjectByXY(e);\\\\n\\\\n            if (obj) {\\\\n                ret.push(obj);\\\\n            }\\\\n        }\\\\n        \\\\n        return ret;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Retrieves the object with the corresponding UID\\\\n    * \\\\n    * @param string uid The UID to get the relevant object for\\\\n    */\\\\n    RG.OR.get =\\\\n    RG.OR.getObjectByUID = function (uid)\\\\n    {\\\\n        var objects = RG.ObjectRegistry.objects.byUID;\\\\n\\\\n        for (var i=0,len=objects.length; i<len; ++i) {\\\\n            if (objects[i] && objects[i][1].uid == uid) {\\\\n                return objects[i][1];\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Brings a chart to the front of the ObjectRegistry by\\\\n    * removing it and then readding it at the end and then\\\\n    * redrawing the canvas\\\\n    * \\\\n    * @param object  obj    The object to bring to the front\\\\n    * @param boolean redraw Whether to redraw the canvas after the \\\\n    *                       object has been moved\\\\n    */\\\\n    RG.OR.bringToFront = function (obj)\\\\n    {\\\\n        var redraw = typeof arguments[1] === 'undefined' ? true : arguments[1];\\\\n\\\\n        RG.ObjectRegistry.remove(obj);\\\\n        RG.ObjectRegistry.add(obj);\\\\n        \\\\n        if (redraw) {\\\\n            RG.redrawCanvas(obj.canvas);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Retrieves the objects that are the given type\\\\n    * \\\\n    * @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID\\\\n    * @param  string type   The type to look for\\\\n    * @return array         An array of one or more objects\\\\n    */\\\\n    RG.OR.type =\\\\n    RG.OR.getObjectsByType = function (type)\\\\n    {\\\\n        var objects = RG.ObjectRegistry.objects.byUID;\\\\n        var ret     = [];\\\\n\\\\n        for (var i=0,len=objects.length; i<len; ++i) {\\\\n\\\\n            if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {\\\\n                ret.push(objects[i][1]);\\\\n            }\\\\n        }\\\\n\\\\n        return ret;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Retrieves the FIRST object that matches the given type\\\\n    *\\\\n    * @param  string type   The type of object to look for\\\\n    * @return object        The FIRST object that matches the given type\\\\n    */\\\\n    RG.OR.first =\\\\n    RG.OR.getFirstObjectByType = function (type)\\\\n    {\\\\n        var objects = RG.ObjectRegistry.objects.byUID;\\\\n    \\\\n        for (var i=0,len=objects.length; i<len; ++i) {\\\\n            if (objects[i] && objects[i][1] && objects[i][1].type == type) {\\\\n                return objects[i][1];\\\\n            }\\\\n        }\\\\n        \\\\n        return null;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This takes centerx, centery, x and y coordinates and returns the\\\\n    * appropriate angle relative to the canvas angle system. Remember\\\\n    * that the canvas angle system starts at the EAST axis\\\\n    * \\\\n    * @param  number cx  The centerx coordinate\\\\n    * @param  number cy  The centery coordinate\\\\n    * @param  number x   The X coordinate (eg the mouseX if coming from a click)\\\\n    * @param  number y   The Y coordinate (eg the mouseY if coming from a click)\\\\n    * @return number     The relevant angle (measured in in RADIANS)\\\\n    */\\\\n    RG.getAngleByXY = function (cx, cy, x, y)\\\\n    {\\\\n        var angle = ma.atan((y - cy) / (x - cx));\\\\n            angle = ma.abs(angle)\\\\n\\\\n        if (x >= cx && y >= cy) {\\\\n            angle += RG.TWOPI;\\\\n\\\\n        } else if (x >= cx && y < cy) {\\\\n            angle = (RG.HALFPI - angle) + (RG.PI + RG.HALFPI);\\\\n\\\\n        } else if (x < cx && y < cy) {\\\\n            angle += RG.PI;\\\\n\\\\n        } else {\\\\n            angle = RG.PI - angle;\\\\n        }\\\\n\\\\n        /**\\\\n        * Upper and lower limit checking\\\\n        */\\\\n        if (angle > RG.TWOPI) {\\\\n            angle -= RG.TWOPI;\\\\n        }\\\\n\\\\n        return angle;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function returns the distance between two points. In effect the\\\\n    * radius of an imaginary circle that is centered on x1 and y1. The name\\\\n    * of this function is derived from the word \\\\\\\"Hypoteneuse\\\\\\\", which in\\\\n    * trigonmetry is the longest side of a triangle\\\\n    * \\\\n    * @param number x1 The original X coordinate\\\\n    * @param number y1 The original Y coordinate\\\\n    * @param number x2 The target X coordinate\\\\n    * @param number y2 The target Y  coordinate\\\\n    */\\\\n    RG.getHypLength = function (x1, y1, x2, y2)\\\\n    {\\\\n        var ret = ma.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\\\\n\\\\n        return ret;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function gets the end point (X/Y coordinates) of a given radius.\\\\n    * You pass it the center X/Y and the radius and this function will return\\\\n    * the endpoint X/Y coordinates.\\\\n    * \\\\n    * @param number cx The center X coord\\\\n    * @param number cy The center Y coord\\\\n    * @param number r  The lrngth of the radius\\\\n    */\\\\n    RG.getRadiusEndPoint = function (cx, cy, angle, radius)\\\\n    {\\\\n        var x = cx + (ma.cos(angle) * radius);\\\\n        var y = cy + (ma.sin(angle) * radius);\\\\n        \\\\n        return [x, y];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This installs all of the event listeners\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.installEventListeners =\\\\n    RG.InstallEventListeners = function (obj)\\\\n    {\\\\n        var prop = obj.properties;\\\\n\\\\n        /**\\\\n        * Don't attempt to install event listeners for older versions of MSIE\\\\n        */\\\\n        if (RG.ISOLD) {\\\\n            return;\\\\n        }\\\\n\\\\n        /**\\\\n        * If this function exists, then the dynamic file has been included.\\\\n        */\\\\n        if (RG.installCanvasClickListener) {\\\\n\\\\n            RG.installWindowMousedownListener(obj);\\\\n            RG.installWindowMouseupListener(obj);\\\\n            RG.installCanvasMousemoveListener(obj);\\\\n            RG.installCanvasMouseupListener(obj);\\\\n            RG.installCanvasMousedownListener(obj);\\\\n            RG.installCanvasClickListener(obj);\\\\n        \\\\n        } else if (   RG.hasTooltips(obj)\\\\n                   || prop['chart.adjustable']\\\\n                   || prop['chart.annotatable']\\\\n                   || prop['chart.contextmenu']\\\\n                   || prop['chart.resizable']\\\\n                   || prop['chart.key.interactive']\\\\n                   || prop['chart.events.click']\\\\n                   || prop['chart.events.mousemove']\\\\n                   || typeof obj.onclick === 'function'\\\\n                   || typeof obj.onmousemove === 'function'\\\\n                  ) {\\\\n\\\\n            alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Loosly mimicks the PHP function print_r();\\\\n    */\\\\n    RG.pr = function (obj)\\\\n    {\\\\n        var indent = (arguments[2] ? arguments[2] : '    ');\\\\n        var str    = '';\\\\n\\\\n        var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;\\\\n        \\\\n        if (counter >= 5) {\\\\n            return '';\\\\n        }\\\\n        \\\\n        switch (typeof obj) {\\\\n            \\\\n            case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;\\\\n            case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;\\\\n            case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;\\\\n            case 'function':  str += 'function () {}'; break;\\\\n            case 'undefined': str += 'undefined'; break;\\\\n            case 'null':      str += 'null'; break;\\\\n            \\\\n            case 'object':\\\\n                // In case of null\\\\n                if (RGraph.is_null(obj)) {\\\\n                    str += indent + 'null\\\\\\\\n';\\\\n                } else {\\\\n                    str += indent + 'Object {' + '\\\\\\\\n'\\\\n                    for (j in obj) {\\\\n                        str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\\\\\\\\n';\\\\n                    }\\\\n                    str += indent + '}';\\\\n                }\\\\n                break;\\\\n            \\\\n            \\\\n            default:\\\\n                str += 'Unknown type: ' + typeof obj + '';\\\\n                break;\\\\n        }\\\\n\\\\n\\\\n        /**\\\\n        * Finished, now either return if we're in a recursed call, or alert()\\\\n        * if we're not.\\\\n        */\\\\n        if (!arguments[1]) {\\\\n            alert(str);\\\\n        }\\\\n        \\\\n        return str;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Produces a dashed line\\\\n    * \\\\n    * @param object co The 2D context\\\\n    * @param number x1 The start X coordinate\\\\n    * @param number y1 The start Y coordinate\\\\n    * @param number x2 The end X coordinate\\\\n    * @param number y2 The end Y coordinate\\\\n    */\\\\n    RG.dashedLine =\\\\n    RG.DashedLine = function(co, x1, y1, x2, y2)\\\\n    {\\\\n        /**\\\\n        * This is the size of the dashes\\\\n        */\\\\n        var size = 5;\\\\n\\\\n        /**\\\\n        * The optional fifth argument can be the size of the dashes\\\\n        */\\\\n        if (typeof arguments[5] === 'number') {\\\\n            size = arguments[5];\\\\n        }\\\\n\\\\n        var dx  = x2 - x1;\\\\n        var dy  = y2 - y1;\\\\n        var num = ma.floor(ma.sqrt((dx * dx) + (dy * dy)) / size);\\\\n\\\\n        var xLen = dx / num;\\\\n        var yLen = dy / num;\\\\n\\\\n        var count = 0;\\\\n\\\\n        do {\\\\n            (count % 2 == 0 && count > 0) ? co.lineTo(x1, y1) : co.moveTo(x1, y1);\\\\n\\\\n            x1 += xLen;\\\\n            y1 += yLen;\\\\n        } while(count++ <= num);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Makes an AJAX call. It calls the given callback (a function) when ready\\\\n    * \\\\n    * @param string   url      The URL to retrieve\\\\n    * @param function callback A function that is called when the response is ready, there's an example below\\\\n    *                          called \\\\\\\"myCallback\\\\\\\".\\\\n    */\\\\n    RG.AJAX = function (url, callback)\\\\n    {\\\\n        // Mozilla, Safari, ...\\\\n        if (window.XMLHttpRequest) {\\\\n            var httpRequest = new XMLHttpRequest();\\\\n\\\\n        // MSIE\\\\n        } else if (window.ActiveXObject) {\\\\n            var httpRequest = new ActiveXObject(\\\\\\\"Microsoft.XMLHTTP\\\\\\\");\\\\n        }\\\\n\\\\n        httpRequest.onreadystatechange = function ()\\\\n        {\\\\n            if (this.readyState == 4 && this.status == 200) {\\\\n                this.__user_callback__ = callback;\\\\n\\\\n                this.__user_callback__(this.responseText);\\\\n            }\\\\n        }\\\\n\\\\n        httpRequest.open('GET', url, true);\\\\n        httpRequest.send();\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Makes an AJAX POST request. It calls the given callback (a function) when ready\\\\n    * \\\\n    * @param string   url      The URL to retrieve\\\\n    * @param object   data     The POST data\\\\n    * @param function callback A function that is called when the response is ready, there's an example below\\\\n    *                          called \\\\\\\"myCallback\\\\\\\".\\\\n    */\\\\n    RG.AJAX.POST = function (url, data, callback)\\\\n    {\\\\n        // Used when building the POST string\\\\n        var crumbs = [];\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        // Mozilla, Safari, ...\\\\n        if (window.XMLHttpRequest) {\\\\n            var httpRequest = new XMLHttpRequest();\\\\n\\\\n        // MSIE\\\\n        } else if (window.ActiveXObject) {\\\\n            var httpRequest = new ActiveXObject(\\\\\\\"Microsoft.XMLHTTP\\\\\\\");\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        httpRequest.onreadystatechange = function ()\\\\n        {\\\\n            if (this.readyState == 4 && this.status == 200) {\\\\n                this.__user_callback__ = callback;\\\\n                this.__user_callback__(this.responseText);\\\\n            }\\\\n        }\\\\n\\\\n        httpRequest.open('POST', url, true);\\\\n        httpRequest.setRequestHeader(\\\\\\\"Content-type\\\\\\\",\\\\\\\"application/x-www-form-urlencoded\\\\\\\");\\\\n        \\\\n        for (i in data) {\\\\n            if (typeof i == 'string') {\\\\n                crumbs.push(i + '=' + encodeURIComponent(data[i]));\\\\n            }\\\\n        }\\\\n\\\\n        httpRequest.send(crumbs.join('&'));\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Uses the above function but calls the call back passing a number as its argument\\\\n    * \\\\n    * @param url string The URL to fetch\\\\n    * @param callback function Your callback function (which is passed the number as an argument)\\\\n    */\\\\n    RG.AJAX.getNumber = function (url, callback)\\\\n    {\\\\n        RG.AJAX(url, function ()\\\\n        {\\\\n            var num = parseFloat(this.responseText);\\\\n\\\\n            callback(num);\\\\n        });\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Uses the above function but calls the call back passing a string as its argument\\\\n    * \\\\n    * @param url string The URL to fetch\\\\n    * @param callback function Your callback function (which is passed the string as an argument)\\\\n    */\\\\n    RG.AJAX.getString = function (url, callback)\\\\n    {\\\\n        RG.AJAX(url, function ()\\\\n        {\\\\n            var str = String(this.responseText);\\\\n\\\\n            callback(str);\\\\n        });\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument\\\\n    * \\\\n    * @param url string The URL to fetch\\\\n    * @param callback function Your callback function (which is passed the JSON object as an argument)\\\\n    */\\\\n    RG.AJAX.getJSON = function (url, callback)\\\\n    {\\\\n        RG.AJAX(url, function ()\\\\n        {\\\\n            var json = eval('(' + this.responseText + ')');\\\\n\\\\n            callback(json);\\\\n        });\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.\\\\n    * Useful if you're retrieving CSV data\\\\n    * \\\\n    * @param url string The URL to fetch\\\\n    * @param callback function Your callback function (which is passed the CSV/array as an argument)\\\\n    */\\\\n    RG.AJAX.getCSV = function (url, callback)\\\\n    {\\\\n        var seperator = arguments[2] ? arguments[2] : ',';\\\\n\\\\n        RG.AJAX(url, function ()\\\\n        {\\\\n            var regexp = new RegExp(seperator);\\\\n            var arr = this.responseText.split(regexp);\\\\n            \\\\n            // Convert the strings to numbers\\\\n            for (var i=0,len=arr.length;i<len;++i) {\\\\n                arr[i] = parseFloat(arr[i]);\\\\n            }\\\\n\\\\n            callback(arr);\\\\n        });\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Rotates the canvas\\\\n    * \\\\n    * @param object canvas The canvas to rotate\\\\n    * @param  int   x      The X coordinate about which to rotate the canvas\\\\n    * @param  int   y      The Y coordinate about which to rotate the canvas\\\\n    * @param  int   angle  The angle(in RADIANS) to rotate the canvas by\\\\n    */\\\\n    RG.rotateCanvas =\\\\n    RG.RotateCanvas = function (ca, x, y, angle)\\\\n    {\\\\n        var co = ca.getContext('2d');\\\\n\\\\n        co.translate(x, y);\\\\n        co.rotate(angle);\\\\n        co.translate(0 - x, 0 - y);    \\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Measures text by creating a DIV in the document and adding the relevant text to it.\\\\n    * Then checking the .offsetWidth and .offsetHeight.\\\\n    * \\\\n    * @param  string text   The text to measure\\\\n    * @param  bool   bold   Whether the text is bold or not\\\\n    * @param  string font   The font to use\\\\n    * @param  size   number The size of the text (in pts)\\\\n    * @return array         A two element array of the width and height of the text\\\\n    */\\\\n    RG.measureText =\\\\n    RG.MeasureText = function (text, bold, font, size)\\\\n    {\\\\n        // Add the sizes to the cache as adding DOM elements is costly and causes slow downs\\\\n        if (typeof RG.measuretext_cache === 'undefined') {\\\\n            RG.measuretext_cache = [];\\\\n        }\\\\n\\\\n        var str = text + ':' + bold + ':' + font + ':' + size;\\\\n        if (typeof RG.measuretext_cache == 'object' && RG.measuretext_cache[str]) {\\\\n            return RG.measuretext_cache[str];\\\\n        }\\\\n        \\\\n        if (!RG.measuretext_cache['text-div']) {\\\\n            var div = document.createElement('DIV');\\\\n                div.style.position = 'absolute';\\\\n                div.style.top = '-100px';\\\\n                div.style.left = '-100px';\\\\n            document.body.appendChild(div);\\\\n            \\\\n            // Now store the newly created DIV\\\\n            RG.measuretext_cache['text-div'] = div;\\\\n\\\\n        } else if (RG.measuretext_cache['text-div']) {\\\\n            var div = RG.measuretext_cache['text-div'];\\\\n        }\\\\n\\\\n        div.innerHTML        = text.replace(/\\\\\\\\r\\\\\\\\n/g, '<br />');\\\\n        div.style.fontFamily = font;\\\\n        div.style.fontWeight = bold ? 'bold' : 'normal';\\\\n        div.style.fontSize   = (size || 12) + 'pt';\\\\n        \\\\n        var size = [div.offsetWidth, div.offsetHeight];\\\\n\\\\n        //document.body.removeChild(div);\\\\n        RG.measuretext_cache[str] = size;\\\\n        \\\\n        return size;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /* New text function. Accepts two arguments:\\\\n    *  o obj - The chart object\\\\n    *  o opt - An object/hash/map of properties. This can consist of:\\\\n    *          x                The X coordinate (REQUIRED)\\\\n    *          y                The Y coordinate (REQUIRED)\\\\n    *          text             The text to show (REQUIRED)\\\\n    *          font             The font to use\\\\n    *          size             The size of the text (in pt)\\\\n    *          italic           Whether the text should be italic or not\\\\n    *          bold             Whether the text shouldd be bold or not\\\\n    *          marker           Whether to show a marker that indicates the X/Y coordinates\\\\n    *          valign           The vertical alignment\\\\n    *          halign           The horizontal alignment\\\\n    *          bounding         Whether to draw a bounding box for the text\\\\n    *          boundingStroke   The strokeStyle of the bounding box\\\\n    *          boundingFill     The fillStyle of the bounding box\\\\n    *          accessible       If false this will cause the text to be\\\\n    *                           rendered as native canvas text. DOM text otherwise\\\\n    */\\\\n    RG.text2 =\\\\n    RG.Text2 = function (obj, opt)\\\\n    {\\\\n        /**\\\\n        * Use DOM nodes to get better quality text. This option is BETA quality\\\\n        * code and most likely and will not work if you use 3D or if you use\\\\n        * your own transformations.\\\\n        */\\\\n        function domtext ()\\\\n        {\\\\n            /**\\\\n            * Check the font property to see if it contains the italic keyword,\\\\n            * and if it does then take it out and set the italic property\\\\n            */\\\\n            if (String(opt.size).toLowerCase().indexOf('italic') !== -1) {\\\\n                opt.size = opt.size.replace(/ *italic +/, '');\\\\n                opt.italic = true;\\\\n            }\\\\n\\\\n\\\\n\\\\n            // Used for caching the DOM node\\\\n            var cacheKey = ma.abs(parseInt(opt.x)) + '_' + ma.abs(parseInt(opt.y)) + '_' + String(opt.text).replace(/[^a-zA-Z0-9]+/g, '_') + '_' + obj.canvas.id;\\\\n\\\\n\\\\n\\\\n            // Wrap the canvas in a DIV\\\\n            if (!ca.rgraph_domtext_wrapper) {\\\\n\\\\n                var wrapper = document.createElement('div');\\\\n                    wrapper.id        = ca.id + '_rgraph_domtext_wrapper';\\\\n                    wrapper.className = 'rgraph_domtext_wrapper';\\\\n\\\\n                    // The wrapper can be configured to hide or show the\\\\n                    // overflow with the textAccessibleOverflow option\\\\n                    wrapper.style.overflow = obj.properties['chart.text.accessible.overflow'] != false && obj.properties['chart.text.accessible.overflow'] != 'hidden' ? 'visible' : 'hidden';\\\\n                    \\\\n                    wrapper.style.width    = ca.offsetWidth + 'px';\\\\n                    wrapper.style.height   = ca.offsetHeight + 'px';\\\\n\\\\n                    wrapper.style.cssFloat = ca.style.cssFloat;\\\\n                    wrapper.style.display  = ca.style.display || 'inline-block';\\\\n                    wrapper.style.position = ca.style.position || 'relative';\\\\n                    wrapper.style.left     = ca.style.left;\\\\n                    wrapper.style.top      = ca.style.top;\\\\n                    wrapper.style.width    = ca.width + 'px';\\\\n                    wrapper.style.height   = ca.height + 'px';\\\\n\\\\n                    ca.style.position      = 'absolute';\\\\n                    ca.style.left          = 0;\\\\n                    ca.style.top           = 0;\\\\n                    ca.style.display       = 'inline';\\\\n                    ca.style.cssFloat      = 'none';\\\\n\\\\n                    \\\\n                    if ((obj.type === 'bar' || obj.type === 'bipolar' || obj.type === 'hbar') && obj.properties['chart.variant'] === '3d') {\\\\n                        wrapper.style.transform = 'skewY(5.7deg)';\\\\n                    }\\\\n\\\\n                ca.parentNode.insertBefore(wrapper, ca);\\\\n                \\\\n                // Remove the canvas from the DOM and put it in the wrapper\\\\n                ca.parentNode.removeChild(ca);\\\\n                wrapper.appendChild(ca);\\\\n                \\\\n                ca.rgraph_domtext_wrapper = wrapper;\\\\n                \\\\n                // TODO Add a subwrapper here\\\\n\\\\n            } else {\\\\n                wrapper = ca.rgraph_domtext_wrapper;\\\\n            }\\\\n\\\\n\\\\n\\\\n            var defaults = {\\\\n                size: 12,\\\\n                font: 'Arial',\\\\n                italic: 'normal',\\\\n                bold: 'normal',\\\\n                valign: 'bottom',\\\\n                halign: 'left',\\\\n                marker: true,\\\\n                color: co.fillStyle,\\\\n                bounding: {\\\\n                    enabled: false,\\\\n                    fill: 'rgba(255,255,255,0.7)',\\\\n                    stroke: '#666'\\\\n                }\\\\n            }\\\\n            \\\\n            \\\\n            // Transform \\\\\\\\n to the string [[RETURN]] which is then replaced\\\\n            // further down\\\\n            opt.text = String(opt.text).replace(/\\\\\\\\r?\\\\\\\\n/g, '[[RETURN]]');\\\\n\\\\n\\\\n            // Create the node cache array that nodes\\\\n            // already created are stored in\\\\n            if (typeof RG.text2.domNodeCache === 'undefined') {\\\\n                RG.text2.domNodeCache = new Array();\\\\n            }\\\\n            \\\\n            if (typeof RG.text2.domNodeCache[obj.id] === 'undefined') {\\\\n                RG.text2.domNodeCache[obj.id] = new Array();\\\\n            }\\\\n\\\\n            // Create the dimension cache array that node\\\\n            // dimensions are stored in\\\\n            if (typeof RG.text2.domNodeDimensionCache === 'undefined') {\\\\n                RG.text2.domNodeDimensionCache = new Array();\\\\n            }\\\\n            \\\\n            if (typeof RG.text2.domNodeDimensionCache[obj.id] === 'undefined') {\\\\n                RG.text2.domNodeDimensionCache[obj.id] = new Array();\\\\n            }\\\\n\\\\n\\\\n\\\\n            // Create the DOM node\\\\n            if (!RG.text2.domNodeCache[obj.id] || !RG.text2.domNodeCache[obj.id][cacheKey]) {\\\\n\\\\n                var span = document.createElement('span');\\\\n                    span.style.position   = 'absolute';\\\\n                    span.style.display    = 'inline';\\\\n                    \\\\n                    span.style.left       = (opt.x * (parseInt(ca.offsetWidth) / parseInt(ca.width))) + 'px';\\\\n                    span.style.top        = (opt.y * (parseInt(ca.offsetHeight) / parseInt(ca.height)))  + 'px';\\\\n                    span.style.color      = opt.color || defaults.color;\\\\n                    span.style.fontFamily = opt.font || defaults.font;\\\\n                    span.style.fontWeight = opt.bold ? 'bold' : defaults.bold;\\\\n                    span.style.fontStyle  = opt.italic ? 'italic' : defaults.italic;\\\\n                    span.style.fontSize   = (opt.size || defaults.size) + 'pt';\\\\n                    span.style.whiteSpace = 'nowrap';\\\\n                    span.tag              = opt.tag;\\\\n\\\\n\\\\n                    // Shadow\\\\n                    span.style.textShadow = '\\\";\");\";s:33:\"tcpfunc_58dc766f5d52b5.70379995_2\";s:296:\"\$tpl_funcs['tcpfunc_58dc766f5d52b5.70379995_2']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d52b5.70379995_2']=recall_named_function('58dc766f5d52f0.03600699','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_1)?\\\$bound_1:null,\\\"1/RGraph.common.core\\\"),\\n	\\\"px \\\";\");\";s:33:\"tcpfunc_58dc766f5d5331.33577257_3\";s:296:\"\$tpl_funcs['tcpfunc_58dc766f5d5331.33577257_3']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5331.33577257_3']=recall_named_function('58dc766f5d5356.96223658','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_2)?\\\$bound_2:null,\\\"2/RGraph.common.core\\\"),\\n	\\\"px \\\";\");\";s:33:\"tcpfunc_58dc766f5d5371.93796205_4\";s:296:\"\$tpl_funcs['tcpfunc_58dc766f5d5371.93796205_4']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5371.93796205_4']=recall_named_function('58dc766f5d5381.32803316','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_3)?\\\$bound_3:null,\\\"3/RGraph.common.core\\\"),\\n	\\\"px \\\";\");\";s:33:\"tcpfunc_58dc766f5d53a3.92968304_5\";s:30093:\"\$tpl_funcs['tcpfunc_58dc766f5d53a3.92968304_5']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d53a3.92968304_5']=recall_named_function('58dc766f5d53e1.04588627','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_4)?\\\$bound_4:null,\\\"4/RGraph.common.core\\\"),\\n	\\\"'.format(\\\\n                        co.shadowOffsetX,\\\\n                        co.shadowOffsetY,\\\\n                        co.shadowBlur,\\\\n                        co.shadowColor\\\\n                    );\\\\n\\\\n\\\\n                    if (opt.bounding) {\\\\n                        span.style.border          = '1px solid ' + (opt['bounding.stroke'] || defaults.bounding.stroke);\\\\n                        span.style.backgroundColor = opt['bounding.fill'] || defaults.bounding.fill;\\\\n                    }\\\\n                    // Pointer events\\\\n                    if ((typeof obj.properties['chart.text.accessible.pointerevents'] === 'undefined' ||\\\\n                        obj.properties['chart.text.accessible.pointerevents']) &&\\\\n                        obj.properties['chart.text.accessible.pointerevents'] !== 'none') {\\\\n                        \\\\n                        span.style.pointerEvents =  'auto';\\\\n                    } else {\\\\n                        span.style.pointerEvents =  'none';\\\\n                    }\\\\n\\\\n                    span.style.padding = opt.bounding ? '2px' : null;\\\\n                    span.__text__      = opt.text\\\\n                    span.innerHTML     = opt.text.replace('&', '&amp;')\\\\n                                                 .replace('<', '&lt;')\\\\n                                                 .replace('>', '&gt;');\\\\n                    \\\\n                    // Now replace the string [[RETURN]] with a <br />\\\\n                    span.innerHTML = span.innerHTML.replace(/\\\\\\\\[\\\\\\\\[RETURN\\\\\\\\]\\\\\\\\]/g, '<br />');\\\\n\\\\n                wrapper.appendChild(span);\\\\n\\\\n                // Alignment defaults\\\\n                opt.halign = opt.halign || 'left';\\\\n                opt.valign = opt.valign || 'bottom';\\\\n                \\\\n                // Horizontal alignment\\\\n                if (opt.halign === 'right') {\\\\n                    span.style.left      = parseFloat(span.style.left) - span.offsetWidth + 'px';\\\\n                    span.style.textAlign = 'right';\\\\n                } else if (opt.halign === 'center') {\\\\n                    span.style.left      = parseFloat(span.style.left) - (span.offsetWidth  / 2) + 'px';\\\\n                    span.style.textAlign = 'center';\\\\n                }\\\\n                \\\\n                // Vertical alignment\\\\n                if (opt.valign === 'top') {\\\\n                    // Nothing to do here\\\\n                } else if (opt.valign === 'center') {\\\\n                    span.style.top = parseFloat(span.style.top) - (span.offsetHeight / 2) + 'px';\\\\n                } else {\\\\n                    span.style.top = parseFloat(span.style.top) - span.offsetHeight + 'px';\\\\n                }\\\\n                        \\\\n                \\\\n                var offsetWidth  = parseFloat(span.offsetWidth),\\\\n                    offsetHeight = parseFloat(span.offsetHeight),\\\\n                    top          = parseFloat(span.style.top),\\\\n                    left         = parseFloat(span.style.left);\\\\n\\\\n                RG.text2.domNodeCache[obj.id][cacheKey] = span;\\\\n                RG.text2.domNodeDimensionCache[obj.id][cacheKey] = {\\\\n                      left: left,\\\\n                       top: top,\\\\n                     width: offsetWidth,\\\\n                    height: offsetHeight\\\\n                };\\\\n                span.id = cacheKey;\\\\n\\\\n\\\\n            \\\\n            } else {\\\\n                span = RG.text2.domNodeCache[obj.id][cacheKey];\\\\n                span.style.display = 'inline';\\\\n                \\\\n                var offsetWidth  = RG.text2.domNodeDimensionCache[obj.id][cacheKey].width,\\\\n                    offsetHeight = RG.text2.domNodeDimensionCache[obj.id][cacheKey].height,\\\\n                    top          = RG.text2.domNodeDimensionCache[obj.id][cacheKey].top,\\\\n                    left         = RG.text2.domNodeDimensionCache[obj.id][cacheKey].left;\\\\n            }\\\\n\\\\n\\\\n            \\\\n\\\\n            \\\\n            \\\\n            // If requested, draw a marker to indicate the coords\\\\n            if (opt.marker) {\\\\n                RG.path2(context, 'b m % % l % % m % % l % % s',\\\\n                    opt.x - 5, opt.y,\\\\n                    opt.x + 5, opt.y,\\\\n                    opt.x, opt.y - 5,\\\\n                    opt.x, opt.y + 5\\\\n                );\\\\n            }\\\\n            \\\\n            /**\\\\n            * If its a drawing API text object then allow\\\\n            * for events and tooltips\\\\n            */\\\\n            if (obj.type === 'drawing.text') {\\\\n\\\\n                // Mousemove\\\\n                if (obj.properties['chart.events.mousemove']) {\\\\n                    span.addEventListener('mousemove', function (e) {(obj.properties['chart.events.mousemove'])(e, obj);}, false);\\\\n                }\\\\n                \\\\n                // Click\\\\n                if (obj.properties['chart.events.click']) {\\\\n                    span.addEventListener('click', function (e) {(obj.properties['chart.events.click'])(e, obj);}, false);\\\\n                }\\\\n                \\\\n                // Tooltips\\\\n                if (obj.properties['chart.tooltips']) {\\\\n                    span.addEventListener(\\\\n                        obj.properties['chart.tooltips.event'].indexOf('mousemove') !== -1 ? 'mousemove' : 'click',\\\\n                        function (e)\\\\n                        {\\\\n                            if (   !RG.Registry.get('chart.tooltip')\\\\n                                || RG.Registry.get('chart.tooltip').__index__ !== 0\\\\n                                || RG.Registry.get('chart.tooltip').__object__.uid != obj.uid\\\\n                               ) {\\\\n                               \\\\n                                RG.hideTooltip();\\\\n                                RG.redraw();\\\\n                                RG.tooltip(obj, obj.properties['chart.tooltips'][0], opt.x, opt.y, 0, e);\\\\n                            }\\\\n                        },\\\\n                        false\\\\n                    );\\\\n                }\\\\n            }\\\\n\\\\n            // Build the return value\\\\n            var ret    = {};\\\\n            ret.x      = left;\\\\n            ret.y      = top;\\\\n            ret.width  = offsetWidth;\\\\n            ret.height = offsetHeight;\\\\n            ret.object = obj;\\\\n            ret.text   = opt.text;\\\\n            ret.tag    = opt.tag;\\\\n\\\\n            \\\\n            // The reset() function clears the domNodeCache\\\\n            ////\\\\n            // @param object OPTIONAL You can pass in the canvas to limit the\\\\n            //                        clearing to that canvas.\\\\n            RG.text2.domNodeCache.reset = function ()\\\\n            {\\\\n                // Limit the clearing to a single canvas tag\\\\n                if (arguments[0]) {\\\\n                \\\\n                    var nodes = RG.text2.domNodeCache[arguments[0].id];\\\\n                \\\\n                    for (j in nodes) {\\\\n                        \\\\n                        var node = RG.text2.domNodeCache[arguments[0].id][j];\\\\n                        \\\\n                        if (node && node.parentNode) {\\\\n                            node.parentNode.removeChild(node);\\\\n                        }\\\\n                    }\\\\n\\\\n                // Clear all DOM text from all tags\\\\n                } else {\\\\n                    for (i in RG.text2.domNodeCache) {\\\\n                        for (j in RG.text2.domNodeCache[i]) {\\\\n                            if (RG.text2.domNodeCache[i][j] && RG.text2.domNodeCache[i][j].parentNode) {\\\\n                                RG.text2.domNodeCache[i][j].parentNode.removeChild(RG.text2.domNodeCache[i][j]);\\\\n                            }\\\\n                        }\\\\n                    }\\\\n                }\\\\n            };\\\\n\\\\n\\\\n\\\\n\\\\n            //\\\\n            // Helps you get hold of the SPAN tag nodes that hold the text on the chart\\\\n            //\\\\n            RG.text2.find = function (opt)\\\\n            {\\\\n                var span, nodes = [];\\\\n                var id = typeof opt.id === 'string' ? opt.id : opt.object.id;\\\\n\\\\n                for (i in RG.text2.domNodeCache[id]) {\\\\n                \\\\n                    span = RG.text2.domNodeCache[id][i];\\\\n\\\\n                    // A full tag is given\\\\n                    if (typeof opt.tag === 'string' && opt.tag === span.tag) {\\\\n                        nodes.push(span);\\\\n                        continue;\\\\n                    }\\\\n\\\\n\\\\n\\\\n                    // A regex is given as the tag\\\\n                    if (typeof opt.tag === 'object' && opt.tag.constructor.toString().indexOf('RegExp')) {\\\\n\\\\n                        var regexp = new RegExp(opt.tag);\\\\n\\\\n                        if (regexp.test(span.tag)) {\\\\n                            nodes.push(span);\\\\n                            continue;\\\\n                        }\\\\n                    }\\\\n\\\\n\\\\n\\\\n                    // A full text is given\\\\n                    if (typeof opt.text === 'string' && opt.text === span.__text__) {\\\\n                        nodes.push(span);\\\\n                        continue;\\\\n                    }\\\\n\\\\n\\\\n\\\\n                    // Regex for the text is given\\\\n                    // A regex is given as the tag\\\\n                    if (typeof opt.text === 'object' && opt.text.constructor.toString().indexOf('RegExp')) {\\\\n\\\\n                        var regexp = new RegExp(opt.text);\\\\n\\\\n                        if (regexp.test(span.__text__)) {\\\\n                            nodes.push(span);\\\\n                            \\\\n                        continue;\\\\n                        }\\\\n                    }\\\\n                }\\\\n \\\\n                return nodes;\\\\n            };\\\\n\\\\n\\\\n\\\\n\\\\n            //\\\\n            // Add the SPAN tag to the return value\\\\n            //\\\\n            ret.node = span;\\\\n\\\\n\\\\n            /**\\\\n            * Save and then return the details of the text (but oly\\\\n            * if it's an RGraph object that was given)\\\\n            */\\\\n            if (obj && obj.isRGraph && obj.coordsText) {\\\\n                obj.coordsText.push(ret);\\\\n            }\\\\n\\\\n\\\\n            return ret;\\\\n        }\\\\n        \\\\n        \\\\n\\\\n    \\\\n    \\\\n        /**\\\\n        * An RGraph object can be given, or a string or the 2D rendering context\\\\n        * The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function\\\\n        * still returns the cooords though in all cases.\\\\n        */\\\\n        if (obj && obj.isRGraph) {\\\\n            var obj = obj;\\\\n            var co  = obj.context;\\\\n            var ca  = obj.canvas;\\\\n        } else if (typeof obj == 'string') {\\\\n            var ca  = document.getElementById(obj);\\\\n            var co  = ca.getContext('2d');\\\\n            var obj = ca.__object__;\\\\n        } else if (typeof obj.getContext === 'function') {\\\\n            var ca = obj;\\\\n            var co = ca.getContext('2d');\\\\n            var obj = ca.__object__;\\\\n        } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1 || RGraph.ISIE8 && obj.moveTo) {\\\\n            var co  = obj;\\\\n            var ca  = obj.canvas;\\\\n            var obj = ca.__object__;\\\\n\\\\n        // IE7/8\\\\n        } else if (RG.ISOLD && obj.fillText) {\\\\n            var co  = obj;\\\\n            var ca  = obj.canvas;\\\\n            var obj = ca.__object__;\\\\n        }\\\\n\\\\n\\\\n        /**\\\\n        * Changed the name of boundingFill/boundingStroke - this allows you to still use those names\\\\n        */\\\\n        if (typeof opt.boundingFill === 'string')   opt['bounding.fill']   = opt.boundingFill;\\\\n        if (typeof opt.boundingStroke === 'string') opt['bounding.stroke'] = opt.boundingStroke;\\\\n        \\\\n\\\\n\\\\n        if (obj && obj.properties['chart.text.accessible'] && opt.accessible !== false) {\\\\n            return domtext();\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        var x              = opt.x,\\\\n            y              = opt.y,\\\\n            originalX      = x,\\\\n            originalY      = y,\\\\n            text           = opt.text,\\\\n            text_multiline = typeof text === 'string' ? text.split(/\\\\\\\\r?\\\\\\\\n/g) : '',\\\\n            numlines       = text_multiline.length,\\\\n            font           = opt.font ? opt.font : 'Arial',\\\\n            size           = opt.size ? opt.size : 10,\\\\n            size_pixels    = size * 1.5,\\\\n            bold           = opt.bold,\\\\n            italic         = opt.italic,\\\\n            halign         = opt.halign ? opt.halign : 'left',\\\\n            valign         = opt.valign ? opt.valign : 'bottom',\\\\n            tag            = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '',\\\\n            marker         = opt.marker,\\\\n            angle          = opt.angle || 0\\\\n\\\\n\\\\n\\\\n        \\\\n        \\\\n        \\\\n        \\\\n        \\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        var bounding                = opt.bounding,\\\\n            bounding_stroke         = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black',\\\\n            bounding_fill           = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)',\\\\n            bounding_shadow         = opt['bounding.shadow'],\\\\n            bounding_shadow_color   = opt['bounding.shadow.color'] || '#ccc',\\\\n            bounding_shadow_blur    = opt['bounding.shadow.blur'] || 3,\\\\n            bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3,\\\\n            bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3,\\\\n            bounding_linewidth      = opt['bounding.linewidth'] || 1;\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Initialize the return value to an empty object\\\\n        */\\\\n        var ret = {};\\\\n        \\\\n        //\\\\n        // Color\\\\n        //\\\\n        if (typeof opt.color === 'string') {\\\\n            var orig_fillstyle = co.fillStyle;\\\\n            co.fillStyle = opt.color;\\\\n        }\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The text arg must be a string or a number\\\\n        */\\\\n        if (typeof text == 'number') {\\\\n            text = String(text);\\\\n        }\\\\n\\\\n        if (typeof text !== 'string') {\\\\n            return;\\\\n        }\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * This facilitates vertical text\\\\n        */\\\\n        if (angle != 0) {\\\\n            co.save();\\\\n            co.translate(x, y);\\\\n            co.rotate((ma.PI / 180) * angle)\\\\n            x = 0;\\\\n            y = 0;\\\\n        }\\\\n\\\\n\\\\n        \\\\n        /**\\\\n        * Set the font\\\\n        */\\\\n        co.font = (opt.italic ? 'italic ' : '') + (opt.bold ? 'bold ' : '') + size + 'pt ' + font;\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Measure the width/height. This must be done AFTER the font has been set\\\\n        */\\\\n        var width=0;\\\\n        for (var i=0; i<numlines; ++i) {\\\\n            width = ma.max(width, co.measureText(text_multiline[i]).width);\\\\n        }\\\\n        var height = size_pixels * numlines;\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Accommodate old MSIE 7/8\\\\n        */\\\\n        //if (document.all && RGraph.ISOLD) {\\\\n            //y += 2;\\\\n        //}\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * If marker is specified draw a marker at the X/Y coordinates\\\\n        */\\\\n        if (opt.marker) {\\\\n            var marker_size = 10;\\\\n            var strokestyle = co.strokeStyle;\\\\n            co.beginPath();\\\\n                co.strokeStyle = 'red';\\\\n                co.moveTo(x, y - marker_size);\\\\n                co.lineTo(x, y + marker_size);\\\\n                co.moveTo(x - marker_size, y);\\\\n                co.lineTo(x + marker_size, y);\\\\n            co.stroke();\\\\n            co.strokeStyle = strokestyle;\\\\n        }\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Set the horizontal alignment\\\\n        */\\\\n        if (halign == 'center') {\\\\n            co.textAlign = 'center';\\\\n            var boundingX = x - 2 - (width / 2);\\\\n        } else if (halign == 'right') {\\\\n            co.textAlign = 'right';\\\\n            var boundingX = x - 2 - width;\\\\n        } else {\\\\n            co.textAlign = 'left';\\\\n            var boundingX = x - 2;\\\\n        }\\\\n\\\\n\\\\n        /**\\\\n        * Set the vertical alignment\\\\n        */\\\\n        if (valign == 'center') {\\\\n            \\\\n            co.textBaseline = 'middle';\\\\n            // Move the text slightly\\\\n            y -= 1;\\\\n            \\\\n            y -= ((numlines - 1) / 2) * size_pixels;\\\\n            var boundingY = y - (size_pixels / 2) - 2;\\\\n        \\\\n        } else if (valign == 'top') {\\\\n            co.textBaseline = 'top';\\\\n\\\\n            var boundingY = y - 2;\\\\n\\\\n        } else {\\\\n\\\\n            co.textBaseline = 'bottom';\\\\n            \\\\n            // Move the Y coord if multiline text\\\\n            if (numlines > 1) {\\\\n                y -= ((numlines - 1) * size_pixels);\\\\n            }\\\\n\\\\n            var boundingY = y - size_pixels - 2;\\\\n        }\\\\n        \\\\n        var boundingW = width + 4;\\\\n        var boundingH = height + 4;\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draw a bounding box if required\\\\n        */\\\\n        if (bounding) {\\\\n\\\\n            var pre_bounding_linewidth     = co.lineWidth;\\\\n            var pre_bounding_strokestyle   = co.strokeStyle;\\\\n            var pre_bounding_fillstyle     = co.fillStyle;\\\\n            var pre_bounding_shadowcolor   = co.shadowColor;\\\\n            var pre_bounding_shadowblur    = co.shadowBlur;\\\\n            var pre_bounding_shadowoffsetx = co.shadowOffsetX;\\\\n            var pre_bounding_shadowoffsety = co.shadowOffsetY;\\\\n\\\\n            co.lineWidth   = bounding_linewidth;\\\\n            co.strokeStyle = bounding_stroke;\\\\n            co.fillStyle   = bounding_fill;\\\\n\\\\n            if (bounding_shadow) {\\\\n                co.shadowColor   = bounding_shadow_color;\\\\n                co.shadowBlur    = bounding_shadow_blur;\\\\n                co.shadowOffsetX = bounding_shadow_offsetx;\\\\n                co.shadowOffsetY = bounding_shadow_offsety;\\\\n            }\\\\n\\\\n            //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);\\\\n            //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);\\\\n            co.strokeRect(boundingX, boundingY, boundingW, boundingH);\\\\n            co.fillRect(boundingX, boundingY, boundingW, boundingH);\\\\n\\\\n            // Reset the linewidth,colors and shadow to it's original setting\\\\n            co.lineWidth     = pre_bounding_linewidth;\\\\n            co.strokeStyle   = pre_bounding_strokestyle;\\\\n            co.fillStyle     = pre_bounding_fillstyle;\\\\n            co.shadowColor   = pre_bounding_shadowcolor\\\\n            co.shadowBlur    = pre_bounding_shadowblur\\\\n            co.shadowOffsetX = pre_bounding_shadowoffsetx\\\\n            co.shadowOffsetY = pre_bounding_shadowoffsety\\\\n        }\\\\n\\\\n        \\\\n        \\\\n        /**\\\\n        * Draw the text\\\\n        */\\\\n        if (numlines > 1) {\\\\n            for (var i=0; i<numlines; ++i) {\\\\n                co.fillText(text_multiline[i], x, y + (size_pixels * i));\\\\n            }\\\\n        } else {\\\\n            co.fillText(text, x + 0.5, y + 0.5);\\\\n        }\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * If the text is at 90 degrees restore() the canvas - getting rid of the rotation\\\\n        * and the translate that we did\\\\n        */\\\\n        if (angle != 0) {\\\\n            if (angle == 90) {\\\\n                if (halign == 'left') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                \\\\n                } else if (halign == 'center') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                \\\\n                } else if (halign == 'right') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                }\\\\n\\\\n            } else if (angle == 180) {\\\\n\\\\n                if (halign == 'left') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                \\\\n                } else if (halign == 'center') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                \\\\n                } else if (halign == 'right') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}\\\\n                }\\\\n            \\\\n            } else if (angle == 270) {\\\\n\\\\n                if (halign == 'left') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                \\\\n                } else if (halign == 'center') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                \\\\n                } else if (halign == 'right') {\\\\n                    if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                    if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}\\\\n                }\\\\n            }\\\\n\\\\n            co.restore();\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Reset the text alignment so that text rendered after this text function is not affected\\\\n        */\\\\n        co.textBaseline = 'alphabetic';\\\\n        co.textAlign    = 'left';\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Fill the ret variable with details of the text\\\\n        */\\\\n        ret.x      = boundingX;\\\\n        ret.y      = boundingY;\\\\n        ret.width  = boundingW;\\\\n        ret.height = boundingH\\\\n        ret.object = obj;\\\\n        ret.text   = text;\\\\n        ret.tag    = tag;\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Save and then return the details of the text (but oly\\\\n        * if it's an RGraph object that was given)\\\\n        */\\\\n        if (obj && obj.isRGraph && obj.coordsText) {\\\\n            obj.coordsText.push(ret);\\\\n        }\\\\n        \\\\n        //\\\\n        // Restore the original fillstyle\\\\n        //\\\\n        if (typeof orig_fillstyle === 'string') {\\\\n            co.fillStyle = orig_fillstyle;\\\\n        }\\\\n\\\\n        return ret;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Takes a sequential index abd returns the group/index variation of it. Eg if you have a\\\\n    * sequential index from a grouped bar chart this function can be used to convert that into\\\\n    * an appropriate group/index combination\\\\n    * \\\\n    * @param nindex number The sequential index\\\\n    * @param data   array  The original data (which is grouped)\\\\n    * @return              The group/index information\\\\n    */\\\\n    RG.sequentialIndexToGrouped = function (index, data)\\\\n    {\\\\n        var group         = 0;\\\\n        var grouped_index = 0;\\\\n\\\\n        while (--index >= 0) {\\\\n\\\\n            if (RG.is_null(data[group])) {\\\\n                group++;\\\\n                grouped_index = 0;\\\\n                continue;\\\\n            }\\\\n\\\\n            // Allow for numbers as well as arrays in the dataset\\\\n            if (typeof data[group] == 'number') {\\\\n                group++\\\\n                grouped_index = 0;\\\\n                continue;\\\\n            }\\\\n            \\\\n\\\\n            grouped_index++;\\\\n            \\\\n            if (grouped_index >= data[group].length) {\\\\n                group++;\\\\n                grouped_index = 0;\\\\n            }\\\\n        }\\\\n        \\\\n        return [group, grouped_index];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function highlights a rectangle\\\\n    * \\\\n    * @param object obj    The chart object\\\\n    * @param number shape  The coordinates of the rect to highlight\\\\n    */\\\\n    RG.Highlight.rect =\\\\n    RG.Highlight.Rect = function (obj, shape)\\\\n    {\\\\n        var ca   = obj.canvas;\\\\n        var co   = obj.context;\\\\n        var prop = obj.properties;\\\\n\\\\n        if (prop['chart.tooltips.highlight']) {\\\\n            \\\\n        \\\\n            // Safari seems to need this\\\\n            co.lineWidth = 1;\\\\n\\\\n            /**\\\\n            * Draw a rectangle on the canvas to highlight the appropriate area\\\\n            */\\\\n            co.beginPath();\\\\n\\\\n                co.strokeStyle = prop['chart.highlight.stroke'];\\\\n                co.fillStyle   = prop['chart.highlight.fill'];\\\\n    \\\\n                co.rect(shape['x'],shape['y'],shape['width'],shape['height']);\\\\n                //co.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);\\\\n            co.stroke();\\\\n            co.fill();\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function highlights a point\\\\n    * \\\\n    * @param object obj    The chart object\\\\n    * @param number shape  The coordinates of the rect to highlight\\\\n    */\\\\n    RG.Highlight.point =\\\\n    RG.Highlight.Point = function (obj, shape)\\\\n    {\\\\n        var prop = obj.properties;\\\\n        var ca   = obj.canvas;\\\\n        var co   = obj.context;\\\\n\\\\n        if (prop['chart.tooltips.highlight']) {\\\\n    \\\\n            /**\\\\n            * Draw a rectangle on the canvas to highlight the appropriate area\\\\n            */\\\\n            co.beginPath();\\\\n                co.strokeStyle = prop['chart.highlight.stroke'];\\\\n                co.fillStyle   = prop['chart.highlight.fill'];\\\\n                var radius   = prop['chart.highlight.point.radius'] || 2;\\\\n                co.arc(shape['x'],shape['y'],radius, 0, RG.TWOPI, 0);\\\\n            co.stroke();\\\\n            co.fill();\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the same as Date.parse - though a little more flexible.\\\\n    * \\\\n    * @param string str The date string to parse\\\\n    * @return Returns the same thing as Date.parse\\\\n    */\\\\n    RG.parseDate = function (str)\\\\n    {\\\\n\\\\n        str = RG.trim(str);\\\\n\\\\n        // Allow for: now (just the word \\\\\\\"now\\\\\\\")\\\\n        if (str === 'now') {\\\\n            str = (new Date()).toString();\\\\n        }\\\\n\\\\n\\\\n        // Allow for: 22-11-2013\\\\n        // Allow for: 22/11/2013\\\\n        // Allow for: 22-11-2013 12:09:09\\\\n        // Allow for: 22/11/2013 12:09:09\\\\n        if (str.match(/^(\\\\\\\\d\\\\\\\\d)(?:-|\\\\\\\\/)(\\\\\\\\d\\\\\\\\d)(?:-|\\\\\\\\/)(\\\\\\\\d\\\\\\\\d\\\\\\\\d\\\\\\\\d)(.*)\\\\\\\$/)) {\\\\n            str = '\\\";\");\";s:33:\"tcpfunc_58dc766f5d57d5.20114186_6\";s:294:\"\$tpl_funcs['tcpfunc_58dc766f5d57d5.20114186_6']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d57d5.20114186_6']=recall_named_function('58dc766f5d57f8.47525612','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_1)?\\\$bound_1:null,\\\"1/RGraph.common.core\\\"),\\n	\\\"/\\\";\");\";s:33:\"tcpfunc_58dc766f5d5814.52615111_7\";s:294:\"\$tpl_funcs['tcpfunc_58dc766f5d5814.52615111_7']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5814.52615111_7']=recall_named_function('58dc766f5d5831.34450301','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_2)?\\\$bound_2:null,\\\"2/RGraph.common.core\\\"),\\n	\\\"/\\\";\");\";s:33:\"tcpfunc_58dc766f5d5856.99186176_8\";s:285:\"\$tpl_funcs['tcpfunc_58dc766f5d5856.99186176_8']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5856.99186176_8']=recall_named_function('58dc766f5d5860.04128677','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_3)?\\\$bound_3:null,\\\"3/RGraph.common.core\\\");\");\";s:33:\"tcpfunc_58dc766f5d5887.05792674_9\";s:28366:\"\$tpl_funcs['tcpfunc_58dc766f5d5887.05792674_9']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5887.05792674_9']=recall_named_function('58dc766f5d58c2.38120088','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_4)?\\\$bound_4:null,\\\"4/RGraph.common.core\\\"),\\n	\\\"'.format(\\\\n                RegExp.\\\\\\\$3,\\\\n                RegExp.\\\\\\\$2,\\\\n                RegExp.\\\\\\\$1,\\\\n                RegExp.\\\\\\\$4\\\\n            );\\\\n        }\\\\n\\\\n        // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12\\\\n        if (str.match(/^(\\\\\\\\d\\\\\\\\d\\\\\\\\d\\\\\\\\d)(-|\\\\\\\\/)(\\\\\\\\d\\\\\\\\d)(-|\\\\\\\\/)(\\\\\\\\d\\\\\\\\d)( |T)(\\\\\\\\d\\\\\\\\d):(\\\\\\\\d\\\\\\\\d):(\\\\\\\\d\\\\\\\\d)\\\\\\\$/)) {\\\\n            str = RegExp.\\\\\\\$1 + '-' + RegExp.\\\\\\\$3 + '-' + RegExp.\\\\\\\$5 + 'T' + RegExp.\\\\\\\$7 + ':' + RegExp.\\\\\\\$8 + ':' + RegExp.\\\\\\\$9;\\\\n        }\\\\n\\\\n        // Allow for: 2013-11-22\\\\n        if (str.match(/^\\\\\\\\d\\\\\\\\d\\\\\\\\d\\\\\\\\d-\\\\\\\\d\\\\\\\\d-\\\\\\\\d\\\\\\\\d\\\\\\\$/)) {\\\\n            str = str.replace(/-/g, '/');\\\\n        }\\\\n\\\\n\\\\n        // Allow for: 12:09:44 (time only using todays date)\\\\n        if (str.match(/^\\\\\\\\d\\\\\\\\d:\\\\\\\\d\\\\\\\\d:\\\\\\\\d\\\\\\\\d\\\\\\\$/)) {\\\\n        \\\\n            var dateObj  = new Date();\\\\n            var date     = dateObj.getDate();\\\\n            var month    = dateObj.getMonth() + 1;\\\\n            var year     = dateObj.getFullYear();\\\\n            \\\\n            // Pad the date/month with a zero if it's not two characters\\\\n            if (String(month).length === 1) month = '0' + month;\\\\n            if (String(date).length === 1) date = '0' + date;\\\\n\\\\n            str = (year + '/' + month + '/' + date) + ' ' + str;\\\\n        }\\\\n\\\\n        return Date.parse(str);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Reset all of the color values to their original values\\\\n    * \\\\n    * @param object\\\\n    */\\\\n    RG.resetColorsToOriginalValues = function (obj)\\\\n    {\\\\n        if (obj.original_colors) {\\\\n            // Reset the colors to their original values\\\\n            for (var j in obj.original_colors) {\\\\n                if (typeof j === 'string' && j.substr(0,6) === 'chart.') {\\\\n                    obj.properties[j] = RG.arrayClone(obj.original_colors[j]);\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * If the function is present on the object to reset specific colors - use that\\\\n        */\\\\n        if (typeof obj.resetColorsToOriginalValues === 'function') {\\\\n            obj.resetColorsToOriginalValues();\\\\n        }\\\\n\\\\n\\\\n\\\\n        // Reset the colorsParsed flag so that they're parsed for gradients again\\\\n        obj.colorsParsed = false;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Creates a Linear gradient\\\\n    * \\\\n    * @param object obj The chart object\\\\n    * @param number x1 The start X coordinate\\\\n    * @param number x2 The end X coordinate\\\\n    * @param number y1 The start Y coordinate\\\\n    * @param number y2 The end Y coordinate\\\\n    * @param string color1 The start color\\\\n    * @param string color2 The end color\\\\n    */\\\\n    RG.linearGradient =\\\\n    RG.LinearGradient = function (obj, x1, y1, x2, y2, color1, color2)\\\\n    {\\\\n        var gradient = obj.context.createLinearGradient(x1, y1, x2, y2);\\\\n        var numColors=arguments.length-5;\\\\n        \\\\n        for (var i=5; i<arguments.length; ++i) {\\\\n            \\\\n            var color = arguments[i];\\\\n            var stop = (i - 5) / (numColors - 1);\\\\n            \\\\n            gradient.addColorStop(stop, color);\\\\n        }\\\\n        \\\\n        return gradient;\\\\n    };\\\\n\\\\n\\\\n\\\\n    \\\\n    /**\\\\n    * Creates a Radial gradient\\\\n    * \\\\n    * @param object obj The chart object\\\\n    * @param number x1 The start X coordinate\\\\n    * @param number x2 The end X coordinate\\\\n    * @param number y1 The start Y coordinate\\\\n    * @param number y2 The end Y coordinate\\\\n    * @param string color1 The start color\\\\n    * @param string color2 The end color\\\\n    */\\\\n    RG.radialGradient =\\\\n    RG.RadialGradient = function(obj, x1, y1, r1, x2, y2, r2, color1, color2)\\\\n    {\\\\n        var gradient  = obj.context.createRadialGradient(x1, y1, r1, x2, y2, r2);\\\\n        var numColors = arguments.length-7;\\\\n        \\\\n        for(var i=7; i<arguments.length; ++i) {\\\\n            \\\\n            var color = arguments[i];\\\\n            var stop  = (i-7) / (numColors-1);\\\\n            \\\\n            gradient.addColorStop(stop, color);\\\\n        }\\\\n        \\\\n        return gradient;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Adds an event listener to RGraphs internal array so that RGraph can track them.\\\\n    * This DOESN'T add the event listener to the canvas/window.\\\\n    * \\\\n    * 5/1/14 TODO Used in the tooltips file, but is it necessary any more?\\\\n    */\\\\n    RG.addEventListener =\\\\n    RG.AddEventListener = function (id, e, func)\\\\n    {\\\\n        var type = arguments[3] ? arguments[3] : 'unknown';\\\\n        \\\\n        RG.Registry.get('chart.event.handlers').push([id,e,func,type]);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Clears event listeners that have been installed by RGraph\\\\n    * \\\\n    * @param string id The ID of the canvas to clear event listeners for - or 'window' to clear\\\\n    *                  the event listeners attached to the window\\\\n    */\\\\n    RG.clearEventListeners =\\\\n    RG.ClearEventListeners = function(id)\\\\n    {\\\\n        if (id && id == 'window') {\\\\n        \\\\n            window.removeEventListener('mousedown', window.__rgraph_mousedown_event_listener_installed__, false);\\\\n            window.removeEventListener('mouseup', window.__rgraph_mouseup_event_listener_installed__, false);\\\\n        \\\\n        } else {\\\\n            \\\\n            var canvas = document.getElementById(id);\\\\n            \\\\n            canvas.removeEventListener('mouseup', canvas.__rgraph_mouseup_event_listener_installed__, false);\\\\n            canvas.removeEventListener('mousemove', canvas.__rgraph_mousemove_event_listener_installed__, false);\\\\n            canvas.removeEventListener('mousedown', canvas.__rgraph_mousedown_event_listener_installed__, false);\\\\n            canvas.removeEventListener('click', canvas.__rgraph_click_event_listener_installed__, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Hides the annotating palette. It's here because it can be called\\\\n    * from code other than the annotating code.\\\\n    */\\\\n    RG.hidePalette =\\\\n    RG.HidePalette = function ()\\\\n    {\\\\n        var div = RG.Registry.get('palette');\\\\n        \\\\n        if(typeof div == 'object' && div) {\\\\n            \\\\n            div.style.visibility = 'hidden';\\\\n            div.style.display = 'none';\\\\n            \\\\n            RG.Registry.set('palette', null);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Generates a random number between the minimum and maximum\\\\n    * \\\\n    * @param number min The minimum value\\\\n    * @param number max The maximum value\\\\n    * @param number     OPTIONAL Number of decimal places\\\\n    */\\\\n    RG.random = function (min, max)\\\\n    {\\\\n        var dp = arguments[2] ? arguments[2] : 0;\\\\n        var r  = ma.random();\\\\n        \\\\n        return Number((((max - min) * r) + min).toFixed(dp));\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * \\\\n    */\\\\n    RG.arrayRand =\\\\n    RG.arrayRandom =\\\\n    RG.random.array = function (num, min, max)\\\\n    {\\\\n        for(var i=0,arr=[]; i<num; i+=1) {\\\\n            arr.push(RG.random(min,max, arguments[3]));\\\\n        }\\\\n        \\\\n        return arr;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Turns off shadow by setting blur to zero, the offsets to zero and the color to transparent black.\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.noShadow =\\\\n    RG.NoShadow = function (obj)\\\\n    {\\\\n        var co = obj.context;\\\\n\\\\n        co.shadowColor   = 'rgba(0,0,0,0)';\\\\n        co.shadowBlur    = 0;\\\\n        co.shadowOffsetX = 0;\\\\n        co.shadowOffsetY = 0;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Sets the various shadow properties\\\\n    * \\\\n    * @param object obj     The chart object\\\\n    * @param string color   The color of the shadow\\\\n    * @param number offsetx The offsetX value for the shadow\\\\n    * @param number offsety The offsetY value for the shadow\\\\n    * @param number blur    The blurring value for the shadow\\\\n    */\\\\n    RG.setShadow =\\\\n    RG.SetShadow = function (obj, color, offsetx, offsety, blur)\\\\n    {\\\\n        var co = obj.context;\\\\n\\\\n        co.shadowColor   = color;\\\\n        co.shadowOffsetX = offsetx;\\\\n        co.shadowOffsetY = offsety;\\\\n        co.shadowBlur    = blur;\\\\n\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Sets an object in the RGraph registry\\\\n    * \\\\n    * @param string name The name of the value to set\\\\n    */\\\\n    RG.Registry.set =\\\\n    RG.Registry.Set = function (name, value)\\\\n    {\\\\n        // Convert uppercase letters to dot+lower case letter\\\\n        name = name.replace(/([A-Z])/g, function (str)\\\\n        {\\\\n            return '.' + String(RegExp.\\\\\\\$1).toLowerCase();\\\\n        });\\\\n        \\\\n        // Ensure there is the chart. prefix\\\\n        if (name.substr(0,6) !== 'chart.') {\\\\n            name = 'chart.' + name;\\\\n        }\\\\n\\\\n        RG.Registry.store[name] = value;\\\\n        \\\\n        return value;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Gets an object from the RGraph registry\\\\n    * \\\\n    * @param string name The name of the value to fetch\\\\n    */\\\\n    RG.Registry.get =\\\\n    RG.Registry.Get = function (name)\\\\n    {\\\\n        // Convert uppercase letters to dot+lower case letter\\\\n        name = name.replace(/([A-Z])/g, function (str)\\\\n        {\\\\n            return '.' + String(RegExp.\\\\\\\$1).toLowerCase();\\\\n        });\\\\n        \\\\n        // Ensure there is the chart. prefix\\\\n        if (name.substr(0,6) !== 'chart.') {\\\\n            name = 'chart.' + name;\\\\n        }\\\\n\\\\n\\\\n        return RG.Registry.store[name];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Converts the given number of degrees to radians. Angles in canvas are measured in radians\\\\n    * \\\\n    * @param number deg The value to convert\\\\n    */\\\\n    RG.degrees2Radians = function (deg)\\\\n    {\\\\n        return deg * (RG.PI / 180);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Generates logs for... ...log charts\\\\n    * \\\\n    * @param number n    The number to generate the log for\\\\n    * @param number base The base to use\\\\n    */\\\\n    RG.log = function (n,base)\\\\n    {\\\\n        return ma.log(n) / (base ? ma.log(base) : 1);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Determines if the given object is an array or not\\\\n    * \\\\n    * @param mixed obj The variable to test\\\\n    */\\\\n    RG.isArray =\\\\n    RG.is_array = function (obj)\\\\n    {\\\\n        if (obj && obj.constructor) {\\\\n            var pos = obj.constructor.toString().indexOf('Array');\\\\n        } else {\\\\n            return false;\\\\n        }\\\\n\\\\n        return obj != null &&\\\\n               typeof pos === 'number' &&\\\\n               pos > 0 &&\\\\n               pos < 20;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Removes white-space from the start aqnd end of a string\\\\n    * \\\\n    * @param string str The string to trim\\\\n    */\\\\n    RG.trim = function (str)\\\\n    {\\\\n        return RG.ltrim(RG.rtrim(str));\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Trims the white-space from the start of a string\\\\n    * \\\\n    * @param string str The string to trim\\\\n    */\\\\n    RG.ltrim = function (str)\\\\n    {\\\\n        return str.replace(/^(\\\\\\\\s|\\\\\\\\0)+/, '');\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Trims the white-space off of the end of a string\\\\n    * \\\\n    * @param string str The string to trim\\\\n    */\\\\n    RG.rtrim = function (str)\\\\n    {\\\\n        return str.replace(/(\\\\\\\\s|\\\\\\\\0)+\\\\\\\$/, '');\\\\n    };\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Returns true/false as to whether the given variable is null or not\\\\n    * \\\\n    * @param mixed arg The argument to check\\\\n    */\\\\n    RG.isNull =\\\\n    RG.is_null = function (arg)\\\\n    {\\\\n        // must BE DOUBLE EQUALS - NOT TRIPLE\\\\n        if (arg == null || typeof arg === 'object' && !arg) {\\\\n            return true;\\\\n        }\\\\n        \\\\n        return false;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function facilitates a very limited way of making your charts\\\\n    * whilst letting the rest of page continue - using  the setTimeout function\\\\n    * \\\\n    * @param function func The function to run that creates the chart\\\\n    */\\\\n    RG.async =\\\\n    RG.Async = function (func)\\\\n    {\\\\n        return setTimeout(func, arguments[1] ? arguments[1] : 1);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Resets (more than just clears) the canvas and clears any pertinent objects\\\\n    * from the ObjectRegistry\\\\n    * \\\\n    * @param object ca The canvas object (as returned by document.getElementById() ).\\\\n    */\\\\n    RG.reset =\\\\n    RG.Reset = function (ca)\\\\n    {\\\\n        ca.width = ca.width;\\\\n        \\\\n        RG.ObjectRegistry.clear(ca);\\\\n        \\\\n        ca.__rgraph_aa_translated__ = false;\\\\n\\\\n        if (RG.text2.domNodeCache && RG.text2.domNodeCache.reset) {\\\\n            RG.text2.domNodeCache.reset(ca);\\\\n        }\\\\n\\\\n        // Create the node and dimension caches if they don't already exist\\\\n        if (!RG.text2.domNodeCache)          { RG.text2.domNodeCache          = []; }\\\\n        if (!RG.text2.domNodeDimensionCache) { RG.text2.domNodeDimensionCache = []; }\\\\n\\\\n        // Create/reset the specific canvas arrays in the caches\\\\n        RG.text2.domNodeCache[ca.id]          = [];\\\\n        RG.text2.domNodeDimensionCache[ca.id] = [];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * NOT USED ANY MORE\\\\n    */\\\\n    RG.att = function (ca){}\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function is due to be removed.\\\\n    * \\\\n    * @param string id The ID of what can be either the canvas tag or a DIV tag\\\\n    */\\\\n    RG.getCanvasTag = function (id)\\\\n    {\\\\n        id = typeof id === 'object' ? id.id : id;\\\\n        var canvas = doc.getElementById(id);\\\\n\\\\n        return [id, canvas];\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * A wrapper function that encapsulate requestAnimationFrame\\\\n    * \\\\n    * @param function func The animation function\\\\n    */\\\\n    RG.Effects.updateCanvas =\\\\n    RG.Effects.UpdateCanvas = function (func)\\\\n    {\\\\n        win.requestAnimationFrame =    win.requestAnimationFrame\\\\n                                    || win.webkitRequestAnimationFrame\\\\n                                    || win.msRequestAnimationFrame\\\\n                                    || win.mozRequestAnimationFrame\\\\n                                    || (function (func){setTimeout(func, 16.666);});\\\\n        \\\\n        win.requestAnimationFrame(func);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function returns an easing multiplier for effects so they eas out towards the\\\\n    * end of the effect.\\\\n    * \\\\n    * @param number frames The total number of frames\\\\n    * @param number frame  The frame number\\\\n    */\\\\n    RG.Effects.getEasingMultiplier = function (frames, frame)\\\\n    {\\\\n        return ma.pow(ma.sin((frame / frames) * RG.HALFPI), 3);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function converts an array of strings to an array of numbers. Its used by the meter/gauge\\\\n    * style charts so that if you want you can pass in a string. It supports various formats:\\\\n    * \\\\n    * '45.2'\\\\n    * '-45.2'\\\\n    * ['45.2']\\\\n    * ['-45.2']\\\\n    * '45.2,45.2,45.2' // A CSV style string\\\\n    * \\\\n    * @param number frames The string or array to parse\\\\n    */\\\\n    RG.stringsToNumbers = function (str)\\\\n    {\\\\n        // An optional seperator to use intead of a comma\\\\n        var sep = arguments[1] || ',';\\\\n        \\\\n        \\\\n        // If it's already a number just return it\\\\n        if (typeof str === 'number') {\\\\n            return str;\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        if (typeof str === 'string') {\\\\n            if (str.indexOf(sep) != -1) {\\\\n                str = str.split(sep);\\\\n            } else {\\\\n                str = parseFloat(str);\\\\n            }\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        if (typeof str === 'object') {\\\\n            for (var i=0,len=str.length; i<len; i+=1) {\\\\n                str[i] = parseFloat(str[i]);\\\\n            }\\\\n        }\\\\n\\\\n        return str;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Drawing cache function. This function creates an off-screen canvas and draws [wwhatever] to it\\\\n    * and then subsequent calls use that  instead of repeatedly drawing the same thing.\\\\n    * \\\\n    * @param object   obj  The graph object\\\\n    * @param string   id   An ID string used to identify the relevant entry in the cache\\\\n    * @param function func The drawing function. This will be called to do the draw.\\\\n    */\\\\n    RG.cachedDraw = function (obj, id, func)\\\\n    {\\\\n        //If the cache entry exists - just copy it across to the main canvas\\\\n        if (!RG.cache[id]) {\\\\n\\\\n            RG.cache[id] = {};\\\\n\\\\n            RG.cache[id].object = obj;\\\\n            RG.cache[id].canvas = document.createElement('canvas');\\\\n\\\\n            RG.cache[id].canvas.setAttribute('width', obj.canvas.width);\\\\n            RG.cache[id].canvas.setAttribute('height', obj.canvas.height);\\\\n            RG.cache[id].canvas.setAttribute('id', 'background_cached_canvas' + obj.canvas.id);\\\\n\\\\n            RG.cache[id].canvas.__object__ = obj;\\\\n            RG.cache[id].context = RG.cache[id].canvas.getContext('2d');\\\\n            \\\\n            // Antialiasing on the cache canvas\\\\n            RG.cache[id].context.translate(0.5,0.5);\\\\n\\\\n            // Call the function\\\\n            func(obj, RG.cache[id].canvas, RG.cache[id].context);\\\\n        }\\\\n\\\\n        // Now copy the contents of the cached canvas over to the main one.\\\\n        // The coordinates are -0.5 because of the anti-aliasing effect in\\\\n        // use on the main canvas\\\\n        obj.context.drawImage(RG.cache[id].canvas,-0.5,-0.5);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * The function that runs through the supplied configuration and\\\\n    * converts it to the RGraph stylee.\\\\n    * \\\\n    * @param object conf The config\\\\n    * @param object      The settings for the object\\\\n    */\\\\n    RG.parseObjectStyleConfig = function (obj, config)\\\\n    {\\\\n        /**\\\\n        * The recursion function\\\\n        */\\\\n        var recurse = function (obj, config, name, settings)\\\\n        {\\\\n            var i;\\\\n    \\\\n            for (key in config) {\\\\n\\\\n                // Allow for functions in the configuration. Run them immediately\\\\n                if (key.match(/^exec[0-9]*\\\\\\\$/)) {\\\\n                    (config[key])(obj, settings);\\\\n                    continue;\\\\n                }\\\\n\\\\n                var isObject = false; // Default value\\\\n                var isArray  = false; // Default value\\\\n                var value    = config[key];\\\\n\\\\n                // Change caps to dots. Eg textSize => text.size\\\\n                while(key.match(/([A-Z])/)) {\\\\n                    key = key.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n                }\\\\n\\\\n                if (!RG.isNull(value) && value.constructor) {\\\\n                    isObject = value.constructor.toString().indexOf('Object') > 0;\\\\n                    isArray  = value.constructor.toString().indexOf('Array') > 0;\\\\n                }\\\\n\\\\n                if (isObject && !isArray) {\\\\n                    recurse(obj, config[key], name + '.' + key, settings);\\\\n                \\\\n                } else if (key === 'self') {\\\\n                    settings[name] = value;\\\\n\\\\n                } else {\\\\n                    settings[name + '.' + key] = value;\\\\n                }\\\\n            }\\\\n\\\\n            return settings;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Go through the settings that we've been given\\\\n        */\\\\n        var settings = recurse(obj, config, 'chart', {});\\\\n\\\\n        /**\\\\n        * Go through the settings and set them on the object\\\\n        */\\\\n        for (key in settings) {\\\\n            if (typeof key === 'string') {\\\\n                obj.set(key, settings[key]);\\\\n            }\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function is a short-cut for the canvas path syntax (which can be rather\\\\n    * verbose). You can read a description of it (which details all of the\\\\n    * various options) on the RGraph blog (www.rgraph.net/blog). The function is\\\\n    * added to the CanvasRenderingContext2D object so it becomes a context function.\\\\n    * \\\\n    * So you can use it like these examples show:\\\\n    * \\\\n    * 1. RG.path2(context, 'b r 0 0 50 50 f red');\\\\n    * 2. RG.path2(context, 'b a 50 50 50 0 3.14 false f red');\\\\n    * 3. RG.path2(context, 'b m 5 100 bc 5 0 100 0 100 100 s red');\\\\n    * 4. RG.path2(context, 'b m 5 100 at 50 0 95 100 50 s red');\\\\n    * 5. RG.path2(context, 'sa b r 0 0 50 50 c b r 5 5 590 240 f red rs');\\\\n    * 6. RG.path2(context, 'ld [2,6] ldo 4 b r 5 5 590 240 f red');\\\\n    * 7. RG.path2(context, 'ga 0.25 b r 5 5 590 240 f red');\\\\n    * \\\\n    * @param   array p  The path details\\\\n    */\\\\n    RG.path2 = function (co, p)\\\\n    {\\\\n        // Save this functions arguments\\\\n        var args = arguments;\\\\n\\\\n        \\\\n        // If the path was a string - split it then collapse quoted bits together\\\\n        if (typeof p === 'string') {\\\\n            p = splitstring(p);\\\\n        }\\\\n\\\\n        // Store the last path on the RGraph object\\\\n        RG.path2.last = RG.arrayClone(p);\\\\n\\\\n        // Go through the path information.\\\\n        for (var i=0,len=p.length; i<len; i+=1) {\\\\n\\\\n            switch (p[i]) {\\\\n                case 'b':co.beginPath();break;\\\\n                case 'c':co.closePath();break;\\\\n                case 'm':co.moveTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\\\\n                case 'l':co.lineTo(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\\\\n                case 's':if(p[i+1])co.strokeStyle=p[i+1];co.stroke();i++;break;\\\\n                case 'f':if(p[i+1]){co.fillStyle=p[i+1];}co.fill();i++;break;\\\\n                case 'qc':co.quadraticCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\\\\n                case 'bc':co.bezierCurveTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\\\\n                case 'r':co.rect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\\\\n                case 'a':co.arc(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),p[i+6]==='true'||p[i+6]===true||p[i+6]===1||p[i+6]==='1'?true:false);i+=6;break;\\\\n                case 'at':co.arcTo(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]));i+=5;break;\\\\n                case 'lw':co.lineWidth=parseFloat(p[i+1]);i++;break;\\\\n                case 'e':co.ellipse(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]),parseFloat(p[i+7]),p[i+8] === 'true' ? true : false);i+=8;break;\\\\n                case 'lj':co.lineJoin=p[i+1];i++;break;\\\\n                case 'lc':co.lineCap=p[i+1];i++;break;\\\\n                case 'sc':co.shadowColor=p[i+1];i++;break;\\\\n                case 'sb':co.shadowBlur=parseFloat(p[i+1]);i++;break;\\\\n                case 'sx':co.shadowOffsetX=parseFloat(p[i+1]);i++;break;\\\\n                case 'sy':co.shadowOffsetY=parseFloat(p[i+1]);i++;break;\\\\n                case 'fs':co.fillStyle=p[i+1];i++;break;\\\\n                case 'ss':co.strokeStyle=p[i+1];i++;break;\\\\n                case 'fr':co.fillRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\\\\n                case 'sr':co.strokeRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\\\\n                case 'cl':co.clip();break;\\\\n                case 'sa':co.save();break;\\\\n                case 'rs':co.restore();break;\\\\n                case 'tr':co.translate(parseFloat(p[i+1]),parseFloat(p[i+2]));i+=2;break;\\\\n                case 'sl':co.scale(parseFloat(p[i+1]), parseFloat(p[i+2]));i+=2;break;\\\\n                case 'ro':co.rotate(parseFloat(p[i+1]));i++;break;\\\\n                case 'tf':co.transform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\\\\n                case 'stf':co.setTransform(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]),parseFloat(p[i+5]),parseFloat(p[i+6]));i+=6;break;\\\\n                case 'cr':co.clearRect(parseFloat(p[i+1]),parseFloat(p[i+2]),parseFloat(p[i+3]),parseFloat(p[i+4]));i+=4;break;\\\\n                case 'ld':var parts = p[i+1];co.setLineDash(parts);i+=1;break;\\\\n                case 'ldo':co.lineDashOffset=p[i+1];i++;break;\\\\n                case 'fo':co.font=p[i+1];i++;break;\\\\n                case 'ft':co.fillText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;\\\\n                case 'st':co.strokeText(p[i+1], parseFloat(p[i+2]), parseFloat(p[i+3]));i+=3;break;\\\\n                case 'ta':co.textAlign=p[i+1];i++;break;\\\\n                case 'tbl':co.textBaseline=p[i+1];i++;break;\\\\n                case 'ga':co.globalAlpha=parseFloat(p[i+1]);i++;break;\\\\n                case 'gco':co.globalCompositeOperation=p[i+1];i++;break;\\\\n                case 'fu':(p[i+1])(co.canvas.__object__);i++;break;\\\\n                \\\\n                // Empty option - ignore it\\\\n                case '':break;\\\\n                \\\\n                // Unknown option\\\\n                default: alert('[ERROR] Unknown option: ' + p[i]);\\\\n            }\\\\n        }\\\\n        \\\\n        function splitstring (p)\\\\n        {\\\\n            var ret = [], buffer = '', inquote = false, quote = '', substitutionIndex = 2;\\\\n\\\\n            for (var i=0; i<p.length; i+=1) {\\\\n                \\\\n                var chr = p[i],\\\\n                    isWS = chr.match(/ /);\\\\n\\\\n                if (isWS) {\\\\n                    if (!inquote) {\\\\n                    \\\\n                        // Get rid of any enclosing quotes\\\\n                        if (buffer[0] === '\\\\\\\"' || buffer[0] === \\\\\\\"'\\\\\\\") {\\\\n                            buffer = buffer.substr(1, buffer.length - 2);\\\\n                        }\\\\n\\\\n\\\\n                        // String substitution\\\\n                        if (buffer.trim() === '%' && typeof args[substitutionIndex] !== 'undefined') {\\\\n                            buffer = args[substitutionIndex++];\\\\n                        }\\\\n\\\\n                        ret.push(buffer);\\\\n                        buffer = '';\\\\n                    } else {\\\\n                        buffer += chr;\\\\n                    }\\\\n                } else {\\\\n                    if (chr === \\\\\\\"'\\\\\\\" || chr === '\\\\\\\"') {\\\\n                        inquote = !inquote;\\\\n                    }\\\\n\\\\n                    buffer += chr;\\\\n                }\\\\n            }\\\\n\\\\n            // Do the last bit (including substitution)\\\\n            if (buffer.trim() === '%' && args[substitutionIndex]) {\\\\n                buffer = args[substitutionIndex++];\\\\n            }\\\\n\\\\n            ret.push(buffer);\\\\n\\\\n            return ret;\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    //\\\\n    // Wraps the canvas in a DIV to allow DOM text to be used\\\\n    //\\\\n    // NOT USED ANY MORE\\\\n    //\\\\n    RG.wrap = function () {};\\\\n\\\\n\\\\n\\\\n\\\\n// End module pattern\\\\n})(window, document);\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Uses the alert() function to show the structure of the given variable\\\\n    * \\\\n    * @param mixed v The variable to print/alert the structure of\\\\n    */\\\\n    window.\\\\\\\$p = function (v)\\\\n    {\\\\n        RGraph.pr(arguments[0], arguments[1], arguments[3]);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * A shorthand for the default alert() function\\\\n    */\\\\n    window.\\\\\\\$a = function (v)\\\\n    {\\\\n        alert(v);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Short-hand for console.log\\\\n    * \\\\n    * @param mixed v The variable to log to the console\\\\n    */\\\\n    window.\\\\\\\$cl = function (v)\\\\n    {\\\\n        return console.log(v);\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * A basic string formatting function. Use it like this:\\\\n    * \\\\n    * var str = '\\\";\");\";s:34:\"tcpfunc_58dc766f5d5d05.07017115_10\";s:296:\"\$tpl_funcs['tcpfunc_58dc766f5d5d05.07017115_10']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5d05.07017115_10']=recall_named_function('58dc766f5d5d34.36720565','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_0)?\\\$bound_0:null,\\\"0/RGraph.common.core\\\"),\\n	\\\" \\\";\");\";s:34:\"tcpfunc_58dc766f5d5d51.83976666_11\";s:296:\"\$tpl_funcs['tcpfunc_58dc766f5d5d51.83976666_11']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5d51.83976666_11']=recall_named_function('58dc766f5d5d62.02905551','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_1)?\\\$bound_1:null,\\\"1/RGraph.common.core\\\"),\\n	\\\" \\\";\");\";s:34:\"tcpfunc_58dc766f5d5d81.10276411_12\";s:676:\"\$tpl_funcs['tcpfunc_58dc766f5d5d81.10276411_12']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f5d5d81.10276411_12']=recall_named_function('58dc766f5d5da5.46652479','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_2)?\\\$bound_2:null,\\\"2/RGraph.common.core\\\"),\\n	\\\"'.format('a', 'b', 'c');\\\\n    * \\\\n    * Outputs: a b c\\\\n    */\\\\n    if (!String.prototype.format) {\\\\n      String.prototype.format = function()\\\\n      {\\\\n        var args = arguments;\\\\n\\\\n        return this.replace(/{(\\\\\\\\d+)}/g, function(str, idx)\\\\n        {\\\\n          return typeof args[idx - 1] !== 'undefined' ? args[idx - 1] : str;\\\\n        });\\\\n      };\\\\n    }\\\";\");\";}}");

?>