<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:1:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc766f7c5b07.51992716_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:25:\"RGraph.drawing.background\";i:3;N;i:4;a:1:{s:33:\"tcpfunc_58dc766f7c5b07.51992716_1\";s:18861:\"\$tpl_funcs['tcpfunc_58dc766f7c5b07.51992716_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f7c5b07.51992716_1']=recall_named_function('58dc766f7c5c26.17515084','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n    \\\\n    /**\\\\n    * Having this here means that the RGraph libraries can be included in any order, instead of you having\\\\n    * to include the common core library first.\\\\n    */\\\\n\\\\n    // Define the RGraph global variable\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n    RGraph.Drawing = RGraph.Drawing || {};\\\\n\\\\n    /**\\\\n    * The constructor. This function sets up the object. It only takes the ID (the HTML attribute) of the canvas as the\\\\n    * first argument - the gutters are set as properties.\\\\n    * \\\\n    * @param string id    The canvas tag ID\\\\n    */\\\\n    RGraph.Drawing.Background = function (conf)\\\\n    {\\\\n        /**\\\\n        * Allow for object config style\\\\n        */\\\\n        if (   typeof conf === 'object'\\\\n            && typeof conf.id === 'string') {\\\\n\\\\n            var id                        = conf.id,\\\\n                canvas                    = document.getElementById(id),\\\\n                parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor)\\\\n        \\\\n        } else {\\\\n        \\\\n            var id     = conf,\\\\n                canvas = document.getElementById(id);\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        this.id                = id;\\\\n        this.canvas            = document.getElementById(this.id);\\\\n        this.context           = this.canvas.getContext('2d');\\\\n        this.canvas.__object__ = this;\\\\n        this.original_colors   = [];\\\\n        this.firstDraw         = true; // After the first draw this will be false\\\\n\\\\n\\\\n        /**\\\\n        * This defines the type of this shape\\\\n        */\\\\n        this.type = 'drawing.background';\\\\n\\\\n\\\\n        /**\\\\n        * This facilitates easy object identification, and should always be true\\\\n        */\\\\n        this.isRGraph = true;\\\\n\\\\n\\\\n        /**\\\\n        * This adds a uid to the object that you can use for identification purposes\\\\n        */\\\\n        this.uid = RGraph.CreateUID();\\\\n\\\\n\\\\n        /**\\\\n        * This adds a UID to the canvas for identification purposes\\\\n        */\\\\n        this.canvas.uid = this.canvas.uid ? this.canvas.uid : RGraph.createUID();\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Some example background properties\\\\n        */\\\\n        this.properties =\\\\n        {\\\\n            'chart.background.barcolor1':   'rgba(0,0,0,0)',\\\\n            'chart.background.barcolor2':   'rgba(0,0,0,0)',\\\\n            'chart.background.grid':        true,\\\\n            'chart.background.grid.color':  '#ddd',\\\\n            'chart.background.grid.width':  1,\\\\n            'chart.background.grid.vlines': true,\\\\n            'chart.background.grid.hlines': true,\\\\n            'chart.background.grid.border': true,\\\\n            'chart.background.grid.autofit':true,\\\\n            'chart.background.grid.autofit.numhlines': 5,\\\\n            'chart.background.grid.autofit.numvlines': 20,\\\\n            'chart.background.grid.dashed': false,\\\\n            'chart.background.grid.dotted': false,\\\\n\\\\n            'chart.background.image':       null,\\\\n            'chart.background.image.stretch': true,\\\\n            'chart.background.image.x':     null,\\\\n            'chart.background.image.y':     null,\\\\n            'chart.background.image.w':     null,\\\\n            'chart.background.image.h':     null,\\\\n            'chart.background.image.align': null,\\\\n            'chart.background.color':       null,\\\\n\\\\n            'chart.gutter.left':        25,\\\\n            'chart.gutter.right':       25,\\\\n            'chart.gutter.top':         25,\\\\n            'chart.gutter.bottom':      25,\\\\n\\\\n            'chart.text.color':         'black', // Gradients aren't supported for this color\\\\n            'chart.text.size':          12,\\\\n            'chart.text.font':          'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.text.accessible':           true,\\\\n            'chart.text.accessible.overflow':  'visible',\\\\n            'chart.text.accessible.pointerevents': true,\\\\n            'chart.events.click':       null,\\\\n            'chart.events.mousemove':   null,\\\\n\\\\n            'chart.tooltips':           null,\\\\n            'chart.tooltips.highlight': true,\\\\n            'chart.tooltips.event':     'onclick',\\\\n\\\\n            'chart.highlight.stroke':       'rgba(0,0,0,0)',\\\\n            'chart.highlight.fill':         'rgba(255,255,255,0.7)',\\\\n\\\\n            'chart.linewidth':          1,\\\\n\\\\n            'chart.title':                  '',\\\\n            'chart.title.size':             null,\\\\n            'chart.title.font':             null,\\\\n            'chart.title.background':       null, // Gradients aren't supported for this color\\\\n            'chart.title.hpos':             null,\\\\n            'chart.title.vpos':             null,\\\\n            'chart.title.bold':             true,\\\\n            'chart.title.color':            'black',\\\\n            'chart.title.x':                null,\\\\n            'chart.title.y':                null,\\\\n            'chart.title.halign':           null,\\\\n            'chart.title.valign':           null,\\\\n            \\\\n            'chart.title.xaxis':            '',\\\\n            'chart.title.xaxis.bold':       true,\\\\n            'chart.title.xaxis.size':       null,\\\\n            'chart.title.xaxis.font':       null,\\\\n            'chart.title.xaxis.x':          null,\\\\n            'chart.title.xaxis.y':          null,\\\\n            'chart.title.xaxis.pos':        null,\\\\n            \\\\n            'chart.title.yaxis':            '',\\\\n            'chart.title.yaxis.bold':       true,\\\\n            'chart.title.yaxis.size':       null,\\\\n            'chart.title.yaxis.font':       null,\\\\n            'chart.title.yaxis.color':      'black', // Gradients aren't supported for this color\\\\n            'chart.title.yaxis.x':          null,\\\\n            'chart.title.yaxis.y':          null,\\\\n            'chart.title.yaxis.pos':        null,\\\\n            'chart.clearto':   'rgba(0,0,0,0)'\\\\n        }\\\\n\\\\n        /**\\\\n        * A simple check that the browser has canvas support\\\\n        */\\\\n        if (!this.canvas) {\\\\n            alert('[DRAWING.BACKGROUND] No canvas support');\\\\n            return;\\\\n        }\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Create the dollar object so that functions can be added to them\\\\n        */\\\\n        this.\\\\\\\$0 = {};\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\\\\n        * done already\\\\n        */\\\\n        if (!this.canvas.__rgraph_aa_translated__) {\\\\n            this.context.translate(0.5,0.5);\\\\n            this.canvas.__rgraph_aa_translated__ = true;\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // Short variable names\\\\n        var RG   = RGraph,\\\\n            ca   = this.canvas,\\\\n            co   = ca.getContext('2d'),\\\\n            prop = this.properties,\\\\n            pa   = RG.Path,\\\\n            pa2  = RG.path2,\\\\n            win  = window,\\\\n            doc  = document,\\\\n            ma   = Math\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * \\\\\\\"Decorate\\\\\\\" the object with the generic effects if the effects library has been included\\\\n        */\\\\n        if (RG.Effects && typeof RG.Effects.decorate === 'function') {\\\\n            RG.Effects.decorate(this);\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A setter method for setting graph properties. It can be used like this: obj.Set('chart.strokestyle', '#666');\\\\n        * \\\\n        * @param name  string The name of the property to set OR it can be a map\\\\n        *                     of name/value settings like what you set in the constructor\\\\n        */\\\\n        this.set =\\\\n        this.Set = function (name)\\\\n        {\\\\n            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];\\\\n\\\\n            /**\\\\n            * the number of arguments is only one and it's an\\\\n            * object - parse it for configuration data and return.\\\\n            */\\\\n            if (arguments.length === 1 && typeof name === 'object') {\\\\n                RG.parseObjectStyleConfig(this, name);\\\\n                return this;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n\\\\n\\\\n            prop[name] = value;\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A getter method for retrieving graph properties. It can be used like this: obj.Get('chart.strokestyle');\\\\n        * \\\\n        * @param name  string The name of the property to get\\\\n        */\\\\n        this.get =\\\\n        this.Get = function (name)\\\\n        {\\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n    \\\\n            return prop[name.toLowerCase()];\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the circle\\\\n        */\\\\n        this.draw =\\\\n        this.Draw = function ()\\\\n        {\\\\n            /**\\\\n            * Fire the onbeforedraw event\\\\n            */\\\\n            RG.fireCustomEvent(this, 'onbeforedraw');\\\\n\\\\n            \\\\n            /***********************\\\\n            * DRAW BACKGROUND HERE *\\\\n            ***********************/\\\\n            this.gutterLeft   = prop['chart.gutter.left'];\\\\n            this.gutterRight  = prop['chart.gutter.right'];\\\\n            this.gutterTop    = prop['chart.gutter.top'];\\\\n            this.gutterBottom = prop['chart.gutter.bottom'];\\\\n    \\\\n    \\\\n            /**\\\\n            * Parse the colors. This allows for simple gradient syntax\\\\n            */\\\\n            if (!this.colorsParsed) {\\\\n    \\\\n                this.parseColors();\\\\n    \\\\n                // Don't want to do this again\\\\n                this.colorsParsed = true;\\\\n            }\\\\n\\\\n            /**\\\\n            * Set the shadow\\\\n            */\\\\n            RG.drawBackgroundImage(this);\\\\n            RG.Background.draw(this);\\\\n\\\\n            /**\\\\n            * This installs the event listeners\\\\n            */\\\\n            RG.installEventListeners(this);\\\\n    \\\\n\\\\n            /**\\\\n            * Fire the onfirstdraw event\\\\n            */\\\\n            if (this.firstDraw) {\\\\n                RG.fireCustomEvent(this, 'onfirstdraw');\\\\n                this.firstDraw = false;\\\\n                this.firstDrawFunc();\\\\n            }\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Fire the ondraw event\\\\n            */\\\\n            RG.fireCustomEvent(this, 'ondraw');\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Used in chaining. Runs a function there and then - not waiting for\\\\n        * the events to fire (eg the onbeforedraw event)\\\\n        * \\\\n        * @param function func The function to execute\\\\n        */\\\\n        this.exec = function (func)\\\\n        {\\\\n            func(this);\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The getObjectByXY() worker method\\\\n        */\\\\n        this.getObjectByXY = function (e)\\\\n        {\\\\n            if (this.getShape(e)) {\\\\n                return this;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Not used by the class during creating the shape, but is used by event handlers\\\\n        * to get the coordinates (if any) of the selected bar\\\\n        * \\\\n        * @param object e The event object\\\\n        * @param object   OPTIONAL You can pass in the bar object instead of the\\\\n        *                          function using \\\\\\\"this\\\\\\\"\\\\n        */\\\\n        this.getShape = function (e)\\\\n        {\\\\n            var mouseXY = RG.getMouseXY(e),\\\\n                mouseX  = mouseXY[0],\\\\n                mouseY  = mouseXY[1];\\\\n\\\\n            if (\\\\n                   mouseX >= this.gutterLeft\\\\n                && mouseX <= (ca.width - this.gutterRight)\\\\n                && mouseY >= this.gutterTop\\\\n                && mouseY <= (ca.height - this.gutterBottom)\\\\n               ) {\\\\n\\\\n                var tooltip = prop['chart.tooltips'] ? prop['chart.tooltips'][0] : null\\\\n                \\\\n                return {\\\\n                    0: this, 1: 0 /* the index */, 2: tooltip,\\\\n                    'object': this,'index': 0, 'tooltip': tooltip\\\\n                };\\\\n            }\\\\n            \\\\n            return null;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Each object type has its own Highlight() function which highlights the appropriate shape\\\\n        * \\\\n        * @param object shape The shape to highlight\\\\n        */\\\\n        this.highlight =\\\\n        this.Highlight = function (shape)\\\\n        {\\\\n            if (prop['chart.tooltips.highlight']) {\\\\n                if (typeof prop['chart.highlight.style'] === 'function') {\\\\n                    (prop['chart.highlight.style'])(shape);\\\\n                } else {\\\\n                    pa2(co,\\\\n                        'b r % % % % f % s %',\\\\n                        prop['chart.gutter.left'],\\\\n                        prop['chart.gutter.top'],\\\\n                        ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'],\\\\n                        ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom'],\\\\n                        prop['chart.highlight.fill'],\\\\n                        prop['chart.highlight.stroke']\\\\n                    );\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This allows for easy specification of gradients\\\\n        */\\\\n        this.parseColors = function ()\\\\n        {\\\\n            // Save the original colors so that they can be restored when the canvas is reset\\\\n            if (this.original_colors.length === 0) {\\\\n                this.original_colors['chart.strokestyle']      = RG.arrayClone(prop['chart.strokestyle']);\\\\n                this.original_colors['chart.highlight.stroke'] = RG.arrayClone(prop['chart.highlight.stroke']);\\\\n                this.original_colors['chart.highlight.fill']   = RG.arrayClone(prop['chart.highlight.fill']);\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Parse various properties for colors\\\\n            */\\\\n            prop['chart.strokestyle']      = this.parseSingleColorForGradient(prop['chart.strokestyle']);\\\\n            prop['chart.highlight.stroke'] = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);\\\\n            prop['chart.highlight.fill']   = this.parseSingleColorForGradient(prop['chart.highlight.fill']);\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Use this function to reset the object to the post-constructor state. Eg reset colors if\\\\n        * need be etc\\\\n        */\\\\n        this.reset = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This parses a single color value\\\\n        */\\\\n        this.parseSingleColorForGradient = function (color)\\\\n        {\\\\n            if (!color) {\\\\n                return color;\\\\n            }\\\\n\\\\n            if (typeof color === 'string' && color.match(/^gradient\\\\\\\\((.*)\\\\\\\\)\\\\\\\$/i)) {\\\\n\\\\n                // Split and create the gradient\\\\n                var parts = RegExp.\\\\\\\$1.split(':'),\\\\n                    grad = co.createLinearGradient(\\\\n                        this.gutterLeft,\\\\n                        this.gutterTop,\\\\n                        ca.width - this.gutterRight,\\\\n                        ca.height - this.gutterRight\\\\n                    ),\\\\n                    diff = 1 / (parts.length - 1);\\\\n    \\\\n                //grad.addColorStop(0, RG.trim(parts[0]));\\\\n    \\\\n                for (var j=0; j<parts.length; j+=1) {\\\\n                    grad.addColorStop(j * diff, RG.trim(parts[j]));\\\\n                }\\\\n            }\\\\n\\\\n            return grad ? grad : color;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Using a function to add events makes it easier to facilitate method chaining\\\\n        * \\\\n        * @param string   type The type of even to add\\\\n        * @param function func \\\\n        */\\\\n        this.on = function (type, func)\\\\n        {\\\\n            if (type.substr(0,2) !== 'on') {\\\\n                type = 'on' + type;\\\\n            }\\\\n            \\\\n            if (typeof this[type] !== 'function') {\\\\n                this[type] = func;\\\\n            } else {\\\\n                RG.addCustomEventListener(this, type, func);\\\\n            }\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function runs once only\\\\n        * (put at the end of the file (before any effects))\\\\n        */\\\\n        this.firstDrawFunc = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Objects are now always registered so that the chart is redrawn if need be.\\\\n        */\\\\n        RG.register(this);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This is the 'end' of the constructor so if the first argument\\\\n        * contains configuration data - handle that.\\\\n        */\\\\n        if (parseConfObjectForOptions) {\\\\n            RG.parseObjectStyleConfig(this, conf.options);\\\\n        }\\\\n    };\\\";\");\";}}");

?>