<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:1:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc7e37c76dc5.95515692_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:12:\"RGraph.gauge\";i:3;N;i:4;a:1:{s:33:\"tcpfunc_58dc7e37c76dc5.95515692_1\";s:52612:\"\$tpl_funcs['tcpfunc_58dc7e37c76dc5.95515692_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc7e37c76dc5.95515692_1']=recall_named_function('58dc7e37c77073.87357615','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n\\\\n    /**\\\\n    * The line chart constructor\\\\n    * \\\\n    * @param object canvas The canvas ID\\\\n    * @param array  data   The chart data\\\\n    * @param array  ...    Other lines to plot\\\\n    */\\\\n    RGraph.Gauge = function (conf)\\\\n    {\\\\n        /**\\\\n        * Allow for object config style\\\\n        */\\\\n        if (   typeof conf === 'object'\\\\n            && typeof conf.id === 'string') {\\\\n\\\\n            var id                        = conf.id\\\\n            var canvas                    = document.getElementById(id);\\\\n            var min                       = conf.min;\\\\n            var max                       = conf.max;\\\\n            var value                     = conf.value;\\\\n            var parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor)\\\\n        \\\\n        } else {\\\\n        \\\\n            var id     = conf;\\\\n            var canvas = document.getElementById(id);\\\\n            var min    = arguments[1];\\\\n            var max    = arguments[2];\\\\n            var value  = arguments[3];\\\\n        }\\\\n\\\\n        // id, min, max, value\\\\n        this.id                = id;\\\\n        this.canvas            = canvas;\\\\n        this.context           = this.canvas.getContext ? this.canvas.getContext(\\\\\\\"2d\\\\\\\", {alpha: (typeof id === 'object' && id.alpha === false) ? false : true}) : null;\\\\n        this.canvas.__object__ = this;\\\\n        this.type              = 'gauge';\\\\n        this.min               = RGraph.stringsToNumbers(min);\\\\n        this.max               = RGraph.stringsToNumbers(max);\\\\n        this.value             = RGraph.stringsToNumbers(value);\\\\n        this.isRGraph          = true;\\\\n        this.currentValue      = null;\\\\n        this.uid               = RGraph.CreateUID();\\\\n        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();\\\\n        this.colorsParsed      = false;\\\\n        this.coordsText        = [];\\\\n        this.original_colors   = [];\\\\n        this.firstDraw         = true; // After the first draw this will be false\\\\n\\\\n        /**\\\\n        * Range checking\\\\n        */\\\\n        if (typeof(this.value) == 'object') {\\\\n            for (var i=0; i<this.value.length; ++i) {\\\\n                if (this.value[i] > this.max) this.value[i] = max;\\\\n                if (this.value[i] < this.min) this.value[i] = min;\\\\n            }\\\\n        } else {\\\\n            if (this.value > this.max) this.value = max;\\\\n            if (this.value < this.min) this.value = min;\\\\n        }\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Compatibility with older browsers\\\\n        */\\\\n        //RGraph.OldBrowserCompat(this.context);\\\\n\\\\n\\\\n        // Various config type stuff\\\\n        this.properties =\\\\n        {\\\\n            'chart.angles.start':  null,\\\\n            'chart.angles.end':    null,\\\\n            'chart.centerx':       null,\\\\n            'chart.centery':       null,\\\\n            'chart.radius':        null,\\\\n            'chart.gutter.left':   15,\\\\n            'chart.gutter.right':  15,\\\\n            'chart.gutter.top':    15,\\\\n            'chart.gutter.bottom': 15,\\\\n            'chart.border.width':  10,\\\\n            'chart.title.top':     '',\\\\n            'chart.title.top.font':'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.title.top.size':14,\\\\n            'chart.title.top.color':'#333',\\\\n            'chart.title.top.bold':false,\\\\n            'chart.title.top.pos': null,\\\\n            'chart.title.bottom':  '',\\\\n            'chart.title.bottom.font':'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.title.bottom.size':14,\\\\n            'chart.title.bottom.color':'#333',\\\\n            'chart.title.bottom.bold':false,\\\\n            'chart.title.bottom.pos':null,\\\\n            'chart.text.font':    'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.text.color':     '#666',\\\\n            'chart.text.size':      12,\\\\n            'chart.text.accessible':               true,\\\\n            'chart.text.accessible.overflow':      'visible',\\\\n            'chart.text.accessible.pointerevents': true,\\\\n            'chart.background.color': 'white',\\\\n            'chart.background.gradient': false,\\\\n            'chart.scale.decimals': 0,\\\\n            'chart.scale.point':    '.',\\\\n            'chart.scale.thousand': ',',\\\\n            'chart.units.pre':      '',\\\\n            'chart.units.post':     '',\\\\n\\\\n            'chart.value.text':                 false,\\\\n            'chart.value.text.y.pos':           0.5,\\\\n            'chart.value.text.units.pre':       null,\\\\n            'chart.value.text.units.post':      null,\\\\n            'chart.value.text.color':           'black',\\\\n            'chart.value.text.bounding':        true,\\\\n            'chart.value.text.bounding.fill':   'white',\\\\n            'chart.value.text.bounding.stroke': 'black',\\\\n\\\\n            'chart.red.start':      0.9 * this.max,\\\\n            'chart.red.color':      '#DC3912',\\\\n            'chart.red.width':      10,\\\\n            'chart.yellow.color':   '#FF9900',\\\\n            'chart.yellow.width':   10,\\\\n            'chart.green.end':      0.7 * this.max,\\\\n            'chart.green.color':    'rgba(0,0,0,0)',\\\\n            'chart.green.width':    10,\\\\n            'chart.colors.ranges':  null,\\\\n            'chart.needle.size':    null,\\\\n            'chart.needle.tail':    false,\\\\n            'chart.needle.colors':   ['#D5604D', 'red', 'green', 'yellow'],\\\\n            'chart.needle.type':     'triangle',\\\\n            'chart.needle.width':     7,\\\\n            'chart.border.outer':     '#ccc',\\\\n            'chart.border.inner':     '#f1f1f1',\\\\n            'chart.border.outline':   'black',\\\\n            'chart.centerpin.color':  'blue',\\\\n            'chart.centerpin.radius': null,\\\\n            'chart.zoom.background':  true,\\\\n            'chart.zoom.action':      'zoom',\\\\n            'chart.tickmarks.small':  25,\\\\n            'chart.tickmarks.small.color': 'black',\\\\n            'chart.tickmarks.medium': 0,\\\\n            'chart.tickmarks.medium.color': 'black',\\\\n            'chart.tickmarks.big':    5,\\\\n            'chart.tickmarks.big.color': 'black',\\\\n            \\\\n            'chart.labels.count':     5,\\\\n            'chart.labels.centered':  false,\\\\n            'chart.labels.offset.radius': 0,\\\\n            'chart.labels.offset.angle': 0,\\\\n            'chart.labels.specific':  null,\\\\n            'chart.labels.offsetx':  0,\\\\n            'chart.labels.offsety':  0,\\\\n\\\\n            'chart.border.gradient':  false,\\\\n            'chart.adjustable':       false,\\\\n            'chart.shadow':           true,\\\\n            'chart.shadow.color':     'gray',\\\\n            'chart.shadow.offsetx':   0,\\\\n            'chart.shadow.offsety':   0,\\\\n            'chart.shadow.blur':      15,\\\\n            'chart.clearto':   'rgba(0,0,0,0)'\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /*\\\\n        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\\\\n        * done already\\\\n        */\\\\n        if (!this.canvas.__rgraph_aa_translated__) {\\\\n            this.context.translate(0.5,0.5);\\\\n            \\\\n            this.canvas.__rgraph_aa_translated__ = true;\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        // Short variable names\\\\n        var RG   = RGraph,\\\\n            ca   = this.canvas,\\\\n            co   = ca.getContext('2d'),\\\\n            prop = this.properties,\\\\n            pa2  = RG.path2,\\\\n            win  = window,\\\\n            doc  = document,\\\\n            ma   = Math\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * \\\\\\\"Decorate\\\\\\\" the object with the generic effects if the effects library has been included\\\\n        */\\\\n        if (RG.Effects && typeof RG.Effects.decorate === 'function') {\\\\n            RG.Effects.decorate(this);\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * An all encompassing accessor\\\\n        * \\\\n        * @param string name The name of the property\\\\n        * @param mixed value The value of the property\\\\n        */\\\\n        this.set =\\\\n        this.Set = function (name)\\\\n        {\\\\n            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];\\\\n\\\\n            /**\\\\n            * the number of arguments is only one and it's an\\\\n            * object - parse it for configuration data and return.\\\\n            */\\\\n            if (arguments.length === 1 && typeof name === 'object') {\\\\n                RG.parseObjectStyleConfig(this, name);\\\\n                return this;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            /**\\\\n            * This should be done first - prepend the propertyy name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Title compatibility\\\\n            */\\\\n            if (name == 'chart.title')       name = 'chart.title.top';\\\\n            if (name == 'chart.title.font')  name = 'chart.title.top.font';\\\\n            if (name == 'chart.title.size')  name = 'chart.title.top.size';\\\\n            if (name == 'chart.title.color') name = 'chart.title.top.color';\\\\n            if (name == 'chart.title.bold')  name = 'chart.title.top.bold';\\\\n    \\\\n            // BC\\\\n            if (name == 'chart.needle.color') {\\\\n                name = 'chart.needle.colors';\\\\n            }\\\\n            \\\\n            // name change\\\\n            if (name == 'chart.labels.offset') {\\\\n                name = 'chart.labels.offset.radius';\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            prop[name] = value;\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * An all encompassing accessor\\\\n        * \\\\n        * @param string name The name of the property\\\\n        */\\\\n        this.get =\\\\n        this.Get = function (name)\\\\n        {\\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n    \\\\n            // BC\\\\n            if (name == 'chart.needle.color') {\\\\n                name = 'chart.needle.colors';\\\\n            }\\\\n\\\\n            // name change\\\\n            if (name == 'chart.labels.offset') {\\\\n                name = 'chart.labels.offset.radius';\\\\n            }\\\\n    \\\\n            return prop[name];\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The function you call to draw the line chart\\\\n        * \\\\n        * @param bool An optional bool used internally to ditinguish whether the\\\\n        *             line chart is being called by the bar chart\\\\n        */\\\\n        this.draw =\\\\n        this.Draw = function ()\\\\n        {\\\\n            /**\\\\n            * Fire the onbeforedraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'onbeforedraw');\\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Store the value (for animation primarily\\\\n            */\\\\n            this.currentValue = this.value;\\\\n    \\\\n    \\\\n            /**\\\\n            * This is new in May 2011 and facilitates indiviual gutter settings,\\\\n            * eg chart.gutter.left\\\\n            */\\\\n            this.gutterLeft   = prop['chart.gutter.left'];\\\\n            this.gutterRight  = prop['chart.gutter.right'];\\\\n            this.gutterTop    = prop['chart.gutter.top'];\\\\n            this.gutterBottom = prop['chart.gutter.bottom'];\\\\n            \\\\n            this.centerx = ((ca.width - this.gutterLeft - this.gutterRight) / 2) + this.gutterLeft;\\\\n            this.centery = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;\\\\n            this.radius  = Math.min(\\\\n                                    ((ca.width - this.gutterLeft - this.gutterRight) / 2),\\\\n                                    ((ca.height - this.gutterTop - this.gutterBottom) / 2)\\\\n                                   );\\\\n            this.startAngle = prop['chart.angles.start'] ? prop['chart.angles.start'] : (RG.HALFPI / 3) + RG.HALFPI;\\\\n            this.endAngle   = prop['chart.angles.end'] ? prop['chart.angles.end'] : RG.TWOPI + RG.HALFPI - (RG.HALFPI / 3);\\\\n            \\\\n            \\\\n            /**\\\\n            * Reset this so it doesn't keep growing\\\\n            */\\\\n            this.coordsText = [];\\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * You can now override the positioning and radius if you so wish.\\\\n            */\\\\n            if (typeof(prop['chart.centerx']) == 'number') this.centerx = prop['chart.centerx'];\\\\n            if (typeof(prop['chart.centery']) == 'number') this.centery = prop['chart.centery'];\\\\n            if (typeof(prop['chart.radius']) == 'number')  this.radius  = prop['chart.radius'];\\\\n    \\\\n            /**\\\\n            * Parse the colors. This allows for simple gradient syntax\\\\n            */\\\\n            if (!this.colorsParsed) {\\\\n                this.parseColors();\\\\n                \\\\n                // Don't want to do this again\\\\n                this.colorsParsed = true;\\\\n            }\\\\n    \\\\n    \\\\n            // This has to be in the constructor\\\\n            this.centerpinRadius = 0.16 * this.radius;\\\\n            \\\\n            if (typeof(prop['chart.centerpin.radius']) == 'number') {\\\\n                this.centerpinRadius = prop['chart.centerpin.radius'];\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Setup the context menu if required\\\\n            */\\\\n            if (prop['chart.contextmenu']) {\\\\n                RG.ShowContext(this);\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n            // DRAW THE CHART HERE\\\\n            this.DrawBackGround();\\\\n            this.DrawGradient();\\\\n            this.DrawColorBands();\\\\n            this.DrawSmallTickmarks();\\\\n            this.DrawMediumTickmarks();\\\\n            this.DrawBigTickmarks();\\\\n            this.DrawLabels();\\\\n            this.DrawTopTitle();\\\\n            this.DrawBottomTitle();\\\\n    \\\\n            if (typeof(this.value) == 'object') {\\\\n                for (var i=0; i<this.value.length; ++i) {\\\\n                    this.DrawNeedle(this.value[i], prop['chart.needle.colors'][i], i);\\\\n                }\\\\n            } else {\\\\n                this.DrawNeedle(this.value, prop['chart.needle.colors'][0], 0);\\\\n            }\\\\n    \\\\n            this.DrawCenterpin();\\\\n            \\\\n            /**\\\\n            * This function enables resizing\\\\n            */\\\\n            if (prop['chart.resizable']) {\\\\n                RG.AllowResizing(this);\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * This installs the event listeners\\\\n            */\\\\n            RG.InstallEventListeners(this);\\\\n    \\\\n\\\\n            /**\\\\n            * Fire the onfirstdraw event\\\\n            */\\\\n            if (this.firstDraw) {\\\\n                RG.fireCustomEvent(this, 'onfirstdraw');\\\\n                this.firstDraw = false;\\\\n                this.firstDrawFunc();\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Fire the RGraph ondraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'ondraw');\\\\n            \\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * Used in chaining. Runs a function there and then - not waiting for\\\\n        * the events to fire (eg the onbeforedraw event)\\\\n        * \\\\n        * @param function func The function to execute\\\\n        */\\\\n        this.exec = function (func)\\\\n        {\\\\n            func(this);\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draw the background\\\\n        */\\\\n        this.drawBackGround =\\\\n        this.DrawBackGround = function ()\\\\n        {\\\\n            // Shadow //////////////////////////////////////////////\\\\n            if (prop['chart.shadow']) {\\\\n                RG.SetShadow(this, prop['chart.shadow.color'], prop['chart.shadow.offsetx'], prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\\\\n            }\\\\n            \\\\n            co.beginPath();\\\\n                co.fillStyle = prop['chart.background.color'];\\\\n                //co.moveTo(this.centerx, this.centery)\\\\n                co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n            \\\\n            // Turn off the shadow\\\\n            RG.NoShadow(this);\\\\n            // Shadow //////////////////////////////////////////////\\\\n    \\\\n    \\\\n            var grad = co.createRadialGradient(this.centerx + 50, this.centery - 50, 0, this.centerx + 50, this.centery - 50, 150);\\\\n            grad.addColorStop(0, '#eee');\\\\n            grad.addColorStop(1, 'white');\\\\n    \\\\n            var borderWidth = prop['chart.border.width'];\\\\n    \\\\n            co.beginPath();\\\\n                co.fillStyle = prop['chart.background.color'];\\\\n                co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n    \\\\n            /**\\\\n            * Draw the gray circle\\\\n            */\\\\n            co.beginPath();\\\\n                co.fillStyle = prop['chart.border.outer'];\\\\n                co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n    \\\\n            /**\\\\n            * Draw the light gray inner border\\\\n            */\\\\n            co.beginPath();\\\\n                co.fillStyle = prop['chart.border.inner'];\\\\n                co.arc(this.centerx, this.centery, this.radius - borderWidth, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n    \\\\n    \\\\n    \\\\n            // Draw the white circle inner border\\\\n            co.beginPath();\\\\n                co.fillStyle = prop['chart.background.color'];\\\\n                co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n    \\\\n    \\\\n    \\\\n            // Draw the circle background. Can be any colour now.\\\\n            co.beginPath();\\\\n                co.fillStyle = prop['chart.background.color'];\\\\n                co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n    \\\\n            if (prop['chart.background.gradient']) {\\\\n\\\\n                // Draw a partially transparent gradient that sits on top of the background\\\\n                co.beginPath();\\\\n                    co.fillStyle = RG.RadialGradient(this,\\\\n                                                     this.centerx,\\\\n                                                     this.centery,\\\\n                                                     0,\\\\n                                                     this.centerx,\\\\n                                                     this.centery,\\\\n                                                     this.radius,\\\\n                                                     'rgba(255,255,255,0.6)',\\\\n                                                     'rgba(255,255,255,0.1)');\\\\n                    co.arc(this.centerx, this.centery, this.radius - borderWidth - 4, 0, RG.TWOPI, 0);\\\\n                co.fill();\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n            // Draw a black border around the chart\\\\n            co.beginPath();\\\\n                co.strokeStyle = prop['chart.border.outline'];\\\\n                co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, 0);\\\\n            co.stroke();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the smaller tickmarks\\\\n        */\\\\n        this.drawSmallTickmarks =\\\\n        this.DrawSmallTickmarks = function ()\\\\n        {\\\\n            var numTicks = prop['chart.tickmarks.small'];\\\\n            co.lineWidth = 1;\\\\n    \\\\n            for (var i=0; i<=numTicks; ++i) {\\\\n                co.beginPath();\\\\n                    co.strokeStyle = prop['chart.tickmarks.small.color'];\\\\n                    var a = (((this.endAngle - this.startAngle) / numTicks) * i) + this.startAngle;\\\\n                    co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);\\\\n                    co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 5, a, a + 0.00001, 0);\\\\n                co.stroke();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the medium sized tickmarks\\\\n        */\\\\n        this.drawMediumTickmarks =\\\\n        this.DrawMediumTickmarks = function ()\\\\n        {\\\\n            if (prop['chart.tickmarks.medium']) {\\\\n    \\\\n                var numTicks = prop['chart.tickmarks.medium'];\\\\n                co.lineWidth = 3;\\\\n                co.lineCap   = 'round';\\\\n                co.strokeStyle = prop['chart.tickmarks.medium.color'];\\\\n        \\\\n                for (var i=0; i<=numTicks; ++i) {\\\\n                    co.beginPath();\\\\n                        var a = (((this.endAngle - this.startAngle) / numTicks) * i) + this.startAngle + (((this.endAngle - this.startAngle) / (2 * numTicks)));\\\\n                        \\\\n                        if (a > this.startAngle && a< this.endAngle) {\\\\n                            co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);\\\\n                            co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 6, a, a + 0.00001, 0);\\\\n                        }\\\\n                    co.stroke();\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the large, bold tickmarks\\\\n        */\\\\n        this.drawBigTickmarks =\\\\n        this.DrawBigTickmarks = function ()\\\\n        {\\\\n            var numTicks = prop['chart.tickmarks.big'];\\\\n            co.lineWidth = 3;\\\\n            co.lineCap   = 'round';\\\\n    \\\\n            for (var i=0; i<=numTicks; ++i) {\\\\n                co.beginPath();\\\\n                    co.strokeStyle = prop['chart.tickmarks.big.color'];\\\\n                    var a = (((this.endAngle - this.startAngle) / numTicks) * i) + this.startAngle;\\\\n                    co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10, a, a + 0.00001, 0);\\\\n                    co.arc(this.centerx, this.centery, this.radius - prop['chart.border.width'] - 10 - 10, a, a + 0.00001, 0);\\\\n                co.stroke();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the centerpin\\\\n        */\\\\n        this.drawCenterpin =\\\\n        this.DrawCenterpin = function ()\\\\n        {\\\\n            var offset = 6;\\\\n    \\\\n            var grad = co.createRadialGradient(this.centerx + offset, this.centery - offset, 0, this.centerx + offset, this.centery - offset, 25);\\\\n            grad.addColorStop(0, '#ddf');\\\\n            grad.addColorStop(1, prop['chart.centerpin.color']);\\\\n    \\\\n            co.beginPath();\\\\n                co.fillStyle = grad;\\\\n                co.arc(this.centerx, this.centery, this.centerpinRadius, 0, RG.TWOPI, 0);\\\\n            co.fill();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the labels\\\\n        */\\\\n        this.drawLabels =\\\\n        this.DrawLabels = function ()\\\\n        {\\\\n            co.fillStyle = prop['chart.text.color'];\\\\n            \\\\n            var font    = prop['chart.text.font'],\\\\n                size    = prop['chart.text.size'],\\\\n                num     = prop['chart.labels.specific'] ? (prop['chart.labels.specific'].length - 1) : prop['chart.labels.count'],\\\\n                offsetx = prop['chart.labels.offsetx'],\\\\n                offsety = prop['chart.labels.offsety'],\\\\n                offseta = prop['chart.labels.offset.angle']\\\\n\\\\n            co.beginPath();\\\\n                if (num) {\\\\n                    for (var i=0; i<=num; ++i) {\\\\n                        var hyp = (this.radius - 25 - prop['chart.border.width']) - prop['chart.labels.offset.radius'];\\\\n                        var a   = (this.endAngle - this.startAngle) / num\\\\n                            a   = this.startAngle + (i * a);\\\\n                            a  -= RG.HALFPI;\\\\n                            a += offseta;\\\\n\\\\n\\\\n                        var x = this.centerx - (ma.sin(a) * hyp);\\\\n                        var y = this.centery + (ma.cos(a) * hyp);\\\\n\\\\n                        var hAlign = x > this.centerx ? 'right' : 'left';\\\\n                        var vAlign = y > this.centery ? 'bottom' : 'top';\\\\n                        \\\\n                        // This handles the label alignment when the label is on a PI/HALFPI boundary\\\\n                        if (a == RG.HALFPI) {\\\\n                            vAlign = 'center';\\\\n                        } else if (a == RG.PI) {\\\\n                            hAlign = 'center';\\\\n                        } else if (a == (RG.HALFPI + RG.PI) ) {\\\\n                            vAlign = 'center';\\\\n                        }\\\\n                        \\\\n                        /**\\\\n                        * Can now force center alignment\\\\n                        */\\\\n                        if (prop['chart.labels.centered']) {\\\\n                            hAlign = 'center';\\\\n                            vAlign = 'center';\\\\n                        }\\\\n                        \\\\n                        var value = (((this.max - this.min) * (i / num)) + this.min);\\\\n        \\\\n\\\\n                        RG.text2(this, {\\\\n                            'font':font,\\\\n                            'size':size,\\\\n                            'x':x + offsetx,\\\\n                            'y':y + offsety,\\\\n                            'text':prop['chart.labels.specific'] ? prop['chart.labels.specific'][i] : RG.numberFormat(this, value.toFixed(value === 0 ? 0 : prop['chart.scale.decimals']), prop['chart.units.pre'], prop['chart.units.post']),\\\\n                            'halign':hAlign,\\\\n                            'valign':vAlign,\\\\n                            'tag': prop['chart.labels.specific'] ? 'labels.specific' : 'labels'\\\\n                        });\\\\n                    }\\\\n                }\\\\n            co.fill();\\\\n    \\\\n    \\\\n            /**\\\\n            * Draw the textual value if requested\\\\n            */\\\\n            if (prop['chart.value.text']) {\\\\n    \\\\n                var x = this.centerx;\\\\n                var y = this.centery + (prop['chart.value.text.y.pos'] * this.radius);\\\\n                \\\\n                var units_pre      = typeof(prop['chart.value.text.units.pre']) == 'string' ? prop['chart.value.text.units.pre'] : prop['chart.units.pre'];\\\\n                var units_post     = typeof(prop['chart.value.text.units.post']) == 'string' ? prop['chart.value.text.units.post'] : prop['chart.units.post'];\\\\n                var color          = prop['chart.value.text.color'];\\\\n                var bounding       = prop['chart.value.text.bounding'];\\\\n                var boundingFill   = prop['chart.value.text.bounding.fill'];\\\\n                var boundingStroke = prop['chart.value.text.bounding.stroke'];\\\\n                \\\\n                co.fillStyle = color;\\\\n            \\\\n                RG.text2(this, {\\\\n                    'font':font,\\\\n                    'size':size + 2,\\\\n                    'x':x,\\\\n                    'y':y,\\\\n                    'text':RG.numberFormat(this, this.value.toFixed(prop['chart.value.text.decimals']), units_pre, units_post),\\\\n                    'halign':'center',\\\\n                    'valign':'center',\\\\n                    'bounding':bounding,\\\\n                    'bounding.fill':boundingFill,\\\\n                    'bounding.stroke': boundingStroke,\\\\n                    'tag': 'value.text'\\\\n                });\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the top title\\\\n        */\\\\n        this.drawTopTitle =\\\\n        this.DrawTopTitle = function ()\\\\n        {\\\\n            var x = this.centerx;\\\\n            var y = this.centery - 25;\\\\n            \\\\n            // Totally override the calculated positioning\\\\n            if (typeof(prop['chart.title.top.pos']) == 'number') {\\\\n                y = this.centery - (this.radius * prop['chart.title.top.pos']);\\\\n            }\\\\n    \\\\n            if (prop['chart.title.top']) {\\\\n                co.fillStyle = prop['chart.title.top.color'];\\\\n                RG.Text2(this, {'font':prop['chart.title.top.font'],\\\\n                                'size':prop['chart.title.top.size'],\\\\n                                'x':x,\\\\n                                'y':y,\\\\n                                'text':String(prop['chart.title.top']),\\\\n                                'halign':'center',\\\\n                                'valign':'bottom',\\\\n                                'bold':prop['chart.title.top.bold'],\\\\n                                'tag': 'title.top'\\\\n                               });\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the bottom title\\\\n        */\\\\n        this.drawBottomTitle =\\\\n        this.DrawBottomTitle = function ()\\\\n        {\\\\n            var x = this.centerx;\\\\n            var y = this.centery + this.centerpinRadius + 10;\\\\n    \\\\n            // Totally override the calculated positioning\\\\n            if (typeof(prop['chart.title.bottom.pos']) == 'number') {\\\\n                y = this.centery + (this.radius * prop['chart.title.bottom.pos']);\\\\n            }\\\\n    \\\\n            if (prop['chart.title.bottom']) {\\\\n                co.fillStyle = prop['chart.title.bottom.color'];\\\\n    \\\\n                RG.Text2(this, {'font':prop['chart.title.bottom.font'],\\\\n                                'size':prop['chart.title.bottom.size'],\\\\n                                'x':x,\\\\n                                'y':y,\\\\n                                'text':String(prop['chart.title.bottom']),\\\\n                                'halign':'center',\\\\n                                'valign':'top',\\\\n                                'bold':prop['chart.title.bottom.bold'],\\\\n                                'tag': 'title.bottom'\\\\n                               });\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the Needle\\\\n        * \\\\n        * @param number value The value to draw the needle for\\\\n        */\\\\n        this.drawNeedle =\\\\n        this.DrawNeedle = function (value, color, index)\\\\n        {\\\\n            var type = prop['chart.needle.type'];\\\\n    \\\\n            co.lineWidth   = 0.5;\\\\n            co.strokeStyle = 'gray';\\\\n            co.fillStyle   = color;\\\\n    \\\\n            var angle = (this.endAngle - this.startAngle) * ((value - this.min) / (this.max - this.min));\\\\n                angle += this.startAngle;\\\\n    \\\\n    \\\\n            // Work out the size of the needle\\\\n            if (   typeof(prop['chart.needle.size']) == 'object'\\\\n                && prop['chart.needle.size']\\\\n                && typeof(prop['chart.needle.size'][index]) == 'number') {\\\\n    \\\\n                var size = prop['chart.needle.size'][index];\\\\n    \\\\n            } else if (typeof(prop['chart.needle.size']) == 'number') {\\\\n                var size = prop['chart.needle.size'];\\\\n    \\\\n            } else {\\\\n                var size = this.radius - 25 - prop['chart.border.width'];\\\\n            }\\\\n    \\\\n            \\\\n    \\\\n            if (type == 'line') {\\\\n    \\\\n                co.beginPath();\\\\n                \\\\n                    co.lineWidth = prop['chart.needle.width'];\\\\n                    co.strokeStyle = color;\\\\n                    \\\\n                    co.arc(this.centerx,\\\\n                                     this.centery,\\\\n                                     size,\\\\n                                     angle,\\\\n                                     angle + 0.0001,\\\\n                                     false);\\\\n                    \\\\n                    co.lineTo(this.centerx, this.centery);\\\\n                    \\\\n                    if (prop['chart.needle.tail']) {\\\\n                        co.arc(this.centerx, this.centery, this.radius * 0.2  , angle + RG.PI, angle + 0.00001 + RG.PI, false);\\\\n                    }\\\\n                    \\\\n                    co.lineTo(this.centerx, this.centery);\\\\n        \\\\n                co.stroke();\\\\n                //co.fill();\\\\n    \\\\n            } else {\\\\n        \\\\n                co.beginPath();\\\\n                    co.arc(this.centerx, this.centery, size, angle, angle + 0.00001, false);\\\\n                    co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle + RG.HALFPI, angle + 0.00001 + RG.HALFPI, false);\\\\n                    \\\\n                    if (prop['chart.needle.tail']) {\\\\n                        co.arc(this.centerx, this.centery, this.radius * 0.2  , angle + RG.PI, angle + 0.00001 + RG.PI, false);\\\\n                    }\\\\n        \\\\n                    co.arc(this.centerx, this.centery, this.centerpinRadius * 0.5, angle - RG.HALFPI, angle - 0.00001 - RG.HALFPI, false);\\\\n                co.stroke();\\\\n                co.fill();\\\\n                \\\\n                /**\\\\n                * Store the angle in an object variable\\\\n                */\\\\n                this.angle = angle;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This draws the green background to the tickmarks\\\\n        */\\\\n        this.drawColorBands =\\\\n        this.DrawColorBands = function ()\\\\n        {\\\\n            if (RG.is_array(prop['chart.colors.ranges'])) {\\\\n    \\\\n                var ranges = prop['chart.colors.ranges'];\\\\n    \\\\n                for (var i=0; i<ranges.length; ++i) {\\\\n    \\\\n                    //co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : ranges[i][2];\\\\n                    co.fillStyle = ranges[i][2];\\\\n                    co.lineWidth = 0;//prop['chart.linewidth.segments'];\\\\n    \\\\n                    co.beginPath();\\\\n                        co.arc(this.centerx,\\\\n                                         this.centery,\\\\n                                         this.radius - 10 - prop['chart.border.width'],\\\\n                                         (((ranges[i][0] - this.min) / (this.max - this.min)) * (this.endAngle - this.startAngle)) + this.startAngle,\\\\n                                         (((ranges[i][1] - this.min) / (this.max - this.min)) * (this.endAngle - this.startAngle)) + this.startAngle,\\\\n                                         false);\\\\n    \\\\n                        co.arc(this.centerx,\\\\n                                         this.centery,\\\\n                                         this.radius - 20 - prop['chart.border.width'],\\\\n                                         (((ranges[i][1] - this.min) / (this.max - this.min)) * (this.endAngle - this.startAngle)) + this.startAngle,\\\\n                                         (((ranges[i][0] - this.min) / (this.max - this.min)) * (this.endAngle - this.startAngle)) + this.startAngle,\\\\n                                         true);\\\\n                    co.closePath();\\\\n                    co.fill();\\\\n                }\\\\n    \\\\n                return;\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Draw the GREEN region\\\\n            */\\\\n            co.strokeStyle = prop['chart.green.color'];\\\\n            co.fillStyle = prop['chart.green.color'];\\\\n            \\\\n            var greenStart = this.startAngle;\\\\n            var greenEnd   = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.green.end'] - this.min) / (this.max - this.min))\\\\n    \\\\n            co.beginPath();\\\\n                co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], greenStart, greenEnd, false);\\\\n                co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.green.width']) - prop['chart.border.width'], greenEnd, greenStart, true);\\\\n            co.fill();\\\\n    \\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Draw the YELLOW region\\\\n            */\\\\n            co.strokeStyle = prop['chart.yellow.color'];\\\\n            co.fillStyle = prop['chart.yellow.color'];\\\\n            \\\\n            var yellowStart = greenEnd;\\\\n            var yellowEnd   = this.startAngle + (this.endAngle - this.startAngle) * ((prop['chart.red.start'] - this.min) / (this.max - this.min))\\\\n    \\\\n            co.beginPath();\\\\n                co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], yellowStart, yellowEnd, false);\\\\n                co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.yellow.width']) - prop['chart.border.width'], yellowEnd, yellowStart, true);\\\\n            co.fill();\\\\n    \\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Draw the RED region\\\\n            */\\\\n            co.strokeStyle = prop['chart.red.color'];\\\\n            co.fillStyle = prop['chart.red.color'];\\\\n            \\\\n            var redStart = yellowEnd;\\\\n            var redEnd   = this.startAngle + (this.endAngle - this.startAngle) * ((this.max - this.min) / (this.max - this.min))\\\\n    \\\\n            co.beginPath();\\\\n                co.arc(this.centerx, this.centery, this.radius - 10 - prop['chart.border.width'], redStart, redEnd, false);\\\\n                co.arc(this.centerx, this.centery, this.radius - (10 + prop['chart.red.width']) - prop['chart.border.width'], redEnd, redStart, true);\\\\n            co.fill();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A placeholder function\\\\n        * \\\\n        * @param object The event object\\\\n        */\\\\n        this.getShape = function (e) {};\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A getValue method\\\\n        * \\\\n        * @param object e An event object\\\\n        */\\\\n        this.getValue = function (e)\\\\n        {\\\\n            var mouseXY = RG.getMouseXY(e);\\\\n            var mouseX  = mouseXY[0];\\\\n            var mouseY  = mouseXY[1];\\\\n    \\\\n            var angle = RG.getAngleByXY(this.centerx, this.centery, mouseX, mouseY);\\\\n    \\\\n            if (angle >= 0 && angle <= RG.HALFPI) {\\\\n                angle += RG.TWOPI;\\\\n            }\\\\n    \\\\n            var value = ((angle - this.startAngle) / (this.endAngle - this.startAngle)) * (this.max - this.min);\\\\n                value = value + this.min;\\\\n    \\\\n            if (value < this.min) {\\\\n                value = this.min\\\\n            }\\\\n    \\\\n            if (value > this.max) {\\\\n                value = this.max\\\\n            }\\\\n    \\\\n            return value;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The getObjectByXY() worker method. Don't call this call:\\\\n        * \\\\n        * RGraph.ObjectRegistry.getObjectByXY(e)\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.getObjectByXY = function (e)\\\\n        {\\\\n            var mouseXY = RGraph.getMouseXY(e);\\\\n    \\\\n            if (\\\\n                   mouseXY[0] > (this.centerx - this.radius)\\\\n                && mouseXY[0] < (this.centerx + this.radius)\\\\n                && mouseXY[1] > (this.centery - this.radius)\\\\n                && mouseXY[1] < (this.centery + this.radius)\\\\n                && RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]) <= this.radius\\\\n                ) {\\\\n    \\\\n                return this;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This draws the gradient that goes around the Gauge chart\\\\n        */\\\\n        this.drawGradient =\\\\n        this.DrawGradient = function ()\\\\n        {\\\\n            if (prop['chart.border.gradient']) {\\\\n                \\\\n                co.beginPath();\\\\n        \\\\n                    var grad = co.createRadialGradient(this.centerx, this.centery, this.radius, this.centerx, this.centery, this.radius - 15);\\\\n                    grad.addColorStop(0, 'gray');\\\\n                    grad.addColorStop(1, 'white');\\\\n        \\\\n                    co.fillStyle = grad;\\\\n                    co.arc(this.centerx, this.centery, this.radius, 0, RG.TWOPI, false)\\\\n                    co.arc(this.centerx, this.centery, this.radius - 15, RG.TWOPI,0, true)\\\\n                co.fill();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This method handles the adjusting calculation for when the mouse is moved\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.adjusting_mousemove =\\\\n        this.Adjusting_mousemove = function (e)\\\\n        {\\\\n            /**\\\\n            * Handle adjusting for the Bar\\\\n            */\\\\n            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\\\\n                this.value = this.getValue(e);\\\\n                //RG.Clear(this.canvas);\\\\n                RG.redrawCanvas(this.canvas);\\\\n                RG.fireCustomEvent(this, 'onadjust');\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This method returns an appropriate angle for the given value (in RADIANS)\\\\n        * \\\\n        * @param number value The value to get the angle for\\\\n        */\\\\n        this.getAngle = function (value)\\\\n        {\\\\n            // Higher than max\\\\n            if (value > this.max || value < this.min) {\\\\n                return null;\\\\n            }\\\\n    \\\\n            //var value = ((angle - this.startAngle) / (this.endAngle - this.startAngle)) * (this.max - this.min);\\\\n                //value = value + this.min;\\\\n    \\\\n            var angle = (((value - this.min) / (this.max - this.min)) * (this.endAngle - this.startAngle)) + this.startAngle;\\\\n            \\\\n            return angle;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This allows for easy specification of gradients. Could optimise this not to repeatedly call parseSingleColors()\\\\n        */\\\\n        this.parseColors = function ()\\\\n        {\\\\n            // Save the original colors so that they can be restored when the canvas is reset\\\\n            if (this.original_colors.length === 0) {\\\\n                this.original_colors['chart.background.color'] = RG.array_clone(prop['chart.background.color']);\\\\n                this.original_colors['chart.red.color']        = RG.array_clone(prop['chart.red.color']);\\\\n                this.original_colors['chart.yellow.color']     = RG.array_clone(prop['chart.yellow.color']);\\\\n                this.original_colors['chart.green.color']      = RG.array_clone(prop['chart.green.color']);\\\\n                this.original_colors['chart.border.inner']     = RG.array_clone(prop['chart.border.inner']);\\\\n                this.original_colors['chart.border.outer']     = RG.array_clone(prop['chart.border.outer']);\\\\n                this.original_colors['chart.colors.ranges']    = RG.array_clone(prop['chart.colors.ranges']);\\\\n                this.original_colors['chart.needle.colors']    = RG.array_clone(prop['chart.needle.colors']);\\\\n            }\\\\n\\\\n            prop['chart.background.color'] = this.parseSingleColorForGradient(prop['chart.background.color']);\\\\n            prop['chart.red.color']        = this.parseSingleColorForGradient(prop['chart.red.color']);\\\\n            prop['chart.yellow.color']     = this.parseSingleColorForGradient(prop['chart.yellow.color']);\\\\n            prop['chart.green.color']      = this.parseSingleColorForGradient(prop['chart.green.color']);\\\\n            prop['chart.border.inner']     = this.parseSingleColorForGradient(prop['chart.border.inner']);\\\\n            prop['chart.border.outer']     = this.parseSingleColorForGradient(prop['chart.border.outer']);\\\\n            \\\\n            // Parse the chart.color.ranges value\\\\n            if (prop['chart.colors.ranges']) {\\\\n                \\\\n                var ranges = prop['chart.colors.ranges'];\\\\n    \\\\n                for (var i=0; i<ranges.length; ++i) {\\\\n                    ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2], this.radius - 30);\\\\n                }\\\\n            }\\\\n    \\\\n            // Parse the chart.needle.colors value\\\\n            if (prop['chart.needle.colors']) {\\\\n                \\\\n                var colors = prop['chart.needle.colors'];\\\\n    \\\\n                for (var i=0; i<colors.length; ++i) {\\\\n                    colors[i] = this.parseSingleColorForGradient(colors[i]);\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Use this function to reset the object to the post-constructor state. Eg reset colors if\\\\n        * need be etc\\\\n        */\\\\n        this.reset = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This parses a single color value\\\\n        * \\\\n        * @param string color    The color to look for a gradient in\\\\n        * @param radius OPTIONAL The start radius to start the gradient at.\\\\n        *                        If not suppllied the centerx value is used\\\\n        */\\\\n        this.parseSingleColorForGradient = function (color)\\\\n        {\\\\n            var radiusStart = arguments[1] || 0;\\\\n\\\\n            if (!color || typeof(color) != 'string') {\\\\n                return color;\\\\n            }\\\\n    \\\\n            if (color.match(/^gradient\\\\\\\\((.*)\\\\\\\\)\\\\\\\$/i)) {\\\\n                \\\\n                var parts = RegExp.\\\\\\\$1.split(':');\\\\n    \\\\n                // Create the gradient\\\\n                var grad = co.createRadialGradient(this.centerx,\\\\n                                                   this.centery,\\\\n                                                   radiusStart,\\\\n                                                   this.centerx,\\\\n                                                   this.centery,\\\\n                                                   this.radius\\\\n                                                  );\\\\n    \\\\n                var diff = 1 / (parts.length - 1);\\\\n    \\\\n                grad.addColorStop(0, RG.trim(parts[0]));\\\\n    \\\\n                for (var j=1; j<parts.length; ++j) {\\\\n                    grad.addColorStop(j * diff, RG.trim(parts[j]));\\\\n                }\\\\n            }\\\\n\\\\n            return grad ? grad : color;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Using a function to add events makes it easier to facilitate method chaining\\\\n        * \\\\n        * @param string   type The type of even to add\\\\n        * @param function func \\\\n        */\\\\n        this.on = function (type, func)\\\\n        {\\\\n            if (type.substr(0,2) !== 'on') {\\\\n                type = 'on' + type;\\\\n            }\\\\n            \\\\n            if (typeof this[type] !== 'function') {\\\\n                this[type] = func;\\\\n            } else {\\\\n                RG.addCustomEventListener(this, type, func);\\\\n            }\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function runs once only\\\\n        * (put at the end of the file (before any effects))\\\\n        */\\\\n        this.firstDrawFunc = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Gauge Grow\\\\n        * \\\\n        * This effect gradually increases the represented value\\\\n        * \\\\n        * @param object       Options for the effect. You can pass frames here\\\\n        * @param function     An optional callback function\\\\n        */\\\\n        this.grow = function ()\\\\n        {\\\\n            var obj      = this;\\\\n            var opt      = arguments[0] ? arguments[0] : {};\\\\n            var callback = arguments[1] ? arguments[1] : function () {};\\\\n            var frames   = opt.frames || 30;\\\\n            var frame    = 0;\\\\n\\\\n            // Single pointer\\\\n            if (typeof obj.value === 'number') {\\\\n    \\\\n                var origValue = Number(obj.currentValue);\\\\n    \\\\n                if (obj.currentValue == null) {\\\\n                    obj.currentValue = obj.min;\\\\n                    origValue = obj.min;\\\\n                }\\\\n    \\\\n                var newValue  = obj.value;\\\\n                var diff      = newValue - origValue;\\\\n    \\\\n    \\\\n                var iterator = function ()\\\\n                {\\\\n                    obj.value = ((frame / frames) * diff) + origValue;\\\\n\\\\n                    if (obj.value > obj.max) obj.value = obj.max;\\\\n                    if (obj.value < obj.min) obj.value = obj.min;\\\\n        \\\\n                    //RGraph.clear(obj.canvas);\\\\n                    RG.redrawCanvas(obj.canvas);\\\\n        \\\\n                    if (frame++ < frames) {\\\\n                        RG.Effects.updateCanvas(iterator);\\\\n                    } else {\\\\n                        callback(obj);\\\\n                    }\\\\n                };\\\\n    \\\\n                iterator();\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Multiple pointers\\\\n            */\\\\n            } else {\\\\n\\\\n                if (obj.currentValue == null) {\\\\n                    obj.currentValue = [];\\\\n                    \\\\n                    for (var i=0; i<obj.value.length; ++i) {\\\\n                        obj.currentValue[i] = obj.min;\\\\n                    }\\\\n                    \\\\n                    origValue = RG.array_clone(obj.currentValue);\\\\n                }\\\\n\\\\n                var origValue = RG.array_clone(obj.currentValue);\\\\n                var newValue  = RG.array_clone(obj.value);\\\\n                var diff      = [];\\\\n\\\\n                for (var i=0,len=newValue.length; i<len; ++i) {\\\\n                    diff[i] = newValue[i] - Number(obj.currentValue[i]);\\\\n                }\\\\n\\\\n\\\\n\\\\n                var iterator = function ()\\\\n                {\\\\n                    frame++;\\\\n\\\\n                    for (var i=0,len=obj.value.length; i<len; ++i) {\\\\n\\\\n                        obj.value[i] = ((frame / frames) * diff[i]) + origValue[i];\\\\n\\\\n                        if (obj.value[i] > obj.max) obj.value[i] = obj.max;\\\\n                        if (obj.value[i] < obj.min) obj.value[i] = obj.min;\\\\n                    }\\\\n\\\\n                    //RG.clear(obj.canvas);\\\\n                    RG.redrawCanvas(obj.canvas);\\\\n\\\\n\\\\n                    if (frame < frames) {\\\\n                        RG.Effects.updateCanvas(iterator);\\\\n                    } else {\\\\n                        callback(obj);\\\\n                    }\\\\n                };\\\\n        \\\\n                iterator();\\\\n            }\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n        RG.att(ca);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Register the object\\\\n        */\\\\n        RG.Register(this);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This is the 'end' of the constructor so if the first argument\\\\n        * contains configuration data - handle that.\\\\n        */\\\\n        if (parseConfObjectForOptions) {\\\\n            RG.parseObjectStyleConfig(this, conf.options);\\\\n        }\\\\n    };\\\";\");\";}}");

?>