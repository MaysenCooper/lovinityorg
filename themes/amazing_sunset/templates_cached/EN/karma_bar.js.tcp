<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:2:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dd9c02389840.54427650_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:1;a:5:{i:0;s:33:\"tcpfunc_58dd9c02389a66.55847519_2\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:9:\"karma_bar\";i:3;N;i:4;a:2:{s:33:\"tcpfunc_58dd9c02389840.54427650_1\";s:3685:\"\$tpl_funcs['tcpfunc_58dd9c02389840.54427650_1']=\" echo \\\"/*\\\\njquery-circle-progress - jQuery Plugin to draw animated circular progress bars\\\\nURL: http://kottenator.github.io/jquery-circle-progress/\\\\nAuthor: Rostyslav Bryzgunov <kottenator@gmail.com>\\\\nVersion: 1.1.3\\\\nLicense: MIT\\\\n*/\\\\n(function(\\\\\\\$) {\\\\n    function CircleProgress(config) {\\\\n        this.init(config);\\\\n    }\\\\n\\\\n    CircleProgress.prototype = {\\\\n        //----------------------------------------------- public options -----------------------------------------------\\\\n        /**\\\\n         * This is the only required option. It should be from 0.0 to 1.0\\\\n         * @type {number}\\\\n         */\\\\n        value: 0.0,\\\\n\\\\n        /**\\\\n         * Size of the circle / canvas in pixels\\\\n         * @type {number}\\\\n         */\\\\n        size: 100.0,\\\\n\\\\n        /**\\\\n         * Initial angle for 0.0 value in radians\\\\n         * @type {number}\\\\n         */\\\\n        startAngle: -Math.PI,\\\\n\\\\n        /**\\\\n         * Width of the arc. By default it's auto-calculated as 1/14 of size, but you may set it explicitly in pixels\\\\n         * @type {number|string}\\\\n         */\\\\n        thickness: 'auto',\\\\n\\\\n        /**\\\\n         * Fill of the arc. You may set it to:\\\\n         *   - solid color:\\\\n         *     - { color: '#3aeabb' }\\\\n         *     - { color: 'rgba(255, 255, 255, .3)' }\\\\n         *   - linear gradient (left to right):\\\\n         *     - { gradient: ['#3aeabb', '#fdd250'], gradientAngle: Math.PI / 4 }\\\\n         *     - { gradient: ['red', 'green', 'blue'], gradientDirection: [x0, y0, x1, y1] }\\\\n         *   - image:\\\\n         *     - { image: 'http://i.imgur.com/pT0i89v.png' }\\\\n         *     - { image: imageObject }\\\\n         *     - { color: 'lime', image: 'http://i.imgur.com/pT0i89v.png' } - color displayed until the image is loaded\\\\n         */\\\\n        fill: {\\\\n            gradient: ['#3aeabb', '#fdd250']\\\\n        },\\\\n\\\\n        /**\\\\n         * Color of the \\\\\\\"empty\\\\\\\" arc. Only a color fill supported by now\\\\n         * @type {string}\\\\n         */\\\\n        emptyFill: 'rgba(0, 0, 0, .1)',\\\\n\\\\n        /**\\\\n         * Animation config (see jQuery animations: http://api.jquery.com/animate/)\\\\n         */\\\\n        animation: {\\\\n            duration: 1200,\\\\n            easing: 'circleProgressEasing'\\\\n        },\\\\n\\\\n        /**\\\\n         * Default animation starts at 0.0 and ends at specified `value`. Let's call this direct animation.\\\\n         * If you want to make reversed animation then you should set `animationStartValue` to 1.0.\\\\n         * Also you may specify any other value from 0.0 to 1.0\\\\n         * @type {number}\\\\n         */\\\\n        animationStartValue: 0.0,\\\\n\\\\n        /**\\\\n         * Reverse animation and arc draw\\\\n         * @type {boolean}\\\\n         */\\\\n        reverse: false,\\\\n\\\\n        /**\\\\n         * Arc line cap ('butt', 'round' or 'square')\\\\n         * Read more: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.lineCap\\\\n         * @type {string}\\\\n         */\\\\n        lineCap: 'butt',\\\\n\\\\n        //-------------------------------------- protected properties and methods --------------------------------------\\\\n        /**\\\\n         * @protected\\\\n         */\\\\n        constructor: CircleProgress,\\\\n\\\\n        /**\\\\n         * Container element. Should be passed into constructor config\\\\n         * @protected\\\\n         * @type {jQuery}\\\\n         */\\\\n        el: null,\\\\n\\\\n        /**\\\\n         * Canvas element. Automatically generated and prepended to the {@link CircleProgress.el container}\\\\n         * @protected\\\\n         * @type \\\";\";\";s:33:\"tcpfunc_58dd9c02389a66.55847519_2\";s:11740:\"\$tpl_funcs['tcpfunc_58dd9c02389a66.55847519_2']=\"eval(\\\$FULL_RESET_VAR_CODE); echo otp(isset(\\\$bound_HTMLCanvasElement)?\\\$bound_HTMLCanvasElement:null,\\\"HTMLCanvasElement/karma_bar\\\"),\\n	\\\"\\\\n         */\\\\n        canvas: null,\\\\n\\\\n        /**\\\\n         * 2D-context of the {@link CircleProgress.canvas canvas}\\\\n         * @protected\\\\n         * @type {CanvasRenderingContext2D}\\\\n         */\\\\n        ctx: null,\\\\n\\\\n        /**\\\\n         * Radius of the outer circle. Automatically calculated as {@link CircleProgress.size} / 2\\\\n         * @protected\\\\n         * @type {number}\\\\n         */\\\\n        radius: 0.0,\\\\n\\\\n        /**\\\\n         * Fill of the main arc. Automatically calculated, depending on {@link CircleProgress.fill} option\\\\n         * @protected\\\\n         * @type {string|CanvasGradient|CanvasPattern}\\\\n         */\\\\n        arcFill: null,\\\\n\\\\n        /**\\\\n         * Last rendered frame value\\\\n         * @protected\\\\n         * @type {number}\\\\n         */\\\\n        lastFrameValue: 0.0,\\\\n\\\\n        /**\\\\n         * Init/re-init the widget\\\\n         * @param {object} config - Config\\\\n         */\\\\n        init: function(config) {\\\\n            \\\\\\\$.extend(this, config);\\\\n            this.radius = this.size / 2;\\\\n            this.initWidget();\\\\n            this.initFill();\\\\n            this.draw();\\\\n        },\\\\n\\\\n        /**\\\\n         * @protected\\\\n         */\\\\n        initWidget: function() {\\\\n            var canvas = this.canvas = this.canvas || \\\\\\\$('<canvas>').prependTo(this.el)[0];\\\\n            canvas.width = this.size;\\\\n            canvas.height = this.size;\\\\n            this.ctx = canvas.getContext('2d');\\\\n        },\\\\n\\\\n        /**\\\\n         * This method sets {@link CircleProgress.arcFill}\\\\n         * It could do this async (on image load)\\\\n         * @protected\\\\n         */\\\\n        initFill: function() {\\\\n            var self = this,\\\\n                fill = this.fill,\\\\n                ctx = this.ctx,\\\\n                size = this.size;\\\\n\\\\n            if (!fill)\\\\n                throw Error(\\\\\\\"The fill is not specified!\\\\\\\");\\\\n\\\\n            if (fill.color)\\\\n                this.arcFill = fill.color;\\\\n\\\\n            if (fill.gradient) {\\\\n                var gr = fill.gradient;\\\\n\\\\n                if (gr.length == 1) {\\\\n                    this.arcFill = gr[0];\\\\n                } else if (gr.length > 1) {\\\\n                    var ga = fill.gradientAngle || 0, // gradient direction angle; 0 by default\\\\n                        gd = fill.gradientDirection || [\\\\n                            size / 2 * (1 - Math.cos(ga)), // x0\\\\n                            size / 2 * (1 + Math.sin(ga)), // y0\\\\n                            size / 2 * (1 + Math.cos(ga)), // x1\\\\n                            size / 2 * (1 - Math.sin(ga))  // y1\\\\n                        ];\\\\n\\\\n                    var lg = ctx.createLinearGradient.apply(ctx, gd);\\\\n\\\\n                    for (var i = 0; i < gr.length; i++) {\\\\n                        var color = gr[i],\\\\n                            pos = i / (gr.length - 1);\\\\n\\\\n                        if (\\\\\\\$.isArray(color)) {\\\\n                            pos = color[1];\\\\n                            color = color[0];\\\\n                        }\\\\n\\\\n                        lg.addColorStop(pos, color);\\\\n                    }\\\\n\\\\n                    this.arcFill = lg;\\\\n                }\\\\n            }\\\\n\\\\n            if (fill.image) {\\\\n                var img;\\\\n\\\\n                if (fill.image instanceof Image) {\\\\n                    img = fill.image;\\\\n                } else {\\\\n                    img = new Image();\\\\n                    img.src = fill.image;\\\\n                }\\\\n\\\\n                if (img.complete)\\\\n                    setImageFill();\\\\n                else\\\\n                    img.onload = setImageFill;\\\\n            }\\\\n\\\\n            function setImageFill() {\\\\n                var bg = \\\\\\\$('<canvas>')[0];\\\\n                bg.width = self.size;\\\\n                bg.height = self.size;\\\\n                bg.getContext('2d').drawImage(img, 0, 0, size, size);\\\\n                self.arcFill = self.ctx.createPattern(bg, 'no-repeat');\\\\n                self.drawFrame(self.lastFrameValue);\\\\n            }\\\\n        },\\\\n\\\\n        draw: function() {\\\\n            if (this.animation)\\\\n                this.drawAnimated(this.value);\\\\n            else\\\\n                this.drawFrame(this.value);\\\\n        },\\\\n\\\\n        /**\\\\n         * @protected\\\\n         * @param {number} v - Frame value\\\\n         */\\\\n        drawFrame: function(v) {\\\\n            this.lastFrameValue = v;\\\\n            this.ctx.clearRect(0, 0, this.size, this.size);\\\\n            this.drawEmptyArc(v);\\\\n            this.drawArc(v);\\\\n        },\\\\n\\\\n        /**\\\\n         * @protected\\\\n         * @param {number} v - Frame value\\\\n         */\\\\n        drawArc: function(v) {\\\\n            var ctx = this.ctx,\\\\n                r = this.radius,\\\\n                t = this.getThickness(),\\\\n                a = this.startAngle;\\\\n\\\\n            ctx.save();\\\\n            ctx.beginPath();\\\\n\\\\n            if (!this.reverse) {\\\\n                ctx.arc(r, r, r - t / 2, a, a + Math.PI * 2 * v);\\\\n            } else {\\\\n                ctx.arc(r, r, r - t / 2, a - Math.PI * 2 * v, a);\\\\n            }\\\\n\\\\n            ctx.lineWidth = t;\\\\n            ctx.lineCap = this.lineCap;\\\\n            ctx.strokeStyle = this.arcFill;\\\\n            ctx.stroke();\\\\n            ctx.restore();\\\\n        },\\\\n\\\\n        /**\\\\n         * @protected\\\\n         * @param {number} v - Frame value\\\\n         */\\\\n        drawEmptyArc: function(v) {\\\\n            var ctx = this.ctx,\\\\n                r = this.radius,\\\\n                t = this.getThickness(),\\\\n                a = this.startAngle;\\\\n\\\\n            if (v < 1) {\\\\n                ctx.save();\\\\n                ctx.beginPath();\\\\n\\\\n                if (v <= 0) {\\\\n                    ctx.arc(r, r, r - t / 2, 0, Math.PI * 2);\\\\n                } else {\\\\n                    if (!this.reverse) {\\\\n                        ctx.arc(r, r, r - t / 2, a + Math.PI * 2 * v, a);\\\\n                    } else {\\\\n                        ctx.arc(r, r, r - t / 2, a, a - Math.PI * 2 * v);\\\\n                    }\\\\n                }\\\\n\\\\n                ctx.lineWidth = t;\\\\n                ctx.strokeStyle = this.emptyFill;\\\\n                ctx.stroke();\\\\n                ctx.restore();\\\\n            }\\\\n        },\\\\n\\\\n        /**\\\\n         * @protected\\\\n         * @param {number} v - Value\\\\n         */\\\\n        drawAnimated: function(v) {\\\\n            var self = this,\\\\n                el = this.el,\\\\n                canvas = \\\\\\\$(this.canvas);\\\\n\\\\n            // stop previous animation before new \\\\\\\"start\\\\\\\" event is triggered\\\\n            canvas.stop(true, false);\\\\n            el.trigger('circle-animation-start');\\\\n\\\\n            canvas\\\\n                .css({ animationProgress: 0 })\\\\n                .animate({ animationProgress: 1 }, \\\\\\\$.extend({}, this.animation, {\\\\n                    step: function (animationProgress) {\\\\n                        var stepValue = self.animationStartValue * (1 - animationProgress) + v * animationProgress;\\\\n                        self.drawFrame(stepValue);\\\\n                        el.trigger('circle-animation-progress', [animationProgress, stepValue]);\\\\n                    }\\\\n                }))\\\\n                .promise()\\\\n                .always(function() {\\\\n                    // trigger on both successful & failure animation end\\\\n                    el.trigger('circle-animation-end');\\\\n                });\\\\n        },\\\\n\\\\n        /**\\\\n         * @protected\\\\n         * @returns {number}\\\\n         */\\\\n        getThickness: function() {\\\\n            return \\\\\\\$.isNumeric(this.thickness) ? this.thickness : this.size / 14;\\\\n        },\\\\n\\\\n        getValue: function() {\\\\n            return this.value;\\\\n        },\\\\n\\\\n        setValue: function(newValue) {\\\\n            if (this.animation)\\\\n                this.animationStartValue = this.lastFrameValue;\\\\n            this.value = newValue;\\\\n            this.draw();\\\\n        }\\\\n    };\\\\n\\\\n    //-------------------------------------------- Initiating jQuery plugin --------------------------------------------\\\\n    \\\\\\\$.circleProgress = {\\\\n        // Default options (you may override them)\\\\n        defaults: CircleProgress.prototype\\\\n    };\\\\n\\\\n    // ease-in-out-cubic\\\\n    \\\\\\\$.easing.circleProgressEasing = function(x, t, b, c, d) {\\\\n        if ((t /= d / 2) < 1)\\\\n            return c / 2 * t * t * t + b;\\\\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\\\\n    };\\\\n\\\\n    /**\\\\n     * Draw animated circular progress bar.\\\\n     *\\\\n     * Appends <canvas> to the element or updates already appended one.\\\\n     *\\\\n     * If animated, throws 3 events:\\\\n     *\\\\n     *   - circle-animation-start(jqEvent)\\\\n     *   - circle-animation-progress(jqEvent, animationProgress, stepValue) - multiple event;\\\\n     *                                                                        animationProgress: from 0.0 to 1.0;\\\\n     *                                                                        stepValue: from 0.0 to value\\\\n     *   - circle-animation-end(jqEvent)\\\\n     *\\\\n     * @param configOrCommand - Config object or command name\\\\n     *     Example: { value: 0.75, size: 50, animation: false };\\\\n     *     you may set any public property (see above);\\\\n     *     `animation` may be set to false;\\\\n     *     you may use .circleProgress('widget') to get the canvas\\\\n     *     you may use .circleProgress('value', newValue) to dynamically update the value\\\\n     *\\\\n     * @param commandArgument - Some commands (like 'value') may require an argument\\\\n     */\\\\n    \\\\\\\$.fn.circleProgress = function(configOrCommand, commandArgument) {\\\\n        var dataName = 'circle-progress',\\\\n            firstInstance = this.data(dataName);\\\\n\\\\n        if (configOrCommand == 'widget') {\\\\n            if (!firstInstance)\\\\n                throw Error('Calling \\\\\\\"widget\\\\\\\" method on not initialized instance is forbidden');\\\\n            return firstInstance.canvas;\\\\n        }\\\\n\\\\n        if (configOrCommand == 'value') {\\\\n            if (!firstInstance)\\\\n                throw Error('Calling \\\\\\\"value\\\\\\\" method on not initialized instance is forbidden');\\\\n            if (typeof commandArgument == 'undefined') {\\\\n                return firstInstance.getValue();\\\\n            } else {\\\\n                var newValue = arguments[1];\\\\n                return this.each(function() {\\\\n                    \\\\\\\$(this).data(dataName).setValue(newValue);\\\\n                });\\\\n            }\\\\n        }\\\\n\\\\n        return this.each(function() {\\\\n            var el = \\\\\\\$(this),\\\\n                instance = el.data(dataName),\\\\n                config = \\\\\\\$.isPlainObject(configOrCommand) ? configOrCommand : {};\\\\n\\\\n            if (instance) {\\\\n                instance.init(config);\\\\n            } else {\\\\n                var initialConfig = \\\\\\\$.extend({}, el.data());\\\\n                if (typeof initialConfig.fill == 'string')\\\\n                    initialConfig.fill = JSON.parse(initialConfig.fill);\\\\n                if (typeof initialConfig.animation == 'string')\\\\n                    initialConfig.animation = JSON.parse(initialConfig.animation);\\\\n                config = \\\\\\\$.extend(initialConfig, config);\\\\n                config.el = el;\\\\n                instance = new CircleProgress(config);\\\\n                el.data(dataName, instance);\\\\n            }\\\\n        });\\\\n    };\\\\n})(jQuery);\\\";\";\";}}");

?>