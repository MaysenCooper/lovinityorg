<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:3:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc766f81b590.63984067_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:1;a:5:{i:0;s:33:\"tcpfunc_58dc766f81c975.85595140_2\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}i:2;a:5:{i:0;s:33:\"tcpfunc_58dc766f81ca03.13185597_3\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:11:\"RGraph.line\";i:3;N;i:4;a:3:{s:33:\"tcpfunc_58dc766f81b590.63984067_1\";s:118999:\"\$tpl_funcs['tcpfunc_58dc766f81b590.63984067_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f81b590.63984067_1']=recall_named_function('58dc766f81bb86.19717455','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n\\\\n    /**\\\\n    * The line chart constructor\\\\n    * \\\\n    * @param object canvas The cxanvas object\\\\n    * @param array  ...    The lines to plot\\\\n    */\\\\n    RGraph.Line = function (conf)\\\\n    {\\\\n        /**\\\\n        * Allow for object config style\\\\n        */\\\\n        if (   typeof conf === 'object'\\\\n            && typeof conf.data === 'object'\\\\n            && typeof conf.id === 'string') {\\\\n\\\\n            var id                        = conf.id;\\\\n            var canvas                    = document.getElementById(id);\\\\n            var data                      = conf.data;\\\\n            var parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor)\\\\n        \\\\n        } else {\\\\n        \\\\n            var id     = conf;\\\\n            var canvas = document.getElementById(id);\\\\n            var data   = arguments[1];\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        this.id                 = id;\\\\n        this.canvas             = canvas;\\\\n        this.context            = this.canvas.getContext('2d');\\\\n        this.canvas.__object__  = this;\\\\n        this.type               = 'line';\\\\n        this.max                = 0;\\\\n        this.coords             = [];\\\\n        this.coords2            = [];\\\\n        this.coords.key         = [];\\\\n        this.coordsText         = [];\\\\n        this.coordsSpline       = [];\\\\n        this.coordsAxes         = {xaxis: [], yaxis: []};\\\\n        this.hasnegativevalues  = false;\\\\n        this.isRGraph           = true;\\\\n        this.uid                = RGraph.CreateUID();\\\\n        this.canvas.uid         = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();\\\\n        this.colorsParsed       = false;\\\\n        this.original_colors    = [];\\\\n        this.firstDraw          = true; // After the first draw this will be false\\\\n\\\\n\\\\n        /**\\\\n        * Compatibility with older browsers\\\\n        */\\\\n        //RGraph.OldBrowserCompat(this.context);\\\\n\\\\n\\\\n        // Various config type stuff\\\\n        this.properties =\\\\n        {\\\\n            'chart.background.barcolor1':   'rgba(0,0,0,0)',\\\\n            'chart.background.barcolor2':   'rgba(0,0,0,0)',\\\\n            'chart.background.grid':        1,\\\\n            'chart.background.grid.width':  1,\\\\n            'chart.background.grid.hsize':  25,\\\\n            'chart.background.grid.vsize':  25,\\\\n            'chart.background.grid.color':  '#ddd',\\\\n            'chart.background.grid.vlines': true,\\\\n            'chart.background.grid.hlines': true,\\\\n            'chart.background.grid.border': true,\\\\n            'chart.background.grid.autofit':           true,\\\\n            'chart.background.grid.autofit.align':     true,\\\\n            'chart.background.grid.autofit.numhlines': 5,\\\\n            'chart.background.grid.autofit.numvlines': null,\\\\n            'chart.background.grid.dashed': false,\\\\n            'chart.background.grid.dotted': false,\\\\n            'chart.background.hbars':       null,\\\\n            'chart.background.image':       null,\\\\n            'chart.background.image.stretch': true,\\\\n            'chart.background.image.x':     null,\\\\n            'chart.background.image.y':     null,\\\\n            'chart.background.image.w':     null,\\\\n            'chart.background.image.h':     null,\\\\n            'chart.background.image.align': null,\\\\n            'chart.background.color':       null,\\\\n            'chart.labels':                 null,\\\\n            'chart.labels.bold':            false,\\\\n            'chart.labels.color':           null,\\\\n            'chart.labels.ingraph':         null,\\\\n            'chart.labels.above':            false, // Working\\\\n            'chart.labels.above.size':       8, // Working\\\\n            'chart.labels.above.decimals':   null, // Working\\\\n            'chart.labels.above.color':      null,\\\\n            'chart.labels.above.background': 'white',\\\\n            'chart.labels.above.font':       null,\\\\n            'chart.labels.above.border':     true,\\\\n            'chart.labels.above.offsety':     5,\\\\n            'chart.labels.above.units.pre':  '',\\\\n            'chart.labels.above.units.post': '',\\\\n            'chart.labels.above.specific':   null,\\\\n            'chart.labels.offsetx':         0,\\\\n            'chart.labels.offsety':         0,\\\\n            'chart.xtickgap':               20,\\\\n            'chart.smallxticks':            3,\\\\n            'chart.largexticks':            5,\\\\n            'chart.ytickgap':               20,\\\\n            'chart.smallyticks':            3,\\\\n            'chart.largeyticks':            5,\\\\n            'chart.numyticks':              10,\\\\n            'chart.linewidth':              2.01,\\\\n            'chart.colors':                 ['red', '#0f0', '#00f', '#f0f', '#ff0', '#0ff','green','pink','blue','black'],\\\\n            'chart.hmargin':                0,\\\\n            'chart.tickmarks.dot.stroke':   'white',\\\\n            'chart.tickmarks.dot.fill':     null,\\\\n            'chart.tickmarks.dot.linewidth': 3,\\\\n            'chart.tickmarks':              'endcircle',\\\\n            'chart.tickmarks.linewidth':    null,\\\\n            'chart.tickmarks.image':        null,\\\\n            'chart.tickmarks.image.halign': 'center',\\\\n            'chart.tickmarks.image.valign': 'center',\\\\n            'chart.tickmarks.image.offsetx':0,\\\\n            'chart.tickmarks.image.offsety':0,\\\\n            'chart.ticksize':               3,\\\\n            'chart.gutter.left':            25,\\\\n            'chart.gutter.right':           25,\\\\n            'chart.gutter.top':             25,\\\\n            'chart.gutter.bottom':          30,\\\\n            'chart.tickdirection':          -1,\\\\n            'chart.yaxispoints':            5,\\\\n            'chart.fillstyle':              null,\\\\n            'chart.xaxispos':               'bottom',\\\\n            'chart.xaxispos.value':         0,\\\\n            'chart.yaxispos':               'left',\\\\n            'chart.xticks':                 null,\\\\n            'chart.text.size':              12,\\\\n            'chart.text.angle':             0,\\\\n            'chart.text.color':             'black',\\\\n            'chart.text.font':              'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.text.accessible':               true,\\\\n            'chart.text.accessible.overflow':      'visible',\\\\n            'chart.text.accessible.pointerevents': true,\\\\n            'chart.ymin':                   0,\\\\n            'chart.ymax':                   null,\\\\n            'chart.title':                  '',\\\\n            'chart.title.background':       null,\\\\n            'chart.title.hpos':             null,\\\\n            'chart.title.vpos':             null,\\\\n            'chart.title.bold':             true,\\\\n            'chart.title.font':             null,\\\\n            'chart.title.xaxis':            '',\\\\n            'chart.title.xaxis.bold':       true,\\\\n            'chart.title.xaxis.size':       null,\\\\n            'chart.title.xaxis.font':       null,\\\\n            'chart.title.xaxis.color':      null,\\\\n            'chart.title.yaxis':            '',\\\\n            'chart.title.yaxis.bold':       true,\\\\n            'chart.title.yaxis.size':       null,\\\\n            'chart.title.yaxis.font':       null,\\\\n            'chart.title.yaxis.color':      null,\\\\n            'chart.title.xaxis.pos':        null,\\\\n            'chart.title.yaxis.pos':        null,\\\\n            'chart.title.yaxis.x':          null,\\\\n            'chart.title.yaxis.y':          null,\\\\n            'chart.title.xaxis.x':          null,\\\\n            'chart.title.xaxis.y':          null,\\\\n            'chart.title.x':                null,\\\\n            'chart.title.y':                null,\\\\n            'chart.title.halign':           null,\\\\n            'chart.title.valign':           null,\\\\n            'chart.shadow':                 true,\\\\n            'chart.shadow.offsetx':         2,\\\\n            'chart.shadow.offsety':         2,\\\\n            'chart.shadow.blur':            3,\\\\n            'chart.shadow.color':           'rgba(128,128,128,0.5)',\\\\n            'chart.tooltips':               null,\\\\n            'chart.tooltips.hotspot.xonly': false,\\\\n            'chart.tooltips.hotspot.size':  5,\\\\n            'chart.tooltips.effect':        'fade',\\\\n            'chart.tooltips.css.class':     'RGraph_tooltip',\\\\n            'chart.tooltips.event':         'onmousemove',\\\\n            'chart.tooltips.highlight':     true,\\\\n            'chart.tooltips.coords.page':   false,\\\\n            'chart.highlight.style':        null,\\\\n            'chart.highlight.stroke':       'gray',\\\\n            'chart.highlight.fill':         'white',\\\\n            'chart.stepped':                false,\\\\n            'chart.key':                    null,\\\\n            'chart.key.background':         'white',\\\\n            'chart.key.position':           'graph',\\\\n            'chart.key.halign':             null,\\\\n            'chart.key.shadow':             false,\\\\n            'chart.key.shadow.color':       '#666',\\\\n            'chart.key.shadow.blur':        3,\\\\n            'chart.key.shadow.offsetx':     2,\\\\n            'chart.key.shadow.offsety':     2,\\\\n            'chart.key.position.gutter.boxed': false,\\\\n            'chart.key.position.x':         null,\\\\n            'chart.key.position.y':         null,\\\\n            'chart.key.color.shape':        'square',\\\\n            'chart.key.rounded':            true,\\\\n            'chart.key.linewidth':          1,\\\\n            'chart.key.colors':             null,\\\\n            'chart.key.interactive':        false,\\\\n            'chart.key.interactive.highlight.chart.stroke': 'rgba(255,0,0,0.3)',\\\\n            'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',\\\\n            'chart.key.text.color':         'black',\\\\n            'chart.contextmenu':            null,\\\\n            'chart.ylabels':                true,\\\\n            'chart.ylabels.count':          5,\\\\n            'chart.ylabels.inside':         false,\\\\n            'chart.ylabels.offsetx':        0,\\\\n            'chart.ylabels.offsety':        0,\\\\n            'chart.scale.invert':           false,\\\\n            'chart.xlabels.inside':         false,\\\\n            'chart.xlabels.inside.color':   'rgba(255,255,255,0.5)',\\\\n            'chart.noaxes':                 false,\\\\n            'chart.noyaxis':                false,\\\\n            'chart.noxaxis':                false,\\\\n            'chart.noendxtick':             false,\\\\n            'chart.noendytick':             false,\\\\n            'chart.units.post':             '',\\\\n            'chart.units.pre':              '',\\\\n            'chart.scale.zerostart':        true,\\\\n            'chart.scale.decimals':         null,\\\\n            'chart.scale.point':            '.',\\\\n            'chart.scale.thousand':         ',',\\\\n            'chart.crosshairs':             false,\\\\n            'chart.crosshairs.color':       '#333',\\\\n            'chart.crosshairs.hline':       true,\\\\n            'chart.crosshairs.vline':       true,\\\\n            'chart.annotatable':            false,\\\\n            'chart.annotate.color':         'black',\\\\n            'chart.axesontop':              false,\\\\n            'chart.filled':                 false,\\\\n            'chart.filled.range':           false,\\\\n            'chart.filled.range.threshold': null,\\\\n            'chart.filled.range.threshold.colors': ['red', 'green'],\\\\n            'chart.filled.accumulative':    true,\\\\n            'chart.variant':                null,\\\\n            'chart.axis.color':             'black',\\\\n            'chart.axis.linewidth':         1,\\\\n            'chart.numxticks':              (data && typeof(data[0]) == 'number' ? data.length - 1 : (typeof data[0] === 'object' && data[0] && typeof data[0][0] === 'number' ? data[0].length - 1 : 20)),\\\\n            'chart.numyticks':              10,\\\\n            'chart.zoom.factor':            1.5,\\\\n            'chart.zoom.fade.in':           true,\\\\n            'chart.zoom.fade.out':          true,\\\\n            'chart.zoom.hdir':              'right',\\\\n            'chart.zoom.vdir':              'down',\\\\n            'chart.zoom.frames':            25,\\\\n            'chart.zoom.delay':             16.666,\\\\n            'chart.zoom.shadow':            true,\\\\n            'chart.zoom.background':        true,\\\\n            'chart.zoom.action':            'zoom',\\\\n            'chart.backdrop':               false,\\\\n            'chart.backdrop.size':          30,\\\\n            'chart.backdrop.alpha':         0.2,\\\\n            'chart.resizable':              false,\\\\n            'chart.resize.handle.adjust':   [0,0],\\\\n            'chart.resize.handle.background': null,\\\\n            'chart.adjustable':             false,\\\\n            'chart.adjustable.only':        null,\\\\n            'chart.noredraw':               false,\\\\n            'chart.outofbounds':            false,\\\\n            'chart.outofbounds.clip':       false,\\\\n            'chart.chromefix':              true,\\\\n            'chart.animation.factor':       1,\\\\n            'chart.animation.unfold.x':     false,\\\\n            'chart.animation.unfold.y':     true,\\\\n            'chart.animation.unfold.initial': 2,\\\\n            'chart.animation.trace.clip':     1,\\\\n            'chart.curvy':                    false,\\\\n            'chart.line.visible':             [],\\\\n            'chart.events.click':             null,\\\\n            'chart.events.mousemove':         null,\\\\n            'chart.errorbars':              false,\\\\n            'chart.errorbars.color':        'black',\\\\n            'chart.errorbars.capped':        true,\\\\n            'chart.errorbars.capped.width':   12,\\\\n            'chart.errorbars.linewidth':     1,\\\\n            'chart.combinedchart.effect':     null,\\\\n            'chart.combinedchart.effect.options':  null,\\\\n            'chart.combinedchart.effect.callback': null,\\\\n            'chart.clearto':   'rgba(0,0,0,0)'\\\\n        }\\\\n\\\\n        /**\\\\n        * Change null arguments to empty arrays\\\\n        */\\\\n        for (var i=1; i<arguments.length; ++i) {\\\\n            if (typeof(arguments[i]) == 'null' || !arguments[i]) {\\\\n                arguments[i] = [];\\\\n            }\\\\n        }\\\\n\\\\n\\\\n        /**\\\\n        * Store the original data. This also allows for giving arguments as one big array.\\\\n        */\\\\n        this.original_data = [];\\\\n\\\\n        // This allows for the new object based configuration style\\\\n        if (typeof conf === 'object' && conf.data) {\\\\n            if (typeof conf.data[0] === 'number' || RGraph.isNull(conf.data[0])) {\\\\n\\\\n                this.original_data[0] = RGraph.arrayClone(conf.data);\\\\n\\\\n            //} else if (typeof conf.data[0] === 'object' && !RGraph.isNull(conf.data[0])) {\\\\n            } else {\\\\n\\\\n                for (var i=0; i<conf.data.length; ++i) {\\\\n                    this.original_data[i] = RGraph.arrayClone(conf.data[i]);\\\\n                }\\\\n            }\\\\n\\\\n        // Allow for the older configuration style\\\\n        } else {\\\\n            for (var i=1; i<arguments.length; ++i) {\\\\n                \\\\n                if (   arguments[1]\\\\n                    && typeof(arguments[1]) == 'object'\\\\n                    && arguments[1][0]\\\\n                    && typeof(arguments[1][0]) == 'object'\\\\n                    && arguments[1][0].length) {\\\\n    \\\\n                    var tmp = [];\\\\n    \\\\n                    for (var i=0; i<arguments[1].length; ++i) {\\\\n                        tmp[i] = RGraph.array_clone(arguments[1][i]);\\\\n                    }\\\\n    \\\\n                    for (var j=0; j<tmp.length; ++j) {\\\\n                        this.original_data[j] = RGraph.array_clone(tmp[j]);\\\\n                    }\\\\n    \\\\n                } else {\\\\n                    this.original_data[i - 1] = RGraph.array_clone(arguments[i]);\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n\\\\n        // Check for support\\\\n        if (!this.canvas) {\\\\n            alert('[LINE] Fatal error: no canvas support');\\\\n            return;\\\\n        }\\\\n        \\\\n        // Convert strings to numbers\\\\n        for (var i=0; i<this.original_data.length; ++i) {\\\\n            for (var j=0; j<this.original_data[i].length; ++j) {\\\\n                if (typeof this.original_data[i][j] === 'string') {\\\\n                    this.original_data[i][j] = parseFloat(this.original_data[i][j]);\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        \\\\n        /**\\\\n        * Store the data here as one big array\\\\n        */\\\\n        this.data_arr = RGraph.arrayLinearize(this.original_data);\\\\n\\\\n        for (var i=0; i<this.data_arr.length; ++i) {\\\\n            this['\\\\\\\$' + i] = {};\\\\n        }\\\\n\\\\n\\\\n        /**\\\\n        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\\\\n        * done already\\\\n        */\\\\n        if (!this.canvas.__rgraph_aa_translated__) {\\\\n            this.context.translate(0.5,0.5);\\\\n            \\\\n            this.canvas.__rgraph_aa_translated__ = true;\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // Short variable names\\\\n        var RG   = RGraph,\\\\n            ca   = this.canvas,\\\\n            co   = ca.getContext('2d'),\\\\n            prop = this.properties,\\\\n            pa2  = RG.path2,\\\\n            win  = window,\\\\n            doc  = document,\\\\n            ma   = Math\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * \\\\\\\"Decorate\\\\\\\" the object with the generic effects if the effects library has been included\\\\n        */\\\\n        if (RG.Effects && typeof RG.Effects.decorate === 'function') {\\\\n            RG.Effects.decorate(this);\\\\n        }\\\\n        \\\\n\\\\n\\\\n\\\\n    \\\\n        /**\\\\n        * An all encompassing accessor\\\\n        * \\\\n        * @param string name The name of the property\\\\n        * @param mixed value The value of the property\\\\n        */\\\\n        this.set =\\\\n        this.Set = function (name)\\\\n        {\\\\n            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];\\\\n\\\\n            /**\\\\n            * the number of arguments is only one and it's an\\\\n            * object - parse it for configuration data and return.\\\\n            */\\\\n            if (arguments.length === 1 && typeof name === 'object') {\\\\n                RG.parseObjectStyleConfig(this, name);\\\\n                return this;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            /**\\\\n            * This should be done first - prepend the propertyy name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n\\\\n\\\\n\\\\n            // Consolidate the tooltips\\\\n            if (name == 'chart.tooltips' && typeof value == 'object' && value) {\\\\n    \\\\n                var tooltips = [];\\\\n    \\\\n                for (var i=1; i<arguments.length; i++) {\\\\n                    if (typeof(arguments[i]) == 'object' && arguments[i][0]) {\\\\n                        for (var j=0; j<arguments[i].length; j++) {\\\\n                            tooltips.push(arguments[i][j]);\\\\n                        }\\\\n    \\\\n                    } else if (typeof(arguments[i]) == 'function') {\\\\n                        tooltips = arguments[i];\\\\n    \\\\n                    } else {\\\\n                        tooltips.push(arguments[i]);\\\\n                    }\\\\n                }\\\\n    \\\\n                // Because \\\\\\\"value\\\\\\\" is used further down at the end of this function, set it to the expanded array os tooltips\\\\n                value = tooltips;\\\\n            }\\\\n    \\\\n            \\\\n            /**\\\\n            * If (buggy) Chrome and the linewidth is 1, change it to 1.01\\\\n            */\\\\n            if (name == 'chart.linewidth' && navigator.userAgent.match(/Chrome/)) {\\\\n                if (value == 1) {\\\\n                    value = 1.01;\\\\n                \\\\n                } else if (RGraph.is_array(value)) {\\\\n                    for (var i=0; i<value.length; ++i) {\\\\n                        if (typeof(value[i]) == 'number' && value[i] == 1) {\\\\n                            value[i] = 1.01;\\\\n                        }\\\\n                    }\\\\n                }\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * Check for xaxispos\\\\n            */\\\\n            if (name == 'chart.xaxispos' ) {\\\\n                if (value != 'bottom' && value != 'center' && value != 'top') {\\\\n                    alert('[LINE] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');\\\\n                    value = 'center';\\\\n                }\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * chart.xticks is now called chart.numxticks\\\\n            */\\\\n            if (name == 'chart.xticks') {\\\\n                name = 'chart.numxticks';\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * Change the new chart.spline option to chart.curvy\\\\n            */\\\\n            if (name == 'chart.spline') {\\\\n                name = 'chart.curvy';\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * Chnge chart.ylabels.invert to chart.scale.invert\\\\n            */\\\\n            if (name == 'chart.ylabels.invert') {\\\\n                name = 'chart.scale.invert';\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n    \\\\n            this.properties[name] = value;\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * An all encompassing accessor\\\\n        * \\\\n        * @param string name The name of the property\\\\n        */\\\\n        this.get =\\\\n        this.Get = function (name)\\\\n        {\\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n            \\\\n            /**\\\\n            * If requested property is chart.spline - change it to chart.curvy\\\\n            */\\\\n            if (name == 'chart.spline') {\\\\n                name = 'chart.curvy';\\\\n            }\\\\n    \\\\n            return prop[name];\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The function you call to draw the line chart\\\\n        * \\\\n        * @param bool An optional bool used internally to ditinguish whether the\\\\n        *             line chart is being called by the bar chart\\\\n        * \\\\n        * Draw()\\\\n        *  |\\\\n        *  +--Draw()\\\\n        *  |  |\\\\n        *  |  +-DrawLine()\\\\n        *  |\\\\n        *  +-RedrawLine()\\\\n        *     |\\\\n        *     +-DrawCurvyLine()\\\\n        *        |\\\\n        *        +-DrawSpline()\\\\n        */\\\\n        this.draw =\\\\n        this.Draw = function ()\\\\n        {\\\\n            // MUST be the first thing done!\\\\n            if (typeof(prop['chart.background.image']) == 'string') {\\\\n                RG.DrawBackgroundImage(this);\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * Fire the onbeforedraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'onbeforedraw');\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Parse the colors. This allows for simple gradient syntax\\\\n            */\\\\n            if (!this.colorsParsed) {\\\\n    \\\\n                this.parseColors();\\\\n    \\\\n                // Don't want to do this again\\\\n                this.colorsParsed = true;\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * This is new in May 2011 and facilitates indiviual gutter settings,\\\\n            * eg chart.gutter.left\\\\n            */\\\\n            this.gutterLeft   = prop['chart.gutter.left'];\\\\n            this.gutterRight  = prop['chart.gutter.right'];\\\\n            this.gutterTop    = prop['chart.gutter.top'];\\\\n            this.gutterBottom = prop['chart.gutter.bottom'];\\\\n    \\\\n    \\\\n            /**\\\\n            * Check for Chrome 6 and shadow\\\\n            * \\\\n            * TODO Remove once it's been fixed (for a while)\\\\n            * 07/03/2014 - Removed\\\\n            * 29/10/2011 - Looks like it's been fixed as long the linewidth is at least 1.01\\\\n            * SEARCH TAGS: CHROME FIX SHADOW BUG\\\\n            */\\\\n            //if (   prop['chart.shadow']\\\\n            //    && RG.ISCHROME\\\\n            //    && prop['chart.linewidth'] <= 1\\\\n            //    && prop['chart.chromefix']\\\\n            //    && prop['chart.shadow.blur'] > 0) {\\\\n            //        alert('[RGRAPH WARNING] Chrome has a shadow bug, meaning you should increase the linewidth to at least 1.01');\\\\n            //}\\\\n    \\\\n    \\\\n            // Reset the data back to that which was initially supplied\\\\n            this.data = RG.array_clone(this.original_data);\\\\n\\\\n    \\\\n            // Reset the max value\\\\n            this.max = 0;\\\\n    \\\\n            /**\\\\n            * Reverse the datasets so that the data and the labels tally\\\\n            *  COMMENTED OUT 15TH AUGUST 2011\\\\n            */\\\\n            //this.data = RG.array_reverse(this.data);\\\\n\\\\n            if (prop['chart.filled'] && !prop['chart.filled.range'] && this.data.length > 1 && prop['chart.filled.accumulative']) {\\\\n    \\\\n                var accumulation = [];\\\\n\\\\n                for (var set=0; set<this.data.length; ++set) {\\\\n                    for (var point=0; point<this.data[set].length; ++point) {\\\\n                        this.data[set][point] = Number(accumulation[point] ? accumulation[point] : 0) + this.data[set][point];\\\\n                        accumulation[point] = this.data[set][point];\\\\n                    }\\\\n                }\\\\n            }\\\\n    \\\\n            /**\\\\n            * Get the maximum Y scale value\\\\n            */\\\\n            if (prop['chart.ymax']) {\\\\n                \\\\n                this.max = prop['chart.ymax'];\\\\n                this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;\\\\n    \\\\n                this.scale2 = RG.getScale2(this, {\\\\n                    'max':this.max,\\\\n                    'min':prop['chart.ymin'],\\\\n                    'strict':true,\\\\n                    'scale.thousand':prop['chart.scale.thousand'],\\\\n                    'scale.point':prop['chart.scale.point'],\\\\n                    'scale.decimals':prop['chart.scale.decimals'],\\\\n                    'ylabels.count':prop['chart.ylabels.count'],\\\\n                    'scale.round':prop['chart.scale.round'],\\\\n                    'units.pre': prop['chart.units.pre'],\\\\n                    'units.post': prop['chart.units.post']\\\\n                });\\\\n\\\\n                this.max   = this.scale2.max ? this.scale2.max : 0;\\\\n    \\\\n                // Check for negative values\\\\n                if (!prop['chart.outofbounds']) {\\\\n                    for (dataset=0; dataset<this.data.length; ++dataset) {\\\\n                        if (RGraph.isArray(this.data[dataset])) {\\\\n                            for (var datapoint=0; datapoint<this.data[dataset].length; datapoint++) {\\\\n                                // Check for negative values\\\\n                                this.hasnegativevalues = (this.data[dataset][datapoint] < 0) || this.hasnegativevalues;\\\\n                            }\\\\n                        }\\\\n                    }\\\\n                }\\\\n    \\\\n            } else {\\\\n\\\\n                this.min = prop['chart.ymin'] ? prop['chart.ymin'] : 0;\\\\n    \\\\n                // Work out the max Y value\\\\n                for (dataset=0; dataset<this.data.length; ++dataset) {\\\\n                    for (var datapoint=0; datapoint<this.data[dataset].length; datapoint++) {\\\\n        \\\\n                        this.max = Math.max(this.max, this.data[dataset][datapoint] ? Math.abs(parseFloat(this.data[dataset][datapoint])) : 0);\\\\n        \\\\n                        // Check for negative values\\\\n                        if (!prop['chart.outofbounds']) {\\\\n                            this.hasnegativevalues = (this.data[dataset][datapoint] < 0) || this.hasnegativevalues;\\\\n                        }\\\\n                    }\\\\n                }\\\\n\\\\n                this.scale2 = RG.getScale2(this, {\\\\n                    'max':this.max,\\\\n                    'min':prop['chart.ymin'],\\\\n                    'scale.thousand':prop['chart.scale.thousand'],\\\\n                    'scale.point':prop['chart.scale.point'],\\\\n                    'scale.decimals':prop['chart.scale.decimals'],\\\\n                    'ylabels.count':prop['chart.ylabels.count'],\\\\n                    'scale.round':prop['chart.scale.round'],\\\\n                    'units.pre': prop['chart.units.pre'],\\\\n                    'units.post': prop['chart.units.post']\\\\n                });\\\\n    \\\\n                this.max   = this.scale2.max ? this.scale2.max : 0;\\\\n            }\\\\n    \\\\n            /**\\\\n            * Setup the context menu if required\\\\n            */\\\\n            if (prop['chart.contextmenu']) {\\\\n                RG.ShowContext(this);\\\\n            }\\\\n\\\\n            /**\\\\n            * Reset the coords arrays otherwise it will keep growing\\\\n            */\\\\n            this.coords     = [];\\\\n            this.coordsText = [];\\\\n\\\\n            /**\\\\n            * Work out a few things. They need to be here because they depend on things you can change before you\\\\n            * call Draw() but after you instantiate the object\\\\n            */\\\\n            this.grapharea      = ca.height - this.gutterTop - this.gutterBottom;\\\\n            this.halfgrapharea  = this.grapharea / 2;\\\\n            this.halfTextHeight = prop['chart.text.size'] / 2;\\\\n    \\\\n            // Check the combination of the X axis position and if there any negative values\\\\n            //\\\\n            // 25th Feb 2016 - Removed entirely as this is another way to do\\\\n            // offset axes\\\\n            //if (prop['chart.xaxispos'] == 'bottom' && this.hasnegativevalues && !RG.ISOPERA) {\\\\n            //    alert('[LINE] You have negative values and the X axis is at the bottom. This is not good...');\\\\n            //}\\\\n    \\\\n            if (prop['chart.variant'] == '3d') {\\\\n                RG.Draw3DAxes(this);\\\\n            }\\\\n            \\\\n            // Progressively Draw the chart\\\\n            RG.background.Draw(this);\\\\n\\\\n\\\\n            /**\\\\n            * Draw any horizontal bars that have been defined\\\\n            */\\\\n            if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {\\\\n                RG.DrawBars(this);\\\\n            }\\\\n\\\\n            if (prop['chart.axesontop'] == false) {\\\\n                this.DrawAxes();\\\\n            }\\\\n\\\\n            //if (typeof(shadowColor) == 'object') {\\\\n            //    shadowColor = RG.array_reverse(RG.array_clone(prop['chart.shadow.color']]);\\\\n            //}\\\\n    \\\\n            /**\\\\n            * This facilitates the new Trace2 effect\\\\n            */\\\\n    \\\\n            co.save()\\\\n            co.beginPath();\\\\n            co.rect(0, 0, ca.width * prop['chart.animation.trace.clip'], ca.height);\\\\n            co.clip();\\\\n    \\\\n                for (var i=0, j=0, len=this.data.length; i<len; i++, j++) {\\\\n        \\\\n                    co.beginPath();\\\\n        \\\\n                    /**\\\\n                    * Turn on the shadow if required\\\\n                    */\\\\n                    if (!prop['chart.filled']) {\\\\n                        this.SetShadow(i);\\\\n                    }\\\\n        \\\\n                    /**\\\\n                    * Draw the line\\\\n                    */\\\\n        \\\\n                    if (prop['chart.fillstyle']) {\\\\n                        if (typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'][j]) {\\\\n                           var fill = prop['chart.fillstyle'][j];\\\\n                        \\\\n                        } else if (typeof(prop['chart.fillstyle']) == 'object' && prop['chart.fillstyle'].toString().indexOf('Gradient') > 0) {\\\\n                           var fill = prop['chart.fillstyle'];\\\\n                        \\\\n                        } else if (typeof(prop['chart.fillstyle']) == 'string') {\\\\n                            var fill = prop['chart.fillstyle'];\\\\n            \\\\n                        }\\\\n                    } else if (prop['chart.filled']) {\\\\n                        var fill = prop['chart.colors'][j];\\\\n        \\\\n                    } else {\\\\n                        var fill = null;\\\\n                    }\\\\n\\\\n                    /**\\\\n                    * Figure out the tickmark to use\\\\n                    */\\\\n                    if (prop['chart.tickmarks'] && typeof(prop['chart.tickmarks']) == 'object') {\\\\n                        var tickmarks = prop['chart.tickmarks'][i];\\\\n                    } else if (prop['chart.tickmarks'] && typeof(prop['chart.tickmarks']) == 'string') {\\\\n                        var tickmarks = prop['chart.tickmarks'];\\\\n                    } else if (prop['chart.tickmarks'] && typeof(prop['chart.tickmarks']) == 'function') {\\\\n                        var tickmarks = prop['chart.tickmarks'];\\\\n                    } else {\\\\n                        var tickmarks = null;\\\\n                    }\\\\n\\\\n                    //\\\\n                    // Draw the line, accounting for the outofboundsClip option\\\\n                    //\\\\n                    if (prop['chart.outofbounds.clip']) {\\\\n                        pa2(\\\\n                            co,\\\\n                            'sa b r % % % % cl b',\\\\n                            0,\\\\n                            this.gutterTop,\\\\n                            ca.width,\\\\n                            ca.height - this.gutterTop - this.gutterBottom\\\\n                        );\\\\n                    }\\\\n\\\\n                        this.drawLine(\\\\n                            this.data[i],\\\\n                            prop['chart.colors'][j],\\\\n                            fill,\\\\n                            this.getLineWidth(j),\\\\n                            tickmarks,\\\\n                            i\\\\n                        );\\\\n                    if (prop['chart.outofbounds.clip']) {\\\\n                        co.restore();\\\\n                    }\\\\n            \\\\n                    co.stroke();\\\\n\\\\n/**\\\\n* Draw errorbars\\\\n* \\\\n* ** This is now done in the redrawLine function **\\\\n*/\\\\n                }\\\\n        \\\\n            /**\\\\n            * If the line is filled re-stroke the lines\\\\n            */\\\\n            if (prop['chart.filled'] && prop['chart.filled.accumulative'] && !prop['chart.curvy']) {\\\\n        \\\\n                for (var i=0; i<this.coords2.length; ++i) {\\\\n        \\\\n                    co.beginPath();\\\\n                    co.lineWidth = this.GetLineWidth(i);\\\\n                    co.strokeStyle = !this.hidden(i) ? prop['chart.colors'][i] : 'rgba(0,0,0,0)';\\\\n        \\\\n                    for (var j=0,len=this.coords2[i].length; j<len; ++j) {\\\\n        \\\\n                        if (j == 0 || this.coords2[i][j][1] == null || (this.coords2[i][j - 1] && this.coords2[i][j - 1][1] == null)) {\\\\n                            co.moveTo(this.coords2[i][j][0], this.coords2[i][j][1]);\\\\n                        } else {\\\\n                            if (prop['chart.stepped']) {\\\\n                                co.lineTo(this.coords2[i][j][0], this.coords2[i][j - 1][1]);\\\\n                            }\\\\n                            co.lineTo(this.coords2[i][j][0], this.coords2[i][j][1]);\\\\n                        }\\\\n                    }\\\\n                    \\\\n                    co.stroke();\\\\n                    // No fill!\\\\n                }\\\\n\\\\n                //Redraw the tickmarks\\\\n                if (prop['chart.tickmarks']) {\\\\n        \\\\n                    co.beginPath();\\\\n        \\\\n                    co.fillStyle = 'white';\\\\n                    \\\\n                    for (var i=0,len=this.coords2.length; i<len; ++i) {\\\\n        \\\\n                        co.beginPath();\\\\n                        co.strokeStyle = prop['chart.colors'][i];\\\\n    \\\\n                        for (var j=0; j<this.coords2[i].length; ++j) {\\\\n                            if (typeof(this.coords2[i][j]) == 'object' && typeof(this.coords2[i][j][0]) == 'number' && typeof(this.coords2[i][j][1]) == 'number') {\\\\n                                \\\\n                                var tickmarks = typeof(prop['chart.tickmarks']) == 'object' ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];\\\\n        \\\\n                                this.DrawTick(\\\\n                                    this.coords2[i],\\\\n                                    this.coords2[i][j][0],\\\\n                                    this.coords2[i][j][1],\\\\n                                    co.strokeStyle,\\\\n                                    false,\\\\n                                    j == 0 ? 0 : this.coords2[i][j - 1][0],\\\\n                                    j == 0 ? 0 : this.coords2[i][j - 1][1],\\\\n                                    tickmarks,\\\\n                                    j,\\\\n                                    i\\\\n                                );\\\\n                            }\\\\n                        }\\\\n                    }\\\\n        \\\\n                    co.stroke();\\\\n                    co.fill();\\\\n                }\\\\n\\\\n            } else if (prop['chart.filled'] && prop['chart.filled.accumulative'] && prop['chart.curvy']) {\\\\n\\\\n                // Restroke the curvy filled accumulative lines\\\\n\\\\n                for (var i=0; i<this.coordsSpline.length; i+=1) {\\\\n                    co.beginPath();\\\\n                    co.strokeStyle = prop['chart.colors'][i];\\\\n                    co.lineWidth = this.GetLineWidth(i);\\\\n\\\\n                    for (var j=0,len=this.coordsSpline[i].length; j<len; j+=1) {\\\\n                        \\\\n                        var point = this.coordsSpline[i][j];\\\\n                        \\\\n                        j == 0 ? co.moveTo(point[0], point[1]) : co.lineTo(point[0], point[1]);\\\\n                    }\\\\n\\\\n                   co.stroke();\\\\n                }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n                for (var i=0,len=this.coords2.length; i<len; i+=1) {\\\\n                    for (var j=0,len2=this.coords2[i].length; j<len2; ++j) {\\\\n                        if (typeof(this.coords2[i][j]) == 'object' && typeof(this.coords2[i][j][0]) == 'number' && typeof(this.coords2[i][j][1]) == 'number') {\\\\n                            \\\\n                            var tickmarks = typeof prop['chart.tickmarks'] == 'object' && !RGraph.is_null(prop['chart.tickmarks']) ? prop['chart.tickmarks'][i] : prop['chart.tickmarks'];\\\\n                            co.strokeStyle = prop['chart.colors'][i];\\\\n                            this.DrawTick(\\\\n                                this.coords2[i],\\\\n                                this.coords2[i][j][0],\\\\n                                this.coords2[i][j][1],\\\\n                                prop['chart.colors'][i],\\\\n                                false,\\\\n                                j == 0 ? 0 : this.coords2[i][j - 1][0],\\\\n                                j == 0 ? 0 : this.coords2[i][j - 1][1],\\\\n                                tickmarks,\\\\n                                j,\\\\n                                i\\\\n                            );\\\\n                        }\\\\n                    }\\\\n                }\\\\n\\\\n\\\\n\\\\n            }\\\\n        co.restore();\\\\n    \\\\n        // ???\\\\n        co.beginPath();\\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * If the axes have been requested to be on top, do that\\\\n            */\\\\n            if (prop['chart.axesontop']) {\\\\n                this.DrawAxes();\\\\n            }\\\\n    \\\\n            /**\\\\n            * Draw the labels\\\\n            */\\\\n            this.DrawLabels();\\\\n            \\\\n            /**\\\\n            * Draw the range if necessary\\\\n            */\\\\n            this.DrawRange();\\\\n\\\\n            // Draw a key if necessary\\\\n            if (prop['chart.key'] && prop['chart.key'].length && RG.DrawKey) {\\\\n                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\\\\n            }\\\\n    \\\\n            /**\\\\n            * Draw \\\\\\\" above\\\\\\\" labels if enabled\\\\n            */\\\\n            if (prop['chart.labels.above']) {\\\\n                this.drawAboveLabels();\\\\n            }\\\\n    \\\\n            /**\\\\n            * Draw the \\\\\\\"in graph\\\\\\\" labels\\\\n            */\\\\n            RG.DrawInGraphLabels(this);\\\\n\\\\n            /**\\\\n            * Redraw the lines if a filled range is on the cards\\\\n            */\\\\n            if (prop['chart.filled'] && prop['chart.filled.range'] && this.data.length == 2) {\\\\n    \\\\n                co.beginPath();\\\\n                var len        = this.coords.length / 2;\\\\n                co.lineWidth   = prop['chart.linewidth'];\\\\n                co.strokeStyle = this.hidden(0) ? 'rgba(0,0,0,0)' : prop['chart.colors'][0];\\\\n    \\\\n                for (var i=0; i<len; ++i) {\\\\n    \\\\n                    if (!RG.isNull(this.coords[i][1])) {\\\\n                        if (i == 0) {\\\\n                            co.moveTo(this.coords[i][0], this.coords[i][1]);\\\\n                        } else {\\\\n                            co.lineTo(this.coords[i][0], this.coords[i][1]);\\\\n                        }\\\\n                    }\\\\n                }\\\\n                \\\\n                co.stroke();\\\\n    \\\\n    \\\\n                co.beginPath();\\\\n                \\\\n                if (prop['chart.colors'][1]) {\\\\n                    co.strokeStyle = this.hidden(1) ? 'rgba(0,0,0,0)' : prop['chart.colors'][1];\\\\n                }\\\\n                \\\\n                for (var i=this.coords.length - 1; i>=len; --i) {\\\\n                    if (!RG.is_null(this.coords[i][1])) {\\\\n                        if (i == (this.coords.length - 1)) {\\\\n                            co.moveTo(this.coords[i][0], this.coords[i][1]);\\\\n                        } else {\\\\n                            co.lineTo(this.coords[i][0], this.coords[i][1]);\\\\n                        }\\\\n                    }\\\\n                }\\\\n    \\\\n                co.stroke();\\\\n    \\\\n    \\\\n            } else if (prop['chart.filled'] && prop['chart.filled.range']) {\\\\n                alert('[LINE] You must have only two sets of data for a filled range chart');\\\\n            }\\\\n\\\\n            /**\\\\n            * This function enables resizing\\\\n            */\\\\n            if (prop['chart.resizable']) {\\\\n                RG.AllowResizing(this);\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * This installs the event listeners\\\\n            */\\\\n            RG.InstallEventListeners(this);\\\\n            \\\\n            \\\\n\\\\n    \\\\n    \\\\n\\\\n            /**\\\\n            * Fire the onfirstdraw event\\\\n            */\\\\n            if (this.firstDraw) {\\\\n                RG.fireCustomEvent(this, 'onfirstdraw');\\\\n                this.firstDraw = false;\\\\n                this.firstDrawFunc();\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Fire the RGraph ondraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'ondraw');\\\\n            \\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * Used in chaining. Runs a function there and then - not waiting for\\\\n        * the events to fire (eg the onbeforedraw event)\\\\n        * \\\\n        * @param function func The function to execute\\\\n        */\\\\n        this.exec = function (func)\\\\n        {\\\\n            func(this);\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the axes\\\\n        */\\\\n        this.drawAxes =\\\\n        this.DrawAxes = function ()\\\\n        {\\\\n            // Don't draw the axes?\\\\n            if (prop['chart.noaxes']) {\\\\n                return;\\\\n            }\\\\n    \\\\n            // Turn any shadow off\\\\n            RG.noShadow(this);\\\\n    \\\\n            co.lineWidth   = prop['chart.axis.linewidth'] + 0.001;\\\\n            co.lineCap     = 'square';\\\\n            co.lineJoin    = 'miter';\\\\n            co.strokeStyle = prop['chart.axis.color'];\\\\n            coords         = {\\\\n                xaxis: {},\\\\n                yaxis: {}\\\\n            };\\\\n\\\\n            co.beginPath();\\\\n\\\\n            // Draw the X axis\\\\n            if (prop['chart.noxaxis'] == false) {\\\\n\\\\n                if (prop['chart.xaxispos'] == 'center') {\\\\n                    coords.xaxis = [\\\\n                        this.gutterLeft,\\\\n                        ma.round((this.grapharea / 2) + this.gutterTop),\\\\n                        ca.width - this.gutterRight,\\\\n                        ma.round((this.grapharea / 2) + this.gutterTop)\\\\n                    ];\\\\n                } else if (prop['chart.xaxispos'] === 'top') {\\\\n                    coords.xaxis = [\\\\n                        this.gutterLeft,\\\\n                        this.gutterTop,\\\\n                        ca.width - this.gutterRight,\\\\n                        this.gutterTop\\\\n                    ];\\\\n                } else {\\\\n\\\\n                    var y = ma.round(this.getYCoord(prop['chart.ymin'] != 0 ? prop['chart.ymin'] : 0));\\\\n                    \\\\n                    if (prop['chart.scale.invert'] && prop['chart.ymin'] === 0) {\\\\n                        y = this.getYCoord(this.scale2.max);\\\\n                    } else if (prop['chart.scale.invert'] || prop['chart.ymin'] < 0) {\\\\n                        y = this.getYCoord(0);\\\\n                    }\\\\n\\\\n                    coords.xaxis = [\\\\n                        this.gutterLeft,\\\\n                        y,\\\\n                        ca.width - this.gutterRight,\\\\n                        y\\\\n                    ];\\\\n                }\\\\n                \\\\n                co.moveTo(coords.xaxis[0], coords.xaxis[1]);\\\\n                co.lineTo(coords.xaxis[2], coords.xaxis[3]);\\\\n\\\\n                // Save the coords so that they can\\\\n                // be referenced at a later time\\\\n                this.coordsAxes = coords;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            // Draw the Y axis\\\\n            if (prop['chart.noyaxis'] == false) {\\\\n                if (prop['chart.yaxispos'] == 'left') {\\\\n                    co.moveTo(this.gutterLeft, this.gutterTop);\\\\n                    co.lineTo(this.gutterLeft, ca.height - this.gutterBottom);\\\\n                } else {\\\\n                    co.moveTo(ca.width - this.gutterRight, this.gutterTop);\\\\n                    co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\\\\n                }\\\\n            }\\\\n\\\\n            /**\\\\n            * Draw the X tickmarks\\\\n            */\\\\n            if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\\\\n\\\\n                var xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];\\\\n    \\\\n                \\\\n                if (!xTickInterval || xTickInterval <= 0) {\\\\n                    xTickInterval = (ca.width - this.gutterLeft - this.gutterRight) / (prop['chart.labels'] && prop['chart.labels'].length ? prop['chart.labels'].length - 1 : 10);\\\\n                }\\\\n\\\\n                for (x=this.gutterLeft + (prop['chart.yaxispos'] == 'left' ? xTickInterval : 0); x<=(ca.width - this.gutterRight + 1 ); x+=xTickInterval) {\\\\n    \\\\n                    if (prop['chart.yaxispos'] == 'right' && x >= (ca.width - this.gutterRight - 1) ) {\\\\n                        break;\\\\n                    }\\\\n\\\\n                    // If the last tick is not desired...\\\\n                    if (prop['chart.noendxtick']) {\\\\n                        if (prop['chart.yaxispos'] == 'left' && x >= (ca.width - this.gutterRight - 1)) {\\\\n                            break;\\\\n                        } else if (prop['chart.yaxispos'] == 'right' && x == this.gutterLeft) {\\\\n                            continue;\\\\n                        }\\\\n                    }\\\\n    \\\\n                    var yStart = prop['chart.xaxispos'] === 'center' ? (this.gutterTop + (this.grapharea / 2)) - 3 : ca.height - this.gutterBottom;\\\\n                    var yEnd   = prop['chart.xaxispos'] === 'center' ? yStart + 6 : ca.height - this.gutterBottom - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);\\\\n\\\\n\\\\n                    // Draw the tick\\\\n                    if (prop['chart.ymin'] >= 0 && prop['chart.xaxispos'] === 'bottom') {\\\\n                        var yStart = this.getYCoord(prop['chart.ymin']) - (prop['chart.ymin'] >= 0 ? 0 : 3),\\\\n                            yEnd   = this.getYCoord(prop['chart.ymin']) + 3;\\\\n\\\\n                        if (prop['chart.scale.invert']) {\\\\n                            yStart = ca.height - prop['chart.gutter.bottom'];\\\\n                            yEnd   = yStart + 3;\\\\n                        }\\\\n\\\\n                    } else if (prop['chart.xaxispos'] == 'center') {\\\\n                        var yStart = Math.round((this.gutterTop + (this.grapharea / 2))) - 3,\\\\n                            yEnd = yStart + 6;\\\\n                    \\\\n                    } else if (prop['chart.xaxispos'] == 'bottom') {\\\\n\\\\n                        var yStart = this.getYCoord(0) - (prop['chart.ymin'] !== 0 ? 3 : 0),\\\\n                            yEnd   = this.getYCoord(0) - (x % 60 == 0 ? prop['chart.largexticks'] * prop['chart.tickdirection'] : prop['chart.smallxticks'] * prop['chart.tickdirection']);\\\\n                        yEnd += 0;\\\\n\\\\n\\\\n\\\\n                    \\\\n                    } else if (prop['chart.xaxispos'] == 'top') {\\\\n\\\\n                        yStart = this.gutterTop - 3;\\\\n                        yEnd   = this.gutterTop;\\\\n                    }\\\\n\\\\n\\\\n                    co.moveTo(ma.round(x), yStart);\\\\n                    co.lineTo(ma.round(x), yEnd);\\\\n                }\\\\n    \\\\n            // Draw an extra tickmark if there is no X axis, but there IS a Y axis\\\\n            // OR if there is an offset X axis\\\\n            } else if (prop['chart.noyaxis'] == false && prop['chart.numyticks'] > 0) {\\\\n\\\\n                if (!prop['chart.noendytick']) {\\\\n                    if (prop['chart.yaxispos'] == 'left') {\\\\n                        co.moveTo(this.gutterLeft, Math.round(ca.height - this.gutterBottom));\\\\n                        co.lineTo(this.gutterLeft - prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\\\\n                    } else {\\\\n                        co.moveTo(ca.width - this.gutterRight, Math.round(ca.height - this.gutterBottom));\\\\n                        co.lineTo(ca.width - this.gutterRight + prop['chart.smallyticks'], Math.round(ca.height - this.gutterBottom));\\\\n                    }\\\\n                }\\\\n            }\\\\n    \\\\n            /**\\\\n            * Draw the Y tickmarks\\\\n            */\\\\n            var numyticks = prop['chart.numyticks'];\\\\n\\\\n            if (prop['chart.noyaxis'] == false && numyticks > 0) {\\\\n                \\\\n                var counter    = 0,\\\\n                    adjustment = 0;\\\\n        \\\\n                if (prop['chart.yaxispos'] == 'right') {\\\\n                    adjustment = (ca.width - this.gutterLeft - this.gutterRight);\\\\n                }\\\\n                \\\\n                // X axis at the center\\\\n                if (prop['chart.xaxispos'] == 'center') {\\\\n                    var interval = (this.grapharea / numyticks);\\\\n                    var lineto = (prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks']);\\\\n        \\\\n                    // Draw the upper halves Y tick marks\\\\n                    for (y=this.gutterTop; y<(this.grapharea / 2) + this.gutterTop; y+=interval) {\\\\n                        if (y < (this.grapharea / 2) + this.gutterTop) {\\\\n                            co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), Math.round(y));\\\\n                            co.lineTo(lineto, Math.round(y));\\\\n                        }\\\\n                    }\\\\n    \\\\n                    // Draw the lower halves Y tick marks\\\\n                    for (y=this.gutterTop + (this.halfgrapharea) + interval; y <= this.grapharea + this.gutterTop; y+=interval) {\\\\n                        co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), Math.round(y));\\\\n                        co.lineTo(lineto, Math.round(y));\\\\n                    }\\\\n                \\\\n                // X axis at the top\\\\n                } else if (prop['chart.xaxispos'] == 'top') {\\\\n                    var interval = (this.grapharea / numyticks);\\\\n                    var lineto = (prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight + prop['chart.smallyticks']);\\\\n    \\\\n                    // Draw the Y tick marks\\\\n                    for (y=this.gutterTop + interval; y <= this.grapharea + this.gutterBottom; y+=interval) {\\\\n                        co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), Math.round(y));\\\\n                        co.lineTo(lineto, Math.round(y));\\\\n                    }\\\\n\\\\n                    \\\\n                    // If there's no X axis draw an extra tick\\\\n                    if (prop['chart.noxaxis'] && prop['chart.noendytick'] == false) {\\\\n                        co.moveTo((prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight), this.gutterTop);\\\\n                        co.lineTo(lineto, this.gutterTop);\\\\n                    }\\\\n                \\\\n                // X axis at the bottom\\\\n                } else {\\\\n\\\\n                    var lineto = (prop['chart.yaxispos'] == 'left' ? this.gutterLeft - prop['chart.smallyticks'] : ca.width - this.gutterRight + prop['chart.smallyticks']);\\\\n\\\\n                    for (y=this.gutterTop;\\\\n                         y<(ca.height - this.gutterBottom) && counter < numyticks;\\\\n                         y+=( (ca.height - this.gutterTop - this.gutterBottom) / numyticks)\\\\n                        ) {\\\\n\\\\n                        // This check is so that there's no tickmark at\\\\n                        // the same position as the X axis\\\\n                        if (ma.round(y) !== ma.round(this.coordsAxes.xaxis[1])) {\\\\n                            co.moveTo(this.gutterLeft + adjustment, ma.round(y));\\\\n                            co.lineTo(lineto, ma.round(y));\\\\n                        }\\\\n                    \\\\n                        var counter = counter + 1;\\\\n                    }\\\\n                    \\\\n                    // Draw an extra Y tick if there's an offsetX axis\\\\n                    if (prop['chart.ymin'] < 0) {\\\\n\\\\n                        co.moveTo(\\\\n                            (prop['chart.yaxispos'] == 'left' ? this.gutterLeft : ca.width - this.gutterRight),\\\\n                            ma.round(y)\\\\n                        );\\\\n\\\\n                        co.lineTo(\\\\n                            lineto,\\\\n                            ma.round(y)\\\\n                        );\\\\n                    }\\\\n                }\\\\n    \\\\n            // Draw an extra X tickmark\\\\n            } else if (prop['chart.noxaxis'] == false && prop['chart.numxticks'] > 0) {\\\\n    \\\\n                if (prop['chart.yaxispos'] == 'left') {\\\\n                    co.moveTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop : ca.height - this.gutterBottom);\\\\n                    co.lineTo(this.gutterLeft, prop['chart.xaxispos'] == 'top' ? this.gutterTop - prop['chart.smallxticks'] : ca.height - this.gutterBottom + prop['chart.smallxticks']);\\\\n               } else {\\\\n                    co.moveTo(ca.width - this.gutterRight, ca.height - this.gutterBottom);\\\\n                    co.lineTo(ca.width - this.gutterRight, ca.height - this.gutterBottom + prop['chart.smallxticks']);\\\\n                }\\\\n            }\\\\n    \\\\n            co.stroke();\\\\n\\\\n            /**\\\\n            * This is here so that setting the color after this function doesn't\\\\n            * change the color of the axes\\\\n            */\\\\n            co.beginPath();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draw the text labels for the axes\\\\n        */\\\\n        this.drawLabels =\\\\n        this.DrawLabels = function ()\\\\n        {\\\\n            co.strokeStyle = 'black';\\\\n            co.fillStyle   = prop['chart.text.color'];\\\\n            co.lineWidth   = 1;\\\\n            \\\\n            // Turn off any shadow\\\\n            RG.NoShadow(this);\\\\n    \\\\n            // This needs to be here\\\\n            var font      = prop['chart.text.font'];\\\\n            var text_size = prop['chart.text.size'];\\\\n            var decimals  = prop['chart.scale.decimals'];\\\\n            var context   = co;\\\\n            var canvas    = ca;\\\\n            var ymin      = prop['chart.ymin'];\\\\n    \\\\n            // Draw the Y axis labels\\\\n            if (prop['chart.ylabels'] && prop['chart.ylabels.specific'] == null) {\\\\n    \\\\n                var units_pre  = prop['chart.units.pre'];\\\\n                var units_post = prop['chart.units.post'];\\\\n                var xpos       = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;\\\\n                var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';\\\\n                var numYLabels = this.scale2.labels.length;\\\\n                var bounding   = false;\\\\n                var bgcolor    = prop['chart.ylabels.inside'] ? prop['chart.ylabels.inside.color'] : null;\\\\n                var offsetx    = prop['chart.ylabels.offsetx'];\\\\n                var offsety    = prop['chart.ylabels.offsety'];\\\\n    \\\\n                \\\\n                /**\\\\n                * If the Y labels are inside the Y axis, invert the alignment\\\\n                */\\\\n                if (prop['chart.ylabels.inside'] == true && align == 'left') {\\\\n                    xpos -= 10;\\\\n                    align = 'right';\\\\n                    bounding = true;\\\\n                    \\\\n    \\\\n                } else if (prop['chart.ylabels.inside'] == true && align == 'right') {\\\\n                    xpos += 10;\\\\n                    align = 'left';\\\\n                    bounding = true;\\\\n                }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n                /**\\\\n                * X axis in the center\\\\n                */\\\\n                if (prop['chart.xaxispos'] == 'center') {\\\\n                    \\\\n                    var half = this.grapharea / 2;\\\\n    \\\\n                    /**\\\\n                    * Draw the top half \\\\n                    */\\\\n                    for (var i=0; i<this.scale2.labels.length; ++i) {\\\\n                        RG.text2(this, {\\\\n                            'font': font,\\\\n                            'size': text_size,\\\\n                            'x': xpos + offsetx,\\\\n                            'y': this.gutterTop + half - (((i+1)/numYLabels) * half) + offsety,\\\\n                            'valign': 'center',\\\\n                            'halign':align,\\\\n                            'bounding': bounding,\\\\n                            'boundingFill': bgcolor,\\\\n                            'text': this.scale2.labels[i],\\\\n                            'tag': 'scale'\\\\n                        });\\\\n                    }\\\\n                    \\\\n                    /**\\\\n                    * Draw the bottom half\\\\n                    */\\\\n                    for (var i=0; i<this.scale2.labels.length; ++i) {\\\\n                        RG.text2(this, {\\\\n                            'font': font,\\\\n                            'size': text_size,\\\\n                            'x': xpos + offsetx,\\\\n                            'y': this.gutterTop + half + (((i+1)/numYLabels) * half) + offsety,\\\\n                            'valign': 'center',\\\\n                            'halign':align,\\\\n                            'bounding': bounding,\\\\n                            'boundingFill': bgcolor,\\\\n                            'text': '-' + this.scale2.labels[i],\\\\n                            'tag': 'scale'\\\\n                        });\\\\n                    }\\\\n    \\\\n                    // No X axis - so draw 0\\\\n                    if (prop['chart.noxaxis'] == true || ymin != 0 || prop['chart.scale.zerostart']) {\\\\n                        RG.text2(this,{\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':xpos + offsetx,\\\\n                            'y':this.gutterTop + half + offsety,\\\\n                            'text':prop['chart.units.pre'] + ymin.toFixed(ymin === 0 ? 0 : decimals) + prop['chart.units.post'],\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'valign':'center',\\\\n                            'halign':align,\\\\n                            'tag': 'scale'\\\\n                        });\\\\n                    }\\\\n    \\\\n    \\\\n    \\\\n                /**\\\\n                * X axis at the top\\\\n                */\\\\n                } else if (prop['chart.xaxispos'] == 'top') {\\\\n                \\\\n                    var half = this.grapharea / 2;\\\\n    \\\\n                    if (prop['chart.scale.invert']) {\\\\n    \\\\n                        for (var i=0; i<this.scale2.labels.length; ++i) {\\\\n    \\\\n                            RG.text2(this, {\\\\n                                'font': font,\\\\n                                'size': text_size,\\\\n                                'x': xpos + offsetx,\\\\n                                'y': this.gutterTop + ((i/this.scale2.labels.length) * this.grapharea) + offsety,\\\\n                                'valign': 'center',\\\\n                                'halign':align,\\\\n                                'bounding': bounding,\\\\n                                'boundingFill': bgcolor,\\\\n                                'text': '-' + this.scale2.labels[this.scale2.labels.length - (i+1)],\\\\n                                'tag': 'scale'\\\\n                            });\\\\n                        }\\\\n                    } else {\\\\n                        for (var i=0; i<this.scale2.labels.length; ++i) {\\\\n                            RG.text2(this, {\\\\n                                'font': font,\\\\n                                'size': text_size,\\\\n                                'x': xpos + offsetx,\\\\n                                'y': this.gutterTop + (((i+1)/numYLabels) * this.grapharea) + offsety,\\\\n                                'valign': 'center',\\\\n                                'halign':align,\\\\n                                'bounding': bounding,\\\\n                                'boundingFill': bgcolor,\\\\n                                'text': '-' + this.scale2.labels[i],\\\\n                                'tag': 'scale'\\\\n                            });\\\\n                        }\\\\n                    }\\\\n\\\\n                    // Draw the lower limit if chart.ymin is specified\\\\n                    if ((prop['chart.ymin'] != 0 || prop['chart.noxaxis']) || prop['chart.scale.invert'] || prop['chart.scale.zerostart']) {\\\\n                        RG.text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':xpos + offsetx,\\\\n                            'y': prop['chart.scale.invert'] ? ca.height - this.gutterBottom + offsety : this.gutterTop + offsety,\\\\n                            'text': (prop['chart.ymin'] != 0 ? '-' : '') + RG.numberFormat(this, prop['chart.ymin'].toFixed(ymin === 0 ? 0 : decimals), units_pre, units_post),\\\\n                            'valign':'center',\\\\n                            'halign': align,\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'tag': 'scale'\\\\n                        });\\\\n                    }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n    \\\\n    \\\\n                /**\\\\n                * X axis labels at the bottom\\\\n                */\\\\n                } else {\\\\n    \\\\n                    if (prop['chart.scale.invert']) {\\\\n\\\\n                        // Draw the minimum value\\\\n                        RG.text2(this, {\\\\n                            'font': font,\\\\n                            'size': text_size,\\\\n                            'x': xpos + offsetx,\\\\n                            'y': this.gutterTop + offsety,\\\\n                            'valign': 'center',\\\\n                            'halign':align,\\\\n                            'bounding': bounding,\\\\n                            'boundingFill': bgcolor,\\\\n                            'text': RG.numberFormat(this, this.min.toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),\\\\n                            'tag': 'scale'\\\\n                        });\\\\n\\\\n                        for (var i=0,len=this.scale2.labels.length; i<len; ++i) {\\\\n                            RG.Text2(this, {\\\\n                                'font': font,\\\\n                                'size': text_size,\\\\n                                'x': xpos + offsetx,\\\\n                                'y': this.gutterTop + (((i+1)/this.scale2.labels.length) * this.grapharea) + offsety,\\\\n                                'valign': 'center',\\\\n                                'halign':align,\\\\n                                'bounding': bounding,\\\\n                                'boundingFill': bgcolor,\\\\n                                'text': this.scale2.labels[i],\\\\n                                'tag': 'scale'\\\\n                            });\\\\n                        }\\\\n\\\\n                    } else {\\\\n                        for (var i=0,len=this.scale2.labels.length; i<len; ++i) {\\\\n                            RG.text2(this, {\\\\n                                'font': font,\\\\n                                'size': text_size,\\\\n                                'x': xpos + offsetx,\\\\n                                'y': this.gutterTop + ((i/this.scale2.labels.length) * this.grapharea) + offsety,\\\\n                                'valign': 'center',\\\\n                                'halign':align,\\\\n                                'bounding': bounding,\\\\n                                'boundingFill': bgcolor,\\\\n                                'text': this.scale2.labels[this.scale2.labels.length - (i + 1)],\\\\n                                'tag': 'scale'\\\\n                            });\\\\n                        }\\\\n                    }\\\\n\\\\n                    // Draw the lower limit if chart.ymin is specified\\\\n                    if ( (prop['chart.ymin']!= 0 && !prop['chart.scale.invert'] || prop['chart.scale.zerostart'])\\\\n                        || prop['chart.noxaxis']\\\\n                        ) {\\\\n\\\\n                        RG.text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':xpos + offsetx,\\\\n                            'y':prop['chart.scale.invert'] ? this.gutterTop + offsety : ca.height - this.gutterBottom + offsety,\\\\n                            'text':RG.numberFormat(this, prop['chart.ymin'].toFixed(prop['chart.ymin'] === 0 ? 0 : prop['chart.scale.decimals']), units_pre, units_post),\\\\n                            'valign':'center',\\\\n                            'halign':align,\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'tag': 'scale'\\\\n                        });\\\\n\\\\n                    }\\\\n                }\\\\n\\\\n    \\\\n    \\\\n    \\\\n    \\\\n\\\\n    \\\\n                // No X axis - so draw 0 - but not if the X axis is in the center\\\\n                if (   prop['chart.noxaxis'] == true\\\\n                    && prop['chart.ymin'] == null\\\\n                    && prop['chart.xaxispos'] != 'center'\\\\n                    && prop['chart.noendytick'] == false\\\\n                   ) {\\\\n\\\\n                    RG.text2(this, {\\\\n                        'font':font,\\\\n                        'size':text_size,\\\\n                        'x':xpos + offsetx,\\\\n                        'y':prop['chart.xaxispos'] == 'top' ? this.gutterTop + offsety : (ca.height - this.gutterBottom),'text': prop['chart.units.pre'] + Number(0).toFixed(prop['chart.scale.decimals']) + prop['chart.units.post'] + offsety,\\\\n                        'valign':'center',\\\\n                        'halign':align,\\\\n                        'bounding':bounding,\\\\n                        'boundingFill':bgcolor,\\\\n                        'tag':'scale'\\\\n                    });\\\\n                }\\\\n\\\\n            } else if (prop['chart.ylabels'] && typeof(prop['chart.ylabels.specific']) == 'object') {\\\\n    \\\\n                // A few things\\\\n                var gap      = this.grapharea / prop['chart.ylabels.specific'].length;\\\\n                var halign   = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';\\\\n                var bounding = false;\\\\n                var bgcolor  = null;\\\\n                var ymin     = prop['chart.ymin'] != null && prop['chart.ymin'];\\\\n    \\\\n                // Figure out the X coord based on the position of the axis\\\\n                if (prop['chart.yaxispos'] == 'left') {\\\\n                    var x = this.gutterLeft - 5;\\\\n                    \\\\n                    if (prop['chart.ylabels.inside']) {\\\\n                        x += 10;\\\\n                        halign   = 'left';\\\\n                        bounding = true;\\\\n                        bgcolor  = 'rgba(255,255,255,0.5)';\\\\n                    }\\\\n    \\\\n                } else if (prop['chart.yaxispos'] == 'right') {\\\\n                    var x = ca.width - this.gutterRight + 5;\\\\n                    \\\\n                    if (prop['chart.ylabels.inside']) {\\\\n                        x -= 10;\\\\n                        halign = 'right';\\\\n                        bounding = true;\\\\n                        bgcolor  = 'rgba(255,255,255,0.5)';\\\\n                    }\\\\n                }\\\\n    \\\\n                var offsetx = prop['chart.ylabels.offsetx'];\\\\n                var offsety = prop['chart.ylabels.offsety'];\\\\n                \\\\n                // Draw the labels\\\\n                if (prop['chart.xaxispos'] == 'center') {\\\\n                \\\\n\\\\n                \\\\n                    // Draw the top halfs labels\\\\n                    for (var i=0; i<prop['chart.ylabels.specific'].length; ++i) {\\\\n                        \\\\n                        var y = this.gutterTop + (this.grapharea / (((prop['chart.ylabels.specific'].length - 1)) * 2) * i);\\\\n                        \\\\n                        if (ymin && ymin > 0) {\\\\n                            var y  = ((this.grapharea / 2) / (prop['chart.ylabels.specific'].length - (ymin ? 1 : 0)) ) * i;\\\\n                                y += this.gutterTop;\\\\n                        }\\\\n\\\\n                        RG.text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':x + offsetx,\\\\n                            'y':y + offsety,\\\\n                            'text':String(prop['chart.ylabels.specific'][i]),\\\\n                            'valign': 'center',\\\\n                            'halign':halign,\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'tag': 'ylabels.specific'\\\\n                        });\\\\n                    }\\\\n                    \\\\n                    // Now reverse the labels and draw the bottom half\\\\n                    var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);\\\\n                \\\\n                    // Draw the bottom halfs labels\\\\n                    for (var i=0; i<reversed_labels.length; ++i) {\\\\n                        \\\\n                        var y = (this.grapharea / 2) + this.gutterTop + ((this.grapharea / ((reversed_labels.length - 1) * 2) ) * i);\\\\n    \\\\n                        RG.text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':x + offsetx,\\\\n                            'y':y + offsety,\\\\n                            'text':i == 0 ? '' : String(reversed_labels[i]),\\\\n                            'valign': 'center',\\\\n                            'halign':halign,\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'tag': 'ylabels.specific'\\\\n                        });\\\\n                    }\\\\n                \\\\n                } else if (prop['chart.xaxispos'] == 'top') {\\\\n    \\\\n                    // Reverse the labels and draw\\\\n                    var reversed_labels = RG.array_reverse(prop['chart.ylabels.specific']);\\\\n                \\\\n                    // Draw the bottom halfs labels\\\\n                    for (var i=0; i<reversed_labels.length; ++i) {\\\\n                        \\\\n                        var y = (this.grapharea / (reversed_labels.length - 1)) * i;\\\\n                            y = y + this.gutterTop;\\\\n    \\\\n                        RG.Text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':x + offsetx,\\\\n                            'y':y + offsety,\\\\n                            'text':String(reversed_labels[i]),\\\\n                            'valign': 'center',\\\\n                            'halign':halign,\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'tag': 'ylabels.specific'\\\\n                        });\\\\n                    }\\\\n    \\\\n                } else {\\\\n                    for (var i=0; i<prop['chart.ylabels.specific'].length; ++i) {\\\\n                        var y = this.gutterTop + ((this.grapharea / (prop['chart.ylabels.specific'].length - 1)) * i);\\\\n                        RG.text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'x':x + offsetx,\\\\n                            'y':y + offsety,\\\\n                            'text':String(prop['chart.ylabels.specific'][i]),\\\\n                            'valign':'center',\\\\n                            'halign':halign,\\\\n                            'bounding':bounding,\\\\n                            'boundingFill':bgcolor,\\\\n                            'tag': 'ylabels.specific'\\\\n                        });\\\\n                    }\\\\n                }\\\\n            }\\\\n    \\\\n            // Draw the X axis labels\\\\n            if (prop['chart.labels'] && prop['chart.labels'].length > 0) {\\\\n\\\\n                var yOffset  = 5,\\\\n                    bordered = false,\\\\n                    bgcolor  = null\\\\n\\\\n                co.fillStyle = prop['chart.labels.color'] || prop['chart.text.color'];\\\\n\\\\n                /**\\\\n                * Text angle\\\\n                */\\\\n                var angle  = 0,\\\\n                    valign = 'top',\\\\n                    halign = 'center',\\\\n                    bold   = prop['chart.labels.bold']\\\\n    \\\\n                if (prop['chart.xlabels.inside']) {\\\\n                    yOffset  = -5;\\\\n                    bordered = true;\\\\n                    bgcolor  = prop['chart.xlabels.inside.color'];\\\\n                    valign   = 'bottom';\\\\n                }\\\\n                \\\\n                if (prop['chart.xaxispos'] == 'top') {\\\\n                    valign = 'bottom';\\\\n                    yOffset += 2;\\\\n                }\\\\n    \\\\n                if (typeof(prop['chart.text.angle']) == 'number' && prop['chart.text.angle'] > 0) {\\\\n                    angle   = -1 * prop['chart.text.angle'];\\\\n                    valign  = 'center';\\\\n                    halign  = 'right';\\\\n                    yOffset = 10;\\\\n                    \\\\n                    if (prop['chart.xaxispos'] == 'top') {\\\\n                        yOffset = 10;\\\\n                    }\\\\n                }\\\\n    \\\\n                var numLabels = prop['chart.labels'].length,\\\\n                    offsetx   = prop['chart.labels.offsetx'],\\\\n                    offsety   = prop['chart.labels.offsety'];\\\\n    \\\\n                for (i=0; i<numLabels; ++i) {\\\\n    \\\\n                    // Changed 8th Nov 2010 to be not reliant on the coords\\\\n                    //if (this.properties['chart.labels'][i] && this.coords && this.coords[i] && this.coords[i][0]) {\\\\n                    if (prop['chart.labels'][i]) {\\\\n    \\\\n                        var labelX = ((ca.width - this.gutterLeft - this.gutterRight - (2 * prop['chart.hmargin'])) / (numLabels - 1) ) * i;\\\\n                            labelX += this.gutterLeft + prop['chart.hmargin'];\\\\n\\\\n                        /**\\\\n                        * Account for an unrelated number of labels\\\\n                        */\\\\n\\\\n                        if (this.data.length === 0 || !this.data[0] || prop['chart.labels'].length != this.data[0].length) {\\\\n                            labelX = this.gutterLeft + prop['chart.hmargin'] + ((ca.width - this.gutterLeft - this.gutterRight - (2 * prop['chart.hmargin'])) * (i / (prop['chart.labels'].length - 1)));\\\\n                        }\\\\n                        \\\\n                        // This accounts for there only being one point on the chart\\\\n                        if (!labelX) {\\\\n                            labelX = this.gutterLeft + prop['chart.hmargin'];\\\\n                        }\\\\n    \\\\n                        if (prop['chart.xaxispos'] == 'top' && prop['chart.text.angle'] > 0) {\\\\n                            halign = 'left';\\\\n                        }\\\\n                        \\\\n                        if (prop['chart.text.angle'] != 0) {\\\\n                            halign = 'right';\\\\n                        }\\\\n    \\\\n                        RG.Text2(this, {\\\\n                            'font':font,\\\\n                            'size':text_size,\\\\n                            'bold': bold,\\\\n                            'x':labelX + offsetx,\\\\n                            'y':(prop['chart.xaxispos'] == 'top') ? this.gutterTop - yOffset - (prop['chart.xlabels.inside'] ? -22 : 0) + offsety : (ca.height - this.gutterBottom) + yOffset + offsety,\\\\n                            'text':String(prop['chart.labels'][i]),\\\\n                            'valign':valign,\\\\n                            'halign':halign,\\\\n                            'bounding':bordered,\\\\n                            'boundingFill':bgcolor,\\\\n                            'angle':angle,\\\\n                            'tag': 'labels'\\\\n                        });\\\\n                    }\\\\n                }\\\\n    \\\\n            }\\\\n    \\\\n            co.stroke();\\\\n            co.fill();\\\\n        }\\\\n    \\\\n    \\\\n    \\\\n        /**\\\\n        * Draws the line\\\\n        */\\\\n        this.drawLine =\\\\n        this.DrawLine = function (lineData, color, fill, linewidth, tickmarks, index)\\\\n        {\\\\n            // This facilitates the Rise animation (the Y value only)\\\\n            if (prop['chart.animation.unfold.y'] && prop['chart.animation.factor'] != 1) {\\\\n                for (var i=0; i<lineData.length; ++i) {\\\\n                    lineData[i] *= prop['chart.animation.factor'];\\\\n                }\\\\n            }\\\\n    \\\\n            var penUp = false;\\\\n            var yPos  = null;\\\\n            var xPos  = 0;\\\\n            co.lineWidth = 1;\\\\n            var lineCoords = [];\\\\n            \\\\n            /**\\\\n            * Get the previous line data\\\\n            */\\\\n            if (index > 0) {\\\\n                var prevLineCoords = this.coords2[index - 1];\\\\n            }\\\\n\\\\n\\\\n            // Work out the X interval\\\\n            var xInterval = (ca.width - (2 * prop['chart.hmargin']) - this.gutterLeft - this.gutterRight) / (lineData.length - 1);\\\\n    \\\\n            // Loop thru each value given, plotting the line\\\\n            // (FORMERLY FIRST)\\\\n            for (i=0,len=lineData.length; i<len; i+=1) {\\\\n\\\\n                var data_point = lineData[i];\\\\n    \\\\n                /**\\\\n                * Get the yPos for the given data point\\\\n                */\\\\n                var yPos = this.getYCoord(data_point);\\\\n\\\\n\\\\n                // Null data points, and a special case for this bug:http://dev.rgraph.net/tests/ymin.html\\\\n                if (   lineData[i] == null\\\\n                    || (prop['chart.xaxispos'] == 'bottom' && lineData[i] < this.min && !prop['chart.outofbounds'])\\\\n                    ||  (prop['chart.xaxispos'] == 'center' && lineData[i] < (-1 * this.max) && !prop['chart.outofbounds'])\\\\n                    || (((lineData[i] < this.min && prop['chart.xaxispos'] !== 'center') || lineData[i] > this.max) && !prop['chart.outofbounds'])) {\\\\n    \\\\n                    yPos = null;\\\\n                }\\\\n\\\\n                // Not always very noticeable, but it does have an effect\\\\n                // with thick lines\\\\n                co.lineCap  = 'round';\\\\n                co.lineJoin = 'round';\\\\n    \\\\n                // Plot the line if we're at least on the second iteration\\\\n                if (i > 0) {\\\\n                    xPos = xPos + xInterval;\\\\n                } else {\\\\n                    xPos = prop['chart.hmargin'] + this.gutterLeft;\\\\n                }\\\\n                \\\\n                if (prop['chart.animation.unfold.x']) {\\\\n                    xPos *= prop['chart.animation.factor'];\\\\n                    \\\\n                    if (xPos < prop['chart.gutter.left']) {\\\\n                        xPos = prop['chart.gutter.left'];\\\\n                    }\\\\n                }\\\\n    \\\\n                /**\\\\n                * Add the coords to an array\\\\n                */\\\\n                this.coords.push([xPos, yPos]);\\\\n                lineCoords.push([xPos, yPos]);\\\\n            }\\\\n\\\\n            co.stroke();\\\\n\\\\n            // Store the coords in another format, indexed by line number\\\\n            this.coords2[index] = lineCoords;\\\\n    \\\\n            /**\\\\n            * For IE only: Draw the shadow ourselves as ExCanvas doesn't produce shadows\\\\n            */\\\\n            if (RG.ISOLD && prop['chart.shadow']) {\\\\n                this.DrawIEShadow(lineCoords, co.shadowColor);\\\\n            }\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Now draw the actual line [FORMERLY SECOND]\\\\n            */\\\\n            co.beginPath();\\\\n            // Transparent now as of 11/19/2011\\\\n            co.strokeStyle = 'rgba(0,0,0,0)';\\\\n            //co.strokeStyle = fill;\\\\n            if (fill) {\\\\n                co.fillStyle   = fill;\\\\n            }\\\\n\\\\n            var isStepped = prop['chart.stepped'];\\\\n            var isFilled  = prop['chart.filled'];\\\\n            \\\\n            if (prop['chart.xaxispos'] == 'top') {\\\\n                var xAxisPos = this.gutterTop;\\\\n            } else if (prop['chart.xaxispos'] == 'center') {\\\\n                var xAxisPos = this.gutterTop + (this.grapharea / 2);\\\\n            } else if (prop['chart.xaxispos'] == 'bottom') {\\\\n                var xAxisPos = this.getYCoord(prop['chart.ymin'])\\\\n\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            for (var i=0,len=lineCoords.length; i<len; i+=1) {\\\\n    \\\\n                xPos = lineCoords[i][0];\\\\n                yPos = lineCoords[i][1];\\\\n                var set = index;\\\\n    \\\\n                var prevY     = (lineCoords[i - 1] ? lineCoords[i - 1][1] : null);\\\\n                var isLast    = (i + 1) == lineCoords.length;\\\\n    \\\\n                /**\\\\n                * This nullifys values which are out-of-range\\\\n                */\\\\n                if (!prop['chart.outofbounds'] && (prevY < this.gutterTop || prevY > (ca.height - this.gutterBottom) ) ) {\\\\n                    penUp = true;\\\\n                }\\\\n    \\\\n                if (i == 0 || penUp || !yPos || !prevY || prevY < this.gutterTop) {\\\\n\\\\n                    if (prop['chart.filled'] && !prop['chart.filled.range']) {\\\\n    \\\\n                        if (!prop['chart.outofbounds'] || prevY === null || yPos === null) {\\\\n                            co.moveTo(xPos + 1, xAxisPos);\\\\n                        }\\\\n\\\\n                        // This facilitates the X axis being at the top\\\\n                        // NOTE: Also done below\\\\n                        if (prop['chart.xaxispos'] == 'top') {\\\\n                            co.moveTo(xPos + 1, xAxisPos);\\\\n                        }\\\\n                        \\\\n                        if (isStepped && i > 0) {\\\\n                            co.lineTo(xPos, lineCoords[i - 1][1]);\\\\n                        }\\\\n    \\\\n                        co.lineTo(xPos, yPos);\\\\n    \\\\n                    } else {\\\\n    \\\\n                        if (RG.ISOLD && yPos == null) {\\\\n                            // Nada\\\\n                        } else {\\\\n                            co.moveTo(xPos + 1, yPos);\\\\n                        }\\\\n                    }\\\\n    \\\\n                    if (yPos == null) {\\\\n                        penUp = true;\\\\n    \\\\n                    } else {\\\\n                        penUp = false;\\\\n                    }\\\\n    \\\\n                } else {\\\\n    \\\\n                    // Draw the stepped part of stepped lines\\\\n                    if (isStepped) {\\\\n                        co.lineTo(xPos, lineCoords[i - 1][1]);\\\\n                    }\\\\n    \\\\n                    if ((yPos >= this.gutterTop && yPos <= (ca.height - this.gutterBottom)) || prop['chart.outofbounds'] ) {\\\\n    \\\\n                        if (isLast && prop['chart.filled'] && !prop['chart.filled.range'] && prop['chart.yaxispos'] == 'right') {\\\\n                            xPos -= 1;\\\\n                        }\\\\n    \\\\n    \\\\n                        // Added 8th September 2009\\\\n                        if (!isStepped || !isLast) {\\\\n                            co.lineTo(xPos, yPos);\\\\n                            \\\\n                            if (isFilled && lineCoords[i+1] && lineCoords[i+1][1] == null) {\\\\n                                co.lineTo(xPos, xAxisPos);\\\\n                            }\\\\n                        \\\\n                        // Added August 2010\\\\n                        } else if (isStepped && isLast) {\\\\n                            co.lineTo(xPos,yPos);\\\\n                        }\\\\n    \\\\n    \\\\n                        penUp = false;\\\\n                    } else {\\\\n                        penUp = true;\\\\n                    }\\\\n                }\\\\n            }\\\\n\\\\n            /**\\\\n            * Draw a line to the X axis if the chart is filled\\\\n            */\\\\n            if (prop['chart.filled'] && !prop['chart.filled.range'] && !prop['chart.curvy']) {\\\\n\\\\n                // Is this needed ??\\\\n                var fillStyle = prop['chart.fillstyle'];\\\\n\\\\n                /**\\\\n                * Draw the bottom edge of the filled bit using either the X axis or the prevlinedata,\\\\n                * depending on the index of the line. The first line uses the X axis, and subsequent\\\\n                * lines use the prevLineCoords array\\\\n                */\\\\n                if (index > 0 && prop['chart.filled.accumulative']) {\\\\n                    \\\\n                    co.lineTo(xPos, prevLineCoords ? prevLineCoords[i - 1][1] : (ca.height - this.gutterBottom - 1 + (prop['chart.xaxispos'] == 'center' ? (ca.height - this.gutterTop - this.gutterBottom) / 2 : 0)));\\\\n\\\\n                    for (var k=(i - 1); k>=0; --k) {\\\\n                        co.lineTo(k == 0 ? prevLineCoords[k][0] + 1: prevLineCoords[k][0], prevLineCoords[k][1]);\\\\n                    }\\\\n                } else {\\\\n\\\\n                    // Draw a line down to the X axis\\\\n                    if (prop['chart.xaxispos'] == 'top') {\\\\n                        co.lineTo(xPos, prop['chart.gutter.top'] +  1);\\\\n                        co.lineTo(lineCoords[0][0],prop['chart.gutter.top'] + 1);\\\\n                    } else if (typeof(lineCoords[i - 1][1]) == 'number') {\\\\n\\\\n                        // var yPosition = prop['chart.xaxispos'] == 'center' ? ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop : this.getYCoord(0);//ca.height - this.gutterBottom;\\\\n                        var yPosition = this.getYCoord(0);\\\\n\\\\n                        co.lineTo(xPos,yPosition);\\\\n                        co.lineTo(lineCoords[0][0],yPosition);\\\\n                    }\\\\n                }\\\\n    \\\\n                co.fillStyle = !this.hidden(index) ? fill : 'rgba(0,0,0,0)';\\\\n\\\\n                co.fill();\\\\n                co.beginPath();\\\\n\\\\n            }\\\\n    \\\\n            /**\\\\n            * FIXME this may need removing when Chrome is fixed\\\\n            * SEARCH TAGS: CHROME SHADOW BUG\\\\n            */\\\\n            //if (false && RGraph.ISCHROME && prop['chart.shadow'] && prop['chart.chromefix'] && prop['chart.shadow.blur'] > 0) {\\\\n            //\\\\n            //    for (var i=lineCoords.length - 1; i>=0; --i) {\\\\n            //        if (\\\\n            //               typeof(lineCoords[i][1]) != 'number'\\\\n            //            || (typeof(lineCoords[i+1]) == 'object' && typeof(lineCoords[i+1][1]) != 'number')\\\\n            //           ) {\\\\n            //            co.moveTo(lineCoords[i][0],lineCoords[i][1]);\\\\n            //        } else {\\\\n            //            co.lineTo(lineCoords[i][0],lineCoords[i][1]);\\\\n            //        }\\\\n            //    }\\\\n            //}\\\\n    \\\\n            co.stroke();\\\\n    \\\\n    \\\\n            if (prop['chart.backdrop']) {\\\\n                this.DrawBackdrop(lineCoords, color);\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * TODO CLIP TRACE\\\\n            * By using the clip() method the Trace animation can be updated.\\\\n            * NOTE: Needs to be done for the filled part as well\\\\n            */\\\\n            co.save();\\\\n                co.beginPath();\\\\n                co.rect(0,0,ca.width * prop['chart.animation.trace.clip'],ca.height);\\\\n                co.clip();\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n                //\\\\n                // Draw errorbars\\\\n                //\\\\n                if (typeof prop['chart.errorbars'] !== 'null') {\\\\n                    this.drawErrorbars();\\\\n                }\\\\n\\\\n\\\\n\\\\n\\\\n                // Now redraw the lines with the correct line width\\\\n                this.SetShadow(index);\\\\n                this.RedrawLine(lineCoords, color, linewidth, index);\\\\n                co.stroke();\\\\n                RG.NoShadow(this);\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            // Draw the tickmarks\\\\n                for (var i=0; i<lineCoords.length; ++i) {\\\\n        \\\\n                    i = Number(i);\\\\n                    \\\\n                    /**\\\\n                    * Set the color\\\\n                    */\\\\n                    co.strokeStyle = color;\\\\n                    \\\\n        \\\\n                    if (isStepped && i == (lineCoords.length - 1)) {\\\\n                        co.beginPath();\\\\n                        //continue;\\\\n                    }\\\\n        \\\\n                    if (\\\\n                        (\\\\n                            tickmarks != 'endcircle'\\\\n                         && tickmarks != 'endsquare'\\\\n                         && tickmarks != 'filledendsquare'\\\\n                         && tickmarks != 'endtick'\\\\n                         && tickmarks != 'endtriangle'\\\\n                         && tickmarks != 'arrow'\\\\n                         && tickmarks != 'filledarrow'\\\\n                        )\\\\n                        || (i == 0 && tickmarks != 'arrow' && tickmarks != 'filledarrow')\\\\n                        || i == (lineCoords.length - 1)\\\\n                       ) {\\\\n        \\\\n                        var prevX = (i <= 0 ? null : lineCoords[i - 1][0]);\\\\n                        var prevY = (i <= 0 ? null : lineCoords[i - 1][1]);\\\\n\\\\n                        this.DrawTick(\\\\n                            lineData,\\\\n                            lineCoords[i][0],\\\\n                            lineCoords[i][1],\\\\n                            color,\\\\n                            false,\\\\n                            prevX,\\\\n                            prevY,\\\\n                            tickmarks,\\\\n                            i,\\\\n                            index\\\\n                        );\\\\n        \\\\n                        // Draws tickmarks on the stepped bits of stepped charts. Takend out 14th July 2010\\\\n                        //\\\\n                        //if (this.properties['chart.stepped'] && lineCoords[i + 1] && this.properties['chart.tickmarks'] != 'endsquare' && this.properties['chart.tickmarks'] != 'endcircle' && this.properties['chart.tickmarks'] != 'endtick') {\\\\n                        //    this.DrawTick(lineCoords[i + 1][0], lineCoords[i][1], color);\\\\n                        //}\\\\n                    }\\\\n                }\\\\n            \\\\n            co.restore();\\\\n    \\\\n            // Draw something off canvas to skirt an annoying bug\\\\n            co.beginPath();\\\\n            co.arc(ca.width + 50000, ca.height + 50000, 2, 0, 6.38, 1);\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This functions draws a tick mark on the line\\\\n        */\\\\n        this.drawTick =\\\\n        this.DrawTick = function (lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index, dataset)\\\\n        {\\\\n            // Various conditions mean no tick\\\\n            if (this.hidden(dataset)) {\\\\n                return;\\\\n            } else if (RG.is_null(yPos)) {\\\\n                return false;\\\\n            } else if ((yPos > (ca.height - this.gutterBottom)) && !prop['chart.outofbounds']) {\\\\n                return;\\\\n             } else if ((yPos < this.gutterTop) && !prop['chart.outofbounds']) {\\\\n                return;\\\\n            }\\\\n\\\\n            co.beginPath();\\\\n    \\\\n            var offset   = 0;\\\\n    \\\\n            // Reset the stroke and lineWidth back to the same as what they were when the line was drawm\\\\n            // UPDATE 28th July 2011 - the line width is now set to 1\\\\n            co.lineWidth   = prop['chart.tickmarks.linewidth'] ? prop['chart.tickmarks.linewidth'] : prop['chart.linewidth'];\\\\n            co.strokeStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\\\\n            co.fillStyle   = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\\\\n    \\\\n            // Cicular tick marks\\\\n            if (   tickmarks == 'circle'\\\\n                || tickmarks == 'filledcircle'\\\\n                || tickmarks == 'endcircle') {\\\\n    \\\\n                if (tickmarks == 'circle'|| tickmarks == 'filledcircle' || (tickmarks == 'endcircle' && (index == 0 || index == (lineData.length - 1)))) {\\\\n                    co.beginPath();\\\\n                    co.arc(xPos + offset, yPos + offset, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false);\\\\n\\\\n                    if (tickmarks == 'filledcircle') {\\\\n                        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\\\\n                    } else {\\\\n                        co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';\\\\n                    }\\\\n    \\\\n                    co.stroke();\\\\n                    co.fill();\\\\n                }\\\\n    \\\\n            // Halfheight \\\\\\\"Line\\\\\\\" style tick marks\\\\n            } else if (tickmarks == 'halftick') {\\\\n                co.beginPath();\\\\n                co.moveTo(Math.round(xPos), yPos);\\\\n                co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);\\\\n    \\\\n                co.stroke();\\\\n            \\\\n            // Tick style tickmarks\\\\n            } else if (tickmarks == 'tick') {\\\\n                co.beginPath();\\\\n                co.moveTo(Math.round(xPos), yPos -  prop['chart.ticksize']);\\\\n                co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);\\\\n    \\\\n                co.stroke();\\\\n            \\\\n            // Endtick style tickmarks\\\\n            } else if (tickmarks == 'endtick' && (index == 0 || index == (lineData.length - 1))) {\\\\n                co.beginPath();\\\\n                co.moveTo(Math.round(xPos), yPos -  prop['chart.ticksize']);\\\\n                co.lineTo(Math.round(xPos), yPos + prop['chart.ticksize']);\\\\n    \\\\n                co.stroke();\\\\n            \\\\n            // \\\\\\\"Cross\\\\\\\" style tick marks\\\\n            } else if (tickmarks == 'cross') {\\\\n                co.beginPath();\\\\n                    \\\\n                    var ticksize = prop['chart.ticksize'];\\\\n                    \\\\n                    co.moveTo(xPos - ticksize, yPos - ticksize);\\\\n                    co.lineTo(xPos + ticksize, yPos + ticksize);\\\\n                    co.moveTo(xPos + ticksize, yPos - ticksize);\\\\n                    co.lineTo(xPos - ticksize, yPos + ticksize);\\\\n                co.stroke();\\\\n    \\\\n    \\\\n            // Triangle style tick marks\\\\n            } else if (tickmarks == 'triangle' || tickmarks == 'filledtriangle' || (tickmarks == 'endtriangle' && (index == 0 || index == (lineData.length - 1)))) {\\\\n                co.beginPath();\\\\n                    \\\\n                    if (tickmarks == 'filledtriangle') {\\\\n                        co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\\\\n                    } else {\\\\n                        co.fillStyle = 'white';\\\\n                    }\\\\n    \\\\n                    co.moveTo(ma.round(xPos - prop['chart.ticksize']), yPos + prop['chart.ticksize']);\\\\n                    co.lineTo(ma.round(xPos), yPos - prop['chart.ticksize']);\\\\n                    co.lineTo(ma.round(xPos + prop['chart.ticksize']), yPos + prop['chart.ticksize']);\\\\n                co.closePath();\\\\n                \\\\n                co.stroke();\\\\n                co.fill();\\\\n    \\\\n    \\\\n            // \\\\n            // A white bordered circle\\\\n            //\\\\n            } else if (tickmarks == 'borderedcircle' || tickmarks == 'dot') {\\\\n                    \\\\n                    co.lineWidth   = prop['chart.tickmarks.dot.linewidth'] || 0.00000001;\\\\n\\\\n                    pa2(co, [\\\\n                        'b',\\\\n                        'a',xPos, yPos, prop['chart.ticksize'], 0, 360 / (180 / RG.PI), false,\\\\n                        'c',\\\\n                        'f',prop['chart.tickmarks.dot.fill'] || color,\\\\n                        's',prop['chart.tickmarks.dot.stroke'] || color\\\\n                    ]);\\\\n            \\\\n            } else if (   tickmarks == 'square'\\\\n                       || tickmarks == 'filledsquare'\\\\n                       || (tickmarks == 'endsquare' && (index == 0 || index == (lineData.length - 1)))\\\\n                       || (tickmarks == 'filledendsquare' && (index == 0 || index == (lineData.length - 1))) ) {\\\\n    \\\\n                co.fillStyle   = 'white';\\\\n                co.strokeStyle = co.strokeStyle;\\\\n    \\\\n                co.beginPath();\\\\n                co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);\\\\n    \\\\n                // Fillrect\\\\n                if (tickmarks == 'filledsquare' || tickmarks == 'filledendsquare') {\\\\n                    co.fillStyle = isShadow ? prop['chart.shadow.color'] : co.strokeStyle;\\\\n                    co.rect(Math.round(xPos - prop['chart.ticksize']), Math.round(yPos - prop['chart.ticksize']), prop['chart.ticksize'] * 2, prop['chart.ticksize'] * 2);\\\\n    \\\\n                } else if (tickmarks == 'square' || tickmarks == 'endsquare') {\\\\n                    co.fillStyle = isShadow ? prop['chart.shadow.color'] : 'white';\\\\n                    co.rect(Math.round((xPos - prop['chart.ticksize']) + 1), Math.round((yPos - prop['chart.ticksize']) + 1), (prop['chart.ticksize'] * 2) - 2, (prop['chart.ticksize'] * 2) - 2);\\\\n                }\\\\n    \\\\n                co.stroke();\\\\n                co.fill();\\\\n    \\\\n            /**\\\\n            * FILLED arrowhead\\\\n            */\\\\n            } else if (tickmarks == 'filledarrow') {\\\\n            \\\\n                var x = Math.abs(xPos - prevX);\\\\n                var y = Math.abs(yPos - prevY);\\\\n    \\\\n                if (yPos < prevY) {\\\\n                    var a = Math.atan(x / y) + 1.57;\\\\n                } else {\\\\n                    var a = Math.atan(y / x) + 3.14;\\\\n                }\\\\n    \\\\n                co.beginPath();\\\\n                    co.moveTo(Math.round(xPos), Math.round(yPos));\\\\n                    co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5, a + 0.5, false);\\\\n                co.closePath();\\\\n    \\\\n                co.stroke();\\\\n                co.fill();\\\\n    \\\\n            /**\\\\n            * Arrow head, NOT filled\\\\n            */\\\\n            } else if (tickmarks == 'arrow') {\\\\n            \\\\n                var orig_linewidth = co.lineWidth;\\\\n    \\\\n                var x = Math.abs(xPos - prevX);\\\\n                var y = Math.abs(yPos - prevY);\\\\n                \\\\n                co.lineWidth;\\\\n    \\\\n                if (yPos < prevY) {\\\\n                    var a = Math.atan(x / y) + 1.57;\\\\n                } else {\\\\n                    var a = Math.atan(y / x) + 3.14;\\\\n                }\\\\n    \\\\n                co.beginPath();\\\\n                    co.moveTo(Math.round(xPos), Math.round(yPos));\\\\n                    co.arc(Math.round(xPos), Math.round(yPos), 7, a - 0.5 - (doc.all ? 0.1 : 0.01), a - 0.4, false);\\\\n    \\\\n                    co.moveTo(Math.round(xPos), Math.round(yPos));\\\\n                    co.arc(Math.round(xPos), Math.round(yPos), 7, a + 0.5 + (doc.all ? 0.1 : 0.01), a + 0.5, true);\\\\n                co.stroke();\\\\n                co.fill();\\\\n\\\\n                // Revert to original lineWidth\\\\n                co.lineWidth = orig_linewidth;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Image based tickmark\\\\n            */\\\\n            // lineData, xPos, yPos, color, isShadow, prevX, prevY, tickmarks, index\\\\n            } else if (\\\\n                       typeof tickmarks === 'string' &&\\\\n                           (\\\\n                            tickmarks.substr(0, 6) === 'image:'  ||\\\\n                            tickmarks.substr(0, 5) === 'data:'   ||\\\\n                            tickmarks.substr(0, 1) === '/'       ||\\\\n                            tickmarks.substr(0, 3) === '../'     ||\\\\n                            tickmarks.substr(0, 7) === 'images/'\\\\n                           )\\\\n                      ) {\\\\n\\\\n                var img = new Image();\\\\n                \\\\n                if (tickmarks.substr(0, 6) === 'image:') {\\\\n                    img.src = tickmarks.substr(6);\\\\n                } else {\\\\n                    img.src = tickmarks;\\\\n                }\\\\n\\\\n\\\\n                img.onload = function ()\\\\n                {\\\\n                    if (prop['chart.tickmarks.image.halign'] === 'center') xPos -= (this.width / 2);\\\\n                    if (prop['chart.tickmarks.image.halign'] === 'right')  xPos -= this.width;\\\\n                    \\\\n                    if (prop['chart.tickmarks.image.valign'] === 'center') yPos -= (this.height / 2);\\\\n                    if (prop['chart.tickmarks.image.valign'] === 'bottom') yPos -= this.height;\\\\n                    \\\\n                    xPos += prop['chart.tickmarks.image.offsetx'];\\\\n                    yPos += prop['chart.tickmarks.image.offsety'];\\\\n\\\\n                    co.drawImage(this, xPos, yPos);\\\\n                };\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Custom tick drawing function\\\\n            */\\\\n            } else if (typeof(tickmarks) == 'function') {\\\\n                tickmarks(this, lineData, lineData[index], index, xPos, yPos, color, prevX, prevY);\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws a filled range if necessary\\\\n        */\\\\n        this.drawRange =\\\\n        this.DrawRange = function ()\\\\n        {\\\\n            /**\\\\n            * Fill the range if necessary\\\\n            */\\\\n            if (prop['chart.filled.range'] && prop['chart.filled']) {\\\\n            \\\\n                if (RG.isNull(prop['chart.filled.range.threshold'])) {\\\\n                    prop['chart.filled.range.threshold']        = this.ymin\\\\n                    prop['chart.filled.range.threshold.colors'] = [prop['chart.fillstyle'], prop['chart.fillstyle']]\\\\n                }\\\\n    \\\\n                for (var idx=0; idx<2; ++idx) {\\\\n    \\\\n                    var threshold_colors = prop['chart.filled.range.threshold.colors'];\\\\n                    var y = this.getYCoord(prop['chart.filled.range.threshold'])\\\\n                    \\\\n                    co.save();\\\\n                        if (idx == 0) {\\\\n                            co.beginPath();\\\\n                            co.rect(0,0,ca.width,y);\\\\n                            co.clip();\\\\n                        \\\\n                        } else {\\\\n    \\\\n                            co.beginPath();\\\\n                            co.rect(0,y,ca.width, ca.height);\\\\n                            co.clip();\\\\n                        }\\\\n    \\\\n                        co.beginPath();\\\\n                            co.fillStyle = (idx == 1 ? prop['chart.filled.range.threshold.colors'][1] : prop['chart.filled.range.threshold.colors'][0]);\\\\n                        \\\\n                            //co.strokeStyle = prop['chart.fillstyle']; // Strokestyle not used now (10th October 2012)\\\\n                            \\\\n                            co.lineWidth = !this.hidden(idx) ? 1 : 0;\\\\n                            var len = (this.coords.length / 2);\\\\n                \\\\n                            \\\\n                            \\\\n                            for (var i=0; i<len; ++i) {\\\\n                                if (!RG.is_null(this.coords[i][1])) {\\\\n                                    if (i == 0) {\\\\n                                        co.moveTo(this.coords[i][0], this.coords[i][1])\\\\n                                    } else {\\\\n                                        co.lineTo(this.coords[i][0], this.coords[i][1])\\\\n                                    }\\\\n                                }\\\\n                            }\\\\n    \\\\n    \\\\n                            for (var i=this.coords.length - 1; i>=len; --i) {\\\\n                                if (RG.is_null(this.coords[i][1])) {\\\\n                                    co.moveTo(this.coords[i][0], this.coords[i][1])\\\\n                                } else {\\\\n                                    co.lineTo(this.coords[i][0], this.coords[i][1])\\\\n                                }\\\\n                                //co.lineTo(this.coords[i][0], this.coords[i][1])\\\\n                            }\\\\n    \\\\n    \\\\n    \\\\n                        // Taken out - 10th Oct 2012\\\\n                        //co.stroke();\\\\n            \\\\n                        co.fill();\\\\n                    co.restore();\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Redraws the line with the correct line width etc\\\\n        * \\\\n        * @param array coords The coordinates of the line\\\\n        */\\\\n        this.redrawLine =\\\\n        this.RedrawLine = function (coords, color, linewidth, index)\\\\n        {\\\\n\\\\n            if (prop['chart.noredraw'] || prop['chart.filled.range']) {\\\\n                return;\\\\n            }\\\\n    \\\\n            co.strokeStyle = (typeof(color) == 'object' && color && color.toString().indexOf('CanvasGradient') == -1 ? color[0] : color);\\\\n            co.lineWidth = linewidth;\\\\n    \\\\n            if (this.hidden(index)) {\\\\n                co.strokeStyle = 'rgba(0,0,0,0)';\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            if (!RG.ISOLD && (prop['chart.curvy'] || prop['chart.spline'])) {\\\\n                this.DrawCurvyLine(coords, this.hidden(index) ? 'rgba(0,0,0,0)' : color, linewidth, index);\\\\n                return;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            co.beginPath();\\\\n    \\\\n            var len    = coords.length;\\\\n            var width  = ca.width\\\\n            var height = ca.height;\\\\n            var penUp  = false;\\\\n    \\\\n            for (var i=0; i<len; ++i) {\\\\n    \\\\n                var xPos   = coords[i][0];\\\\n                var yPos   = coords[i][1];\\\\n    \\\\n                if (i > 0) {\\\\n                    var prevX = coords[i - 1][0];\\\\n                    var prevY = coords[i - 1][1];\\\\n                }\\\\n    \\\\n    \\\\n                if ((\\\\n                       (i == 0 && coords[i])\\\\n                    || (yPos < this.gutterTop)\\\\n                    || (prevY < this.gutterTop)\\\\n                    || (yPos > (height - this.gutterBottom))\\\\n                    || (i > 0 && prevX > (width - this.gutterRight))\\\\n                    || (i > 0 && prevY > (height - this.gutterBottom))\\\\n                    || prevY == null\\\\n                    || penUp == true\\\\n                   ) && (!prop['chart.outofbounds'] || yPos == null || prevY == null) ) {\\\\n\\\\n                    if (RG.ISOLD && yPos == null) {\\\\n                        // ...?\\\\n                    } else {\\\\n                        co.moveTo(coords[i][0], coords[i][1]);\\\\n                    }\\\\n    \\\\n                    penUp = false;\\\\n    \\\\n                } else {\\\\n    \\\\n                    if (prop['chart.stepped'] && i > 0) {\\\\n                        co.lineTo(coords[i][0], coords[i - 1][1]);\\\\n                    }\\\\n                    \\\\n                    // Don't draw the last bit of a stepped chart. Now DO\\\\n                    //if (!this.properties['chart.stepped'] || i < (coords.length - 1)) {\\\\n                    co.lineTo(coords[i][0], coords[i][1]);\\\\n                    //}\\\\n                    penUp = false;\\\\n                }\\\\n            }\\\\n    \\\\n            /**\\\\n            * If two colors are specified instead of one, go over the up bits\\\\n            */\\\\n            if (prop['chart.colors.alternate'] && typeof(color) == 'object' && color[0] && color[1]) {\\\\n                for (var i=1; i<len; ++i) {\\\\n    \\\\n                    var prevX = coords[i - 1][0];\\\\n                    var prevY = coords[i - 1][1];\\\\n                    \\\\n                    if (prevY != null && coords[i][1] != null) {\\\\n                        co.beginPath();\\\\n                            co.strokeStyle = color[coords[i][1] < prevY ? 0 : 1];\\\\n                            co.lineWidth = prop['chart.linewidth'];\\\\n                            co.moveTo(prevX, prevY);\\\\n                            co.lineTo(coords[i][0], coords[i][1]);\\\\n                        co.stroke();\\\\n                    }\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function is used by MSIE only to manually draw the shadow\\\\n        * \\\\n        * @param array coords The coords for the line\\\\n        */\\\\n        this.drawIEShadow =\\\\n        this.DrawIEShadow = function (coords, color)\\\\n        {\\\\n            var offsetx = prop['chart.shadow.offsetx'];\\\\n            var offsety = prop['chart.shadow.offsety'];\\\\n            \\\\n            co.lineWidth   = prop['chart.linewidth'];\\\\n            co.strokeStyle = color;\\\\n\\\\n            co.beginPath();\\\\n                for (var i=0; i<coords.length; ++i) {\\\\n                \\\\n                    var isNull     = RG.isNull(coords[i][1]);\\\\n                    var prevIsNull = RG.isNull(coords[i-1]) || RG.isNull(coords[i-1][1]);\\\\n\\\\n                    if (i == 0 || isNull || prevIsNull) {\\\\n                        if (!isNull) {\\\\n                            co.moveTo(coords[i][0] + offsetx, coords[i][1] + offsety);\\\\n                        }\\\\n                    } else {\\\\n                        co.lineTo(coords[i][0] + offsetx, coords[i][1] + offsety);\\\\n                    }\\\\n                }\\\\n            co.stroke();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draw the backdrop\\\\n        */\\\\n        this.drawBackdrop =\\\\n        this.DrawBackdrop = function (coords, color)\\\\n        {\\\\n            //var ca   = this.canvas;\\\\n            //var co   = this.context;\\\\n            //var prop = this.properties;\\\\n    \\\\n            var size = prop['chart.backdrop.size'];\\\\n            co.lineWidth = size;\\\\n            co.globalAlpha = prop['chart.backdrop.alpha'];\\\\n            co.strokeStyle = color;\\\\n            var yCoords = [];\\\\n    \\\\n            co.beginPath();\\\\n                if (prop['chart.curvy'] && !RG.ISOLD) {\\\\n                    \\\\n                    // The DrawSpline function only takes the Y coords so extract them from the coords that have\\\\n                    // (which are X/Y pairs)\\\\n                    for (var i=0; i<coords.length; ++i) {\\\\n                        yCoords.push(coords[i][1])\\\\n                    }\\\\n\\\\n                    this.DrawSpline(co, yCoords, color, null);\\\\n    \\\\n                } else {\\\\n                    co.moveTo(coords[0][0], coords[0][1]);\\\\n                    for (var j=1; j<coords.length; ++j) {\\\\n                        co.lineTo(coords[j][0], coords[j][1]);\\\\n                    }\\\\n                }\\\\n            co.stroke();\\\\n        \\\\n            // Reset the alpha value\\\\n            co.globalAlpha = 1;\\\\n            RG.NoShadow(this);\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Returns the linewidth\\\\n        */\\\\n        this.getLineWidth =\\\\n        this.GetLineWidth = function (i)\\\\n        {\\\\n            var linewidth = prop['chart.linewidth'];\\\\n\\\\n            if (typeof(linewidth) == 'number') {\\\\n                return linewidth;\\\\n            \\\\n            } else if (typeof(linewidth) == 'object') {\\\\n                if (linewidth[i]) {\\\\n                    return linewidth[i];\\\\n                } else {\\\\n                    return linewidth[0];\\\\n                }\\\\n    \\\\n                alert('[LINE] Error! chart.linewidth should be a single number or an array of one or more numbers');\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The getPoint() method - used to get the point the mouse is currently over, if any\\\\n        * \\\\n        * @param object e The event object\\\\n        * @param object   OPTIONAL You can pass in the bar object instead of the\\\\n        *                          function getting it from the canvas\\\\n        */\\\\n        this.getShape =\\\\n        this.getPoint = function (e)\\\\n        {\\\\n            var obj  = this,\\\\n                RG   = RGraph,\\\\n                ca   = canvas  = e.target,\\\\n                co   = context = this.context,\\\\n                prop = this.properties;\\\\n    \\\\n            var mouseXY = RG.getMouseXY(e),\\\\n                mouseX  = mouseXY[0],\\\\n                mouseY  = mouseXY[1];\\\\n            \\\\n            // This facilitates you being able to pass in the bar object as a parameter instead of\\\\n            // the function getting it from the object\\\\n            if (arguments[1]) {\\\\n                obj = arguments[1];\\\\n            }\\\\n    \\\\n            for (var i=0; i<obj.coords.length; ++i) {\\\\n            \\\\n                var x = obj.coords[i][0];\\\\n                var y = obj.coords[i][1];\\\\n    \\\\n                // Do this if the hotspot is triggered by the X coord AND the Y coord\\\\n                if (   mouseX <= (x + prop['chart.tooltips.hotspot.size'])\\\\n                    && mouseX >= (x - prop['chart.tooltips.hotspot.size'])\\\\n                    && mouseY <= (y + prop['chart.tooltips.hotspot.size'])\\\\n                    && mouseY >= (y - prop['chart.tooltips.hotspot.size'])\\\\n                   ) {\\\\n    \\\\n                        if (RG.parseTooltipText) {\\\\n                            var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);\\\\n                        }\\\\n    \\\\n                        // Work out the dataset\\\\n                        var dataset = 0;\\\\n                        var idx = i;\\\\n                        while ((idx + 1) > this.data[dataset].length) {\\\\n                            idx -= this.data[dataset].length;\\\\n                            dataset++;\\\\n                        }\\\\n    \\\\n                        return \\\";\");\";s:33:\"tcpfunc_58dc766f81c975.85595140_2\";s:698:\"\$tpl_funcs['tcpfunc_58dc766f81c975.85595140_2']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f81c975.85595140_2']=recall_named_function('58dc766f81c9b7.32091880','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_0obj)?\\\$bound_0obj:null,\\\"0obj/RGraph.line\\\"),\\n	\\\";\\\\n    \\\\n                } else if (    prop['chart.tooltips.hotspot.xonly'] == true\\\\n                            && mouseX <= (x + prop['chart.tooltips.hotspot.size'])\\\\n                            && mouseX >= (x - prop['chart.tooltips.hotspot.size'])) {\\\\n    \\\\n                            var tooltip = RG.parseTooltipText(prop['chart.tooltips'], i);\\\\n    \\\\n                            return \\\";\");\";s:33:\"tcpfunc_58dc766f81ca03.13185597_3\";s:47208:\"\$tpl_funcs['tcpfunc_58dc766f81ca03.13185597_3']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f81ca03.13185597_3']=recall_named_function('58dc766f81ca65.28444910','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo otp(isset(\\\$bound_0obj)?\\\$bound_0obj:null,\\\"0obj/RGraph.line\\\"),\\n	\\\";\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the above line labels\\\\n        */\\\\n        this.drawAboveLabels =\\\\n        this.DrawAboveLabels = function ()\\\\n        {\\\\n            var size       = prop['chart.labels.above.size'],\\\\n                font       = prop['chart.labels.above.font'] || prop['chart.text.font'],\\\\n                units_pre  = prop['chart.labels.above.units.pre'],\\\\n                units_post = prop['chart.labels.above.units.post'],\\\\n                decimals   = prop['chart.labels.above.decimals'],\\\\n                color      = prop['chart.labels.above.color'] || prop['chart.text.color'],\\\\n                bgcolor    = prop['chart.labels.above.background'] || 'white',\\\\n                border     = ((\\\\n                       typeof prop['chart.labels.above.border'] === 'boolean'\\\\n                    || typeof prop['chart.labels.above.border'] === 'number'\\\\n                ) ? prop['chart.labels.above.border'] : true),\\\\n                offsety = prop['chart.labels.above.offsety'] + size,\\\\n                specific = prop['chart.labels.above.specific'];\\\\n\\\\n            // Use this to 'reset' the drawing state\\\\n            co.beginPath();\\\\n    \\\\n            // Don't need to check that chart.labels.above is enabled here, it's been done already\\\\n            for (var i=0, len=this.coords.length; i<len; i+=1) {\\\\n\\\\n                var coords = this.coords[i];\\\\n\\\\n                RG.text2(this, {\\\\n                    color:color,\\\\n                    'font':font,\\\\n                    'size':size,\\\\n                    'x':coords[0],\\\\n                    'y':coords[1] - offsety,\\\\n                    'text':(specific && specific[i]) ? specific[i] : (specific ? null : RG.numberFormat(this, typeof decimals === 'number' ? this.data_arr[i].toFixed(decimals) : this.data_arr[i], units_pre, units_post)),\\\\n                    'valign':'center',\\\\n                    'halign':'center',\\\\n                    'bounding':true,\\\\n                    'boundingFill':bgcolor,\\\\n                    'boundingStroke':border ? 'black' : 'rgba(0,0,0,0)',\\\\n                    'tag':'labels.above'\\\\n                });\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draw a curvy line.\\\\n        */\\\\n        this.drawCurvyLine =\\\\n        this.DrawCurvyLine = function (coords, color, linewidth, index)\\\\n        {\\\\n            var yCoords = [];\\\\n    \\\\n            for (var i=0; i<coords.length; ++i) {\\\\n                yCoords.push(coords[i][1]);\\\\n            }\\\\n            \\\\n            if (prop['chart.filled']) {\\\\n                co.beginPath();\\\\n                    \\\\n                    // First, work out the xaxispos\\\\n                    //if (prop['chart.xaxispos'] === 'center') {\\\\n                    //    var xaxisY = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;\\\\n                    //} else {\\\\n                        var xaxisY = this.getYCoord(prop['chart.ymin']);\\\\n                    //}\\\\n\\\\n\\\\n                    co.moveTo(coords[0][0],xaxisY);\\\\n                    this.drawSpline(co, yCoords, color, index);\\\\n\\\\n                    if (prop['chart.filled.accumulative'] && index > 0) {\\\\n                        for (var i=(this.coordsSpline[index - 1].length - 1); i>=0; i-=1) {\\\\n                            co.lineTo(this.coordsSpline[index - 1][i][0], this.coordsSpline[index - 1][i][1]);\\\\n                        }\\\\n                    } else {\\\\n                        co.lineTo(coords[coords.length - 1][0],xaxisY);\\\\n                    }\\\\n                co.fill();\\\\n            }\\\\n\\\\n            co.beginPath();    \\\\n            this.DrawSpline(co, yCoords, color, index);\\\\n            co.stroke();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * When you click on the chart, this method can return the Y value at that point. It works for any point on the\\\\n        * chart (that is inside the gutters) - not just points on the Line.\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.getValue = function (arg)\\\\n        {\\\\n            if (arg.length == 2) {\\\\n                var mouseX = arg[0];\\\\n                var mouseY = arg[1];\\\\n            } else {\\\\n                var mouseCoords = RG.getMouseXY(arg);\\\\n                var mouseX      = mouseCoords[0];\\\\n                var mouseY      = mouseCoords[1];\\\\n            }\\\\n    \\\\n            var obj = this;\\\\n            var xaxispos = prop['chart.xaxispos'];\\\\n    \\\\n            if (mouseY < prop['chart.gutter.top']) {\\\\n                return xaxispos == 'bottom' || xaxispos == 'center' ? this.max : this.min;\\\\n            } else if (mouseY > (ca.height - prop['chart.gutter.bottom'])) {\\\\n                return xaxispos == 'bottom' ? this.min : this.max;\\\\n            }\\\\n            \\\\n            if (prop['chart.xaxispos'] == 'center') {\\\\n                var value = (( (obj.grapharea / 2) - (mouseY - prop['chart.gutter.top'])) / obj.grapharea) * (obj.max - obj.min);\\\\n                value *= 2;\\\\n                value > 0 ? value += this.min : value -= this.min;\\\\n                return value;\\\\n            } else if (prop['chart.xaxispos'] == 'top') {\\\\n                var value = ((obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea) * (obj.max - obj.min);\\\\n                value = Math.abs(obj.max - value) * -1;\\\\n                return value;\\\\n            } else {\\\\n                var value = ((obj.grapharea - (mouseY - prop['chart.gutter.top'])) / obj.grapharea) * (obj.max - obj.min)\\\\n                value += obj.min;\\\\n                return value;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Each object type has its own Highlight() function which highlights the appropriate shape\\\\n        * \\\\n        * @param object shape The shape to highlight\\\\n        */\\\\n        this.highlight =\\\\n        this.Highlight = function (shape)\\\\n        {\\\\n            if (prop['chart.tooltips.highlight']) {\\\\n                \\\\n                if (typeof prop['chart.highlight.style'] === 'function') {\\\\n                    (prop['chart.highlight.style'])(shape);\\\\n                \\\\n                } else if (prop['chart.highlight.style'] === 'halo') {\\\\n                    \\\\n                    var obj   = shape.object,\\\\n                        color = prop['chart.colors'][shape.dataset];\\\\n\\\\n                    // Clear a space in white first for the tickmark\\\\n                    RG.path2(obj.context, 'b a % % 13 0 6.2830 false f rgba(255,255,255,0.75)',\\\\n                        shape.x,\\\\n                        shape.y\\\\n                    );\\\\n                    \\\\n                    RG.path2(obj.context, 'ga 0.15 b a % % 13 0 6.2830 false f % ga 1',\\\\n                        shape.x,\\\\n                        shape.y,\\\\n                        color\\\\n                    );\\\\n            \\\\n                    RG.path2(obj.context, 'b a % % 7 0 6.2830 false f white',\\\\n                        shape.x,\\\\n                        shape.y\\\\n                    );\\\\n                    \\\\n                    RG.path2(obj.context, 'b a % % 5 0 6.2830 false f %',\\\\n                        shape.x,\\\\n                        shape.y,\\\\n                        color\\\\n                    );\\\\n                \\\\n                } else {\\\\n                    RG.Highlight.Point(this, shape);\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The getObjectByXY() worker method. Don't call this call:\\\\n        * \\\\n        * RG.ObjectRegistry.getObjectByXY(e)\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.getObjectByXY = function (e)\\\\n        {\\\\n            //var ca      = this.canvas;\\\\n            //var prop    = this.properties;\\\\n            var mouseXY = RG.getMouseXY(e);\\\\n    \\\\n            // The 5 is so that the cursor doesn't have to be over the graphArea to trigger the hotspot\\\\n            if (\\\\n                   (mouseXY[0] > prop['chart.gutter.left'] - 5)\\\\n                && mouseXY[0] < (ca.width - prop['chart.gutter.right'] + 5)\\\\n                && mouseXY[1] > (prop['chart.gutter.top'] - 5)\\\\n                && mouseXY[1] < (ca.height - prop['chart.gutter.bottom'] + 5)\\\\n                ) {\\\\n    \\\\n                return this;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This method handles the adjusting calculation for when the mouse is moved\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.adjusting_mousemove =\\\\n        this.Adjusting_mousemove = function (e)\\\\n        {\\\\n            /**\\\\n            * Handle adjusting for the Bar\\\\n            */\\\\n            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\\\\n    \\\\n                // Rounding the value to the given number of decimals make the chart step\\\\n                var value   = Number(this.getValue(e));//.toFixed(this.properties['chart.scale.decimals']);\\\\n                var shape   = RG.Registry.Get('chart.adjusting.shape');\\\\n    \\\\n                if (shape) {\\\\n    \\\\n                    RG.Registry.Set('chart.adjusting.shape', shape);\\\\n    \\\\n                    this.original_data[shape['dataset']][shape['index_adjusted']] = Number(value);\\\\n    \\\\n                    RG.redrawCanvas(e.target);\\\\n                    \\\\n                    RG.fireCustomEvent(this, 'onadjust');\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function can be used when the canvas is clicked on (or similar - depending on the event)\\\\n        * to retrieve the relevant Y coordinate for a particular value.\\\\n        * \\\\n        * @param int value The value to get the Y coordinate for\\\\n        */\\\\n        this.getYCoord = function (value)\\\\n        {    \\\\n            if (typeof(value) != 'number') {\\\\n                return null;\\\\n            }\\\\n    \\\\n            var y;\\\\n            var xaxispos = prop['chart.xaxispos'];\\\\n    \\\\n            // Higher than max\\\\n            // Commented out on March 7th 2013 because the tan curve was not showing correctly\\\\n            //if (value > this.max) {\\\\n            //    value = this.max;\\\\n            //}\\\\n    \\\\n            if (xaxispos == 'top') {\\\\n            \\\\n                // Account for negative numbers\\\\n                //if (value < 0) {\\\\n                //    value = Math.abs(value);\\\\n                //}\\\\n    \\\\n                y = ((value - this.min) / (this.max - this.min)) * this.grapharea;\\\\n    \\\\n                // Inverted Y labels\\\\n                if (prop['chart.scale.invert']) {\\\\n                    y = this.grapharea - y;\\\\n                }\\\\n    \\\\n                y = y + this.gutterTop\\\\n    \\\\n            } else if (xaxispos == 'center') {\\\\n    \\\\n                y = ((value - this.min) / (this.max - this.min)) * (this.grapharea / 2);\\\\n                y = (this.grapharea / 2) - y;\\\\n                y += this.gutterTop;\\\\n    \\\\n            } else {\\\\n    \\\\n                if ((value < this.min || value > this.max) && prop['chart.outofbounds'] == false) {\\\\n                    return null;\\\\n                }\\\\n    \\\\n                y = ((value - this.min) / (this.max - this.min)) * this.grapharea;\\\\n    \\\\n    \\\\n                \\\\n                // Inverted Y labels\\\\n                if (prop['chart.scale.invert']) {\\\\n                    y = this.grapharea - y;\\\\n                }\\\\n                \\\\n                y = ca.height - this.gutterBottom - y;\\\\n            }\\\\n\\\\n            return y;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function positions a tooltip when it is displayed\\\\n        * \\\\n        * @param obj object    The chart object\\\\n        * @param int x         The X coordinate specified for the tooltip\\\\n        * @param int y         The Y coordinate specified for the tooltip\\\\n        * @param objec tooltip The tooltips DIV element\\\\n        *\\\\n        this.positionTooltip = function (obj, x, y, tooltip, idx)\\\\n        {\\\\n\\\\n            var coordX     = obj.coords[tooltip.__index__][0];\\\\n            var coordY     = obj.coords[tooltip.__index__][1];\\\\n            var canvasXY   = RG.getCanvasXY(obj.canvas);\\\\n            var gutterLeft = prop['chart.gutter.left'];\\\\n            var gutterTop  = prop['chart.gutter.top'];\\\\n            var width      = tooltip.offsetWidth;\\\\n            var height     = tooltip.offsetHeight;\\\\n            var mouseXY    = RG.getMouseXY(window.event);\\\\n    \\\\n            // Set the top position\\\\n            tooltip.style.left = 0;\\\\n            tooltip.style.top  = window.event.pageY - height - 20 + 'px';\\\\n            \\\\n            // By default any overflow is hidden\\\\n            tooltip.style.overflow = '';\\\\n            \\\\n            // Reposition the tooltip if at the edges:\\\\n            \\\\n            // LEFT edge\\\\n            if (canvasXY[0] + mouseXY[0] - (width / 2) < 0) {\\\\n                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width * 0.1) + 'px';\\\\n    \\\\n            // RIGHT edge\\\\n            } else if (canvasXY[0] + mouseXY[0]  + (width / 2) > doc.body.offsetWidth) {\\\\n                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width * 0.9) + 'px';\\\\n    \\\\n            // Default positioning - CENTERED\\\\n            } else {\\\\n                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width / 2) + 'px';\\\\n            }\\\\n        };*/\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws a curvy line\\\\n        * \\\\n        * @param object context The  2D context\\\\n        * @param array  coords  The coordinates\\\\n        */\\\\n        this.drawSpline =\\\\n        this.DrawSpline = function (context, coords, color, index)\\\\n        {\\\\n            this.coordsSpline[index] = [];\\\\n            var xCoords     = [];\\\\n            var gutterLeft  = prop['chart.gutter.left'];\\\\n            var gutterRight = prop['chart.gutter.right'];\\\\n            var hmargin     = prop['chart.hmargin'];\\\\n            var interval    = (ca.width - (gutterLeft + gutterRight) - (2 * hmargin)) / (coords.length - 1);\\\\n    \\\\n            co.strokeStyle = color;\\\\n\\\\n            /**\\\\n            * The drawSpline function takes an array of JUST Y coords - not X/Y coords. So the line coords need converting\\\\n            * if we've been given X/Y pairs\\\\n            */\\\\n            for (var i=0,len=coords.length; i<len;i+=1) {\\\\n                if (typeof coords[i] == 'object' && coords[i] && coords[i].length == 2) {\\\\n                    coords[i] = Number(coords[i][1]);\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Get the Points array in the format we want - first value should be null along with the lst value\\\\n            */\\\\n            var P = [coords[0]];\\\\n            for (var i=0; i<coords.length; ++i) {\\\\n                P.push(coords[i]);\\\\n            }\\\\n            P.push(coords[coords.length - 1] + (coords[coords.length - 1] - coords[coords.length - 2]));\\\\n    \\\\n            for (var j=1; j<P.length-2; ++j) {\\\\n                for (var t=0; t<10; ++t) {\\\\n                    \\\\n                    var yCoord = Spline( t/10, P[j-1], P[j], P[j+1], P[j+2] );\\\\n    \\\\n                    xCoords.push(((j-1) * interval) + (t * (interval / 10)) + gutterLeft + hmargin);\\\\n\\\\n                    co.lineTo(xCoords[xCoords.length - 1], yCoord);\\\\n\\\\n                    \\\\n                    if (typeof index == 'number') {\\\\n                        this.coordsSpline[index].push([xCoords[xCoords.length - 1], yCoord]);\\\\n                    }\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            // Draw the last section\\\\n            co.lineTo(((j-1) * interval) + gutterLeft + hmargin, P[j]);\\\\n            if (typeof index == 'number') {\\\\n                this.coordsSpline[index].push([((j-1) * interval) + gutterLeft + hmargin, P[j]]);\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            function Spline (t, P0, P1, P2, P3)\\\\n            {\\\\n                return 0.5 * ((2 * P1) +\\\\n                             ((0-P0) + P2) * t +\\\\n                             ((2*P0 - (5*P1) + (4*P2) - P3) * (t*t) +\\\\n                             ((0-P0) + (3*P1)- (3*P2) + P3) * (t*t*t)));\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This allows for easy specification of gradients\\\\n        */\\\\n        this.parseColors = function ()\\\\n        {\\\\n            // Save the original colors so that they can be restored when the canvas is reset\\\\n            if (this.original_colors.length === 0) {\\\\n                this.original_colors['chart.colors']                = RGraph.array_clone(prop['chart.colors']);\\\\n                this.original_colors['chart.fillstyle']             = RGraph.array_clone(prop['chart.fillstyle']);\\\\n                this.original_colors['chart.key.colors']            = RGraph.array_clone(prop['chart.key.colors']);\\\\n                this.original_colors['chart.background.barcolor1']  = prop['chart.background.barcolor1'];\\\\n                this.original_colors['chart.background.barcolor2']  = prop['chart.background.barcolor2'];\\\\n                this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];\\\\n                this.original_colors['chart.background.color']      = prop['chart.background.color'];\\\\n                this.original_colors['chart.text.color']            = prop['chart.text.color'];\\\\n                this.original_colors['chart.crosshairs.color']      = prop['chart.crosshairs.color'];\\\\n                this.original_colors['chart.annotate.color']        = prop['chart.annotate.color'];\\\\n                this.original_colors['chart.title.color']           = prop['chart.title.color'];\\\\n                this.original_colors['chart.title.yaxis.color']     = prop['chart.title.yaxis.color'];\\\\n                this.original_colors['chart.key.background']        = prop['chart.key.background'];\\\\n                this.original_colors['chart.axis.color']            = prop['chart.axis.color'];\\\\n                this.original_colors['chart.highlight.fill']        = prop['chart.highlight.fill'];\\\\n            }\\\\n            \\\\n            \\\\n            \\\\n            for (var i=0; i<prop['chart.colors'].length; ++i) {\\\\n                if (typeof(prop['chart.colors'][i]) == 'object' && prop['chart.colors'][i][0] && prop['chart.colors'][i][1]) {\\\\n                    prop['chart.colors'][i][0] = this.parseSingleColorForGradient(prop['chart.colors'][i][0]);\\\\n                    prop['chart.colors'][i][1] = this.parseSingleColorForGradient(prop['chart.colors'][i][1]);\\\\n                } else {\\\\n                    prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\\\\n                }\\\\n            }\\\\n            \\\\n            /**\\\\n            * Fillstyle\\\\n            */\\\\n            if (prop['chart.fillstyle']) {\\\\n                if (typeof(prop['chart.fillstyle']) == 'string') {\\\\n                    prop['chart.fillstyle'] = this.parseSingleColorForGradient(prop['chart.fillstyle'], 'vertical');\\\\n                } else {\\\\n                    for (var i=0; i<prop['chart.fillstyle'].length; ++i) {\\\\n                        prop['chart.fillstyle'][i] = this.parseSingleColorForGradient(prop['chart.fillstyle'][i], 'vertical');\\\\n                    }\\\\n                }\\\\n            }\\\\n            \\\\n            /**\\\\n            * Key colors\\\\n            */\\\\n            if (!RG.is_null(prop['chart.key.colors'])) {\\\\n                for (var i=0; i<prop['chart.key.colors'].length; ++i) {\\\\n                    prop['chart.key.colors'][i] = this.parseSingleColorForGradient(prop['chart.key.colors'][i]);\\\\n                }\\\\n            }\\\\n    \\\\n            /**\\\\n            * Parse various properties for colors\\\\n            */\\\\n            var properties = [\\\\n                'chart.background.barcolor1',\\\\n                'chart.background.barcolor2',\\\\n                'chart.background.grid.color',\\\\n                'chart.background.color',\\\\n                'chart.text.color',\\\\n                'chart.crosshairs.color',\\\\n                'chart.annotate.color',\\\\n                'chart.title.color',\\\\n                'chart.title.yaxis.color',\\\\n                'chart.key.background',\\\\n                'chart.axis.color',\\\\n                'chart.highlight.fill'\\\\n            ];\\\\n    \\\\n            for (var i=0; i<properties.length; ++i) {\\\\n                prop[properties[i]] = this.parseSingleColorForGradient(prop[properties[i]]);\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Use this function to reset the object to the post-constructor state. Eg reset colors if\\\\n        * need be etc\\\\n        */\\\\n        this.reset = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This parses a single color value\\\\n        */\\\\n        this.parseSingleColorForGradient = function (color)\\\\n        {            \\\\n            if (!color || typeof(color) != 'string') {\\\\n                return color;\\\\n            }\\\\n\\\\n            /**\\\\n            * Horizontal or vertical gradient\\\\n            */\\\\n            var dir = typeof(arguments[1]) == 'string' ? arguments[1] : 'vertical';\\\\n    \\\\n            if (typeof color === 'string' && color.match(/^gradient\\\\\\\\((.*)\\\\\\\\)\\\\\\\$/i)) {\\\\n    \\\\n                var parts = RegExp.\\\\\\\$1.split(':');\\\\n    \\\\n                // Create the gradient\\\\n                if (dir == 'horizontal') {\\\\n                    var grad = co.createLinearGradient(0,0,ca.width,0);\\\\n                } else {\\\\n                    var grad = co.createLinearGradient(0,ca.height - prop['chart.gutter.bottom'],0,prop['chart.gutter.top']);\\\\n                }\\\\n    \\\\n                var diff = 1 / (parts.length - 1);\\\\n    \\\\n                grad.addColorStop(0, RG.trim(parts[0]));\\\\n    \\\\n                for (var j=1; j<parts.length; ++j) {\\\\n                    grad.addColorStop(\\\\n                        j * diff,\\\\n                        RG.trim(parts[j])\\\\n                    );\\\\n                }\\\\n            }\\\\n    \\\\n            return grad ? grad : color;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Sets the appropriate shadow\\\\n        */\\\\n        this.setShadow =\\\\n        this.SetShadow = function (i)\\\\n        {\\\\n            //var ca   = this.canvas;\\\\n            //var co   = this.context;\\\\n            //var prop = this.properties;\\\\n    \\\\n            if (prop['chart.shadow']) {\\\\n                /**\\\\n                * Handle the appropriate shadow color. This now facilitates an array of differing\\\\n                * shadow colors\\\\n                */\\\\n                var shadowColor = prop['chart.shadow.color'];\\\\n        \\\\n                /**\\\\n                * Accommodate an array of shadow colors as well as a single string\\\\n                */\\\\n                if (typeof(shadowColor) == 'object' && shadowColor[i - 1]) {\\\\n                    co.shadowColor = shadowColor[i];\\\\n    \\\\n                } else if (typeof(shadowColor) == 'object') {\\\\n                    co.shadowColor = shadowColor[0];\\\\n    \\\\n                } else if (typeof(shadowColor) == 'string') {\\\\n                    co.shadowColor = shadowColor;\\\\n                }\\\\n        \\\\n                co.shadowBlur    = prop['chart.shadow.blur'];\\\\n                co.shadowOffsetX = prop['chart.shadow.offsetx'];\\\\n                co.shadowOffsetY = prop['chart.shadow.offsety'];\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function handles highlighting an entire data-series for the interactive\\\\n        * key\\\\n        * \\\\n        * @param int index The index of the data series to be highlighted\\\\n        */\\\\n        this.interactiveKeyHighlight = function (index)\\\\n        {\\\\n            var coords = this.coords2[index];\\\\n\\\\n            if (coords) {\\\\n\\\\n                var pre_linewidth = co.lineWidth;\\\\n                var pre_linecap   = co.lineCap;\\\\n                \\\\n                co.lineWidth   = prop['chart.linewidth'] + 10;\\\\n                co.lineCap     = 'round';\\\\n                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];\\\\n\\\\n                \\\\n                co.beginPath();\\\\n                if (prop['chart.curvy']) {\\\\n                    this.DrawSpline(co, coords, prop['chart.key.interactive.highlight.chart'], null);\\\\n                } else {\\\\n                    for (var i=0,len=coords.length; i<len; i+=1) {\\\\n                        if (   i == 0\\\\n                            || RG.is_null(coords[i][1])\\\\n                            || (typeof coords[i - 1][1] != undefined && RG.is_null(coords[i - 1][1]))) {\\\\n                            co.moveTo(coords[i][0], coords[i][1]);\\\\n                        } else {\\\\n                            co.lineTo(coords[i][0], coords[i][1]);\\\\n                        }\\\\n                    }\\\\n                }\\\\n                co.stroke();\\\\n                \\\\n                // Reset the lineCap and lineWidth\\\\n                co.lineWidth = pre_linewidth;\\\\n                co.lineCap = pre_linecap;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Using a function to add events makes it easier to facilitate method chaining\\\\n        * \\\\n        * @param string   type The type of even to add\\\\n        * @param function func \\\\n        */\\\\n        this.on = function (type, func)\\\\n        {\\\\n            if (type.substr(0,2) !== 'on') {\\\\n                type = 'on' + type;\\\\n            }\\\\n\\\\n\\\\n            if (typeof this[type] !== 'function') {\\\\n                this[type] = func;\\\\n            } else {\\\\n                RG.addCustomEventListener(this, type, func);\\\\n            }\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function runs once only\\\\n        * (put at the end of the file (before any effects))\\\\n        */\\\\n        this.firstDrawFunc = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        //\\\\n        // Draws error-bars for the Bar and Line charts\\\\n        //\\\\n        this.drawErrorbars = function ()\\\\n        {\\\\n            // Save the state of the canvas so that it can be restored at the end\\\\n            co.save();\\\\n\\\\n                RG.noShadow(this);\\\\n\\\\n                var coords = this.coords,\\\\n                         x = 0,\\\\n                 errorbars = prop['chart.errorbars'],\\\\n                    length = 0;\\\\n\\\\n                // If not capped set the width of the cap to zero\\\\n                if (!prop['chart.errorbars.capped']) {\\\\n                    prop['chart.errorbars.capped.width'] = 0.001;\\\\n                    halfwidth = 0.0005;\\\\n                }\\\\n\\\\n                // Set the linewidth\\\\n                co.lineWidth = prop['chart.errorbars.linewidth'];\\\\n    \\\\n    \\\\n    \\\\n    \\\\n                for (var i=0; i<coords.length; ++i) {\\\\n                \\\\n                    var halfwidth = prop['chart.errorbars.capped.width'] / 2 || 5,\\\\n                            color = prop['chart.errorbars.color'] || 'black';\\\\n\\\\n                    // Set the perbar linewidth if the fourth option in the array\\\\n                    // is specified\\\\n                    if (errorbars[i] && typeof errorbars[i][3] === 'number') {\\\\n                        co.lineWidth = errorbars[i][3];\\\\n                    } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\\\\n                        co.lineWidth = prop['chart.errorbars.linewidth'];\\\\n                    } else {\\\\n                        co.lineWidth = 1;\\\\n                    }\\\\n\\\\n    \\\\n    \\\\n                    // Calulate the pixel size\\\\n                    if (typeof errorbars === 'number' || typeof errorbars[i] === 'number') {\\\\n\\\\n                        if (typeof errorbars === 'number') {\\\\n                            var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars),\\\\n                                negativeLength = positiveLength;\\\\n                        } else {\\\\n                            var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i]),\\\\n                                negativeLength = positiveLength;\\\\n                        }\\\\n\\\\n                        if (positiveLength || negativeLength) {\\\\n\\\\n                            pa2(\\\\n                                co,\\\\n                                'lj miter lc square b m % % l % % m % % l % % l % % m % % l % % s %',\\\\n                                coords[i][0] - halfwidth,\\\\n                                coords[i][1] + negativeLength,\\\\n                                coords[i][0] + halfwidth,\\\\n                                coords[i][1] + negativeLength,\\\\n                                coords[i][0],\\\\n                                coords[i][1] + negativeLength,\\\\n                                coords[i][0],\\\\n                                coords[i][1] - positiveLength,\\\\n                                coords[i][0] - halfwidth,\\\\n                                coords[i][1] - positiveLength,\\\\n                                coords[i][0],\\\\n                                coords[i][1] - positiveLength,\\\\n                                coords[i][0] + halfwidth,\\\\n                                coords[i][1] - positiveLength,\\\\n                                color\\\\n                            );\\\\n\\\\n                            pa2(\\\\n                                co,\\\\n                                'lj miter lc square b m % % l % % s %',\\\\n                                coords[i][0] - halfwidth,\\\\n                                coords[i][1] + negativeLength,\\\\n                                coords[i][0] + halfwidth,\\\\n                                coords[i][1] + negativeLength,\\\\n                                color\\\\n                            );\\\\n                        }\\\\n\\\\n\\\\n\\\\n                    } else if (typeof errorbars[i] === 'object' && !RG.isNull(errorbars[i])) {\\\\n\\\\n                        var positiveLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][0]),\\\\n                            negativeLength = this.getYCoord(this.min) - this.getYCoord(this.min + errorbars[i][1]);\\\\n\\\\n\\\\n                        // Color\\\\n                        if (typeof errorbars[i][2] === 'string') {\\\\n                            color = errorbars[i][2];\\\\n                        }\\\\n\\\\n                        // Cap width\\\\n                        halfwidth = typeof errorbars[i][4] === 'number' ? errorbars[i][4] / 2 : halfwidth;\\\\n    \\\\n    \\\\n                        // Set the linewidth\\\\n                        if (typeof errorbars[i] === 'object' && typeof errorbars[i][3] === 'number') {\\\\n                            co.lineWidth = errorbars[i][3];\\\\n                        } else if (typeof prop['chart.errorbars.linewidth'] === 'number') {\\\\n                            co.lineWidth = prop['chart.errorbars.linewidth'];\\\\n                        } else {\\\\n                            co.lineWidth = 1;\\\\n                        }\\\\n\\\\n\\\\n                        if (!RG.isNull(errorbars[i][0])) {\\\\n\\\\n                            pa2(\\\\n                                co,\\\\n                                'lc square b  m % % l % % l % % m % % l % % s %',\\\\n                                coords[i][0],\\\\n                                coords[i][1],\\\\n                                coords[i][0],\\\\n                                coords[i][1] - positiveLength,\\\\n                                coords[i][0] - halfwidth,\\\\n                                ma.round(coords[i][1] - positiveLength),\\\\n                                coords[i][0],\\\\n                                ma.round(coords[i][1] - positiveLength),\\\\n                                coords[i][0] + halfwidth,\\\\n                                ma.round(coords[i][1] - positiveLength),\\\\n                                color\\\\n                            );\\\\n                        }\\\\n    \\\\n                        if (typeof errorbars[i][1] === 'number') {\\\\n\\\\n                            var negativeLength = ma.abs(this.getYCoord(errorbars[i][1]) - this.getYCoord(0));\\\\n    \\\\n                            pa2(\\\\n                                co,\\\\n                                'b m % % l % % l % % m % % l % % s %',\\\\n                                coords[i][0],\\\\n                                coords[i][1],\\\\n                                coords[i][0],\\\\n                                coords[i][1] + negativeLength,\\\\n                                coords[i][0] - halfwidth,\\\\n                                ma.round(coords[i][1] + negativeLength),\\\\n                                coords[i][0],\\\\n                                ma.round(coords[i][1] + negativeLength),\\\\n                                coords[i][0] + halfwidth,\\\\n                                ma.round(coords[i][1] + negativeLength),\\\\n                                color\\\\n                            );\\\\n                        }\\\\n                    }\\\\n                }\\\\n\\\\n            co.restore();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Hides a line by setting the appropriate flag so that the .visible(index)\\\\n        * function returns the relevant result.\\\\n        * \\\\n        * @param int index The index of the line to hide\\\\n        */\\\\n        this.hide = function ()\\\\n        {\\\\n            // Hide a single line\\\\n            if (typeof arguments[0] === 'number') {\\\\n                prop['chart.line.visible'][arguments[0]] = false;\\\\n            \\\\n            // Hide multiple lines\\\\n            } else if (typeof arguments[0] === 'object') {\\\\n                for (var i=0; i<arguments[0].length; ++i) {\\\\n                    prop['chart.line.visible'][arguments[0][i]] = false;\\\\n                }\\\\n                \\\\n            // Hide all lines\\\\n            } else {\\\\n                for (var i=0; i<this.original_data.length; ++i) {\\\\n                    prop['chart.line.visible'][i] = false;\\\\n                }\\\\n            }\\\\n            \\\\n            RG.redraw();\\\\n            \\\\n            // Facilitate chaining\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Shows a line by setting the appropriate flag so that the .visible(index)\\\\n        * function returns the relevant result.\\\\n        * \\\\n        * @param int index The index of the line to show\\\\n        */\\\\n        this.show = function ()\\\\n        {\\\\n            // Show a single line\\\\n            if (typeof arguments[0] === 'number') {\\\\n                prop['chart.line.visible'][arguments[0]] = true;\\\\n            \\\\n            // Show multiple lines\\\\n            } else if (typeof arguments[0] === 'object') {\\\\n                for (var i=0; i<arguments[0].length; ++i) {\\\\n                    prop['chart.line.visible'][arguments[0][i]] = true;\\\\n                }\\\\n\\\\n            // Show all lines\\\\n            } else {\\\\n                for (var i=0; i<this.original_data.length; ++i) {\\\\n                    prop['chart.line.visible'][i] = true;\\\\n                }\\\\n            }\\\\n            \\\\n            RG.redraw();            \\\\n            \\\\n            // Facilitate chaining\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Returns true/false as to wether a line is hidden or not\\\\n        * \\\\n        * @param int index The index of the line to hide\\\\n        */\\\\n        this.hidden = function (index)\\\\n        {\\\\n            return !prop['chart.line.visible'][index];\\\\n        };\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Unfold\\\\n        * \\\\n        * This effect gradually increases the X/Y coordinatesfrom 0\\\\n        * \\\\n        * @param object obj The chart object\\\\n        */\\\\n        this.unfold = function ()\\\\n        {\\\\n            var obj                        = this;\\\\n            var opt                        = arguments[0] ? arguments[0] : {};\\\\n            var frames                     = opt.frames ? opt.frames : 30;\\\\n            var frame                      = 0;\\\\n            var callback                   = arguments[1] ? arguments[1] : function () {};\\\\n            var initial                    = prop['chart.animation.unfold.initial'];\\\\n            \\\\n            prop['chart.animation.factor'] = prop['chart.animation.unfold.initial'];\\\\n\\\\n            function iterator ()\\\\n            {\\\\n                prop['chart.animation.factor'] = ((1 - initial) * (frame / frames)) + initial;\\\\n    \\\\n                RG.clear(obj.canvas);\\\\n                RG.redrawCanvas(obj.canvas);\\\\n    \\\\n                if (frame < frames) {\\\\n                    frame++;\\\\n                    RG.Effects.updateCanvas(iterator);\\\\n                } else {\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n\\\\n\\\\n            iterator();\\\\n\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Trace2\\\\n        * \\\\n        * This is a new version of the Trace effect which no longer requires jQuery and is more compatible\\\\n        * with other effects (eg Expand). This new effect is considerably simpler and less code.\\\\n        * \\\\n        * @param object     Options for the effect. Currently only \\\\\\\"frames\\\\\\\" is available.\\\\n        * @param int        A function that is called when the ffect is complete\\\\n        */\\\\n        this.trace  =\\\\n        this.trace2 = function ()\\\\n        {\\\\n            var obj       = this;\\\\n            var callback  = arguments[2];\\\\n            var opt       = arguments[0] || {};\\\\n            var frames    = opt.frames || 30;\\\\n            var frame     = 0;\\\\n            var callback = arguments[1] || function () {};\\\\n\\\\n            obj.Set('animation.trace.clip', 0);\\\\n    \\\\n            function iterator ()\\\\n            {\\\\n                RG.clear(obj.canvas);\\\\n\\\\n                RG.redrawCanvas(obj.canvas);\\\\n\\\\n                if (frame++ < frames) {\\\\n                    obj.Set('animation.trace.clip', frame / frames);\\\\n                    RG.Effects.updateCanvas(iterator);\\\\n                } else {\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n            \\\\n            iterator();\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * FoldToCenter\\\\n        * \\\\n        * Line chart  FoldTocenter\\\\n        * \\\\n        * @param object   OPTIONAL An object map of options\\\\n        * @param function OPTIONAL A callback to run when the effect is complete\\\\n        */\\\\n        this.foldtocenter =\\\\n        this.foldToCenter = function ()\\\\n        {\\\\n            var obj      = this;\\\\n            var opt      = arguments[0] || {};\\\\n            var frames   = opt.frames || 30;\\\\n            var frame    = 0;\\\\n            var callback = arguments[1] || function () {};\\\\n            var center_value = obj.scale2.max / 2;\\\\n\\\\n            obj.Set('chart.ymax', obj.scale2.max);\\\\n            \\\\n            var original_data = RG.array_clone(obj.original_data);\\\\n            \\\\n            function iterator ()\\\\n            {\\\\n                for (var i=0,len=obj.data.length; i<len; ++i) {\\\\n                    if (obj.data[i].length) {\\\\n                        for (var j=0,len2=obj.data[i].length; j<len2; ++j) {\\\\n                            \\\\n                            var dataset = obj.original_data[i];\\\\n\\\\n                            if (dataset[j] > center_value) {\\\\n                                dataset[j] = original_data[i][j] - ((original_data[i][j] - center_value) * (frame / frames));\\\\n                            } else {\\\\n                                dataset[j] = original_data[i][j] + (((center_value - original_data[i][j]) / frames) * frame);\\\\n                            }\\\\n                        }\\\\n                    }\\\\n                }\\\\n                \\\\n                RG.clear(obj.canvas);\\\\n                RG.redrawCanvas(obj.canvas)\\\\n    \\\\n                if (frame++ < frames) {\\\\n                    RG.Effects.updateCanvas(iterator);\\\\n                } else {\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n            iterator();\\\\n\\\\n\\\\n\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * UnfoldFromCenterTrace effect\\\\n        * \\\\n        * @param object   An object containing options\\\\n        * @param function A callback function\\\\n        */\\\\n        this.unfoldFromCenterTrace =\\\\n        this.unfoldFromCenterTrace2 = function ()\\\\n        {\\\\n            var obj      = this,\\\\n                opt      = arguments[0] || {},\\\\n                frames   = opt.frames || 30,\\\\n                frame    = 0,\\\\n                data     = RG.arrayClone(obj.original_data),\\\\n                callback = arguments[1] || function () {};\\\\n\\\\n\\\\n\\\\n            // Draw the chart once to get the scale values\\\\n            obj.canvas.style.visibility = 'hidden';\\\\n            obj.draw();\\\\n            var max = obj.scale2.max;\\\\n            RG.clear(obj.canvas);\\\\n            obj.canvas.style.visibility = 'visible';\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * When the Trace function finishes it calls this function\\\\n            */\\\\n            var unfoldCallback = function ()\\\\n            {\\\\n                obj.original_data = data;\\\\n                obj.unfoldFromCenter({frames: frames / 2}, callback);\\\\n            };\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Determine the mid-point\\\\n            */\\\\n            var half = obj.Get('chart.xaxispos') == 'center' ? obj.min : ((obj.max - obj.min) / 2) + obj.min;\\\\n            obj.Set('chart.ymax', obj.max);\\\\n    \\\\n            for (var i=0,len=obj.original_data.length; i<len; ++i) {\\\\n                for (var j=0; j<obj.original_data[i].length; ++j) {\\\\n                    obj.original_data[i][j] = (obj.Get('chart.filled') && obj.Get('chart.filled.accumulative') && i > 0) ? 0 : half;\\\\n                }\\\\n            }\\\\n\\\\n            RG.clear(obj.canvas);\\\\n            obj.trace2({frames: frames / 2}, unfoldCallback);\\\\n            \\\\n            return obj;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * UnfoldFromCenter\\\\n        * \\\\n        * Line chart  unfold from center\\\\n        * \\\\n        * @param object An option map of properties. Only frames is supported: {frames: 30}\\\\n        * @param function An optional callback\\\\n        */\\\\n        this.unfoldFromCenter = function ()\\\\n        {\\\\n            var obj           = this;\\\\n            var opt           = arguments[0] || {};\\\\n            var frames        = opt.frames || 30;\\\\n            var frame         = 0;\\\\n            var callback      = arguments[1] || function () {};\\\\n            \\\\n            // Draw the chart once to get the scale values\\\\n            obj.canvas.style.visibility = 'hidden';\\\\n            obj.Draw();\\\\n            var max = obj.scale2.max;\\\\n            RG.clear(obj.canvas);\\\\n            obj.canvas.style.visibility = 'visible';\\\\n\\\\n            var center_value  = obj.Get('chart.xaxispos') === 'center' ? prop['chart.ymin'] : ((obj.max - obj.min) / 2) + obj.min;\\\\n            var original_data = RG.array_clone(obj.original_data);\\\\n            var steps         = null;\\\\n            \\\\n            obj.Set('chart.ymax', max);\\\\n\\\\n            if (!steps) {\\\\n            \\\\n                steps = [];\\\\n            \\\\n                for (var dataset=0,len=original_data.length; dataset<len; ++dataset) {\\\\n    \\\\n                    steps[dataset] = []\\\\n    \\\\n                    for (var i=0,len2=original_data[dataset].length; i<len2; ++i) {\\\\n                        if (prop['chart.filled'] && prop['chart.filled.accumulative'] && dataset > 0) {\\\\n                            steps[dataset][i] = original_data[dataset][i] / frames;\\\\n                            obj.original_data[dataset][i] = center_value;\\\\n                        } else {\\\\n                            steps[dataset][i] = (original_data[dataset][i] - center_value) / frames;\\\\n                            obj.original_data[dataset][i] = center_value;\\\\n                        }\\\\n                    }\\\\n                }\\\\n            }\\\\n\\\\n            function unfoldFromCenter ()\\\\n            {\\\\n                for (var dataset=0; dataset<original_data.length; ++dataset) {\\\\n                    for (var i=0; i<original_data[dataset].length; ++i) {\\\\n                        obj.original_data[dataset][i] += steps[dataset][i];\\\\n                    }\\\\n                }\\\\n\\\\n                RG.clear(obj.canvas);\\\\n                RG.redrawCanvas(obj.canvas);\\\\n    \\\\n                if (--frames > 0) {\\\\n                    RG.Effects.updateCanvas(unfoldFromCenter);\\\\n                } else {\\\\n                    obj.original_data = RG.array_clone(original_data);\\\\n                    RG.clear(obj.canvas);\\\\n                    RG.redrawCanvas(obj.canvas);\\\\n\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n            \\\\n            unfoldFromCenter();\\\\n            \\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        RG.att(ca);\\\\n\\\\n\\\\n\\\\n        //\\\\n        // Determines whether a point is adjustable or not.\\\\n        //\\\\n        // @param object A shape object\\\\n        //\\\\n        this.isAdjustable = function (shape)\\\\n        {\\\\n            if (RG.isNull(prop['chart.adjustable.only'])) {\\\\n                return true;\\\\n            }\\\\n\\\\n            if (RG.isArray(prop['chart.adjustable.only']) && prop['chart.adjustable.only'][shape.index]) {\\\\n                return true;\\\\n            }\\\\n\\\\n            return false;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Register the object so it is redrawn when necessary\\\\n        */\\\\n        RG.Register(this);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This is the 'end' of the constructor so if the first argument\\\\n        * contains configuration data - handle that.\\\\n        */\\\\n        if (parseConfObjectForOptions) {\\\\n            RG.parseObjectStyleConfig(this, conf.options);\\\\n        }\\\\n\\\\n        /**\\\\n        * Allow all lines to start off as visible\\\\n        */\\\\n        for (var i=0; i<this.original_data.length; ++i) {\\\\n            prop['chart.line.visible'][i] = true;\\\\n        }\\\\n    };\\\";\");\";}}");

?>