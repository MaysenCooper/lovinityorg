<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:1:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc766f7194c2.46634029_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:21:\"RGraph.common.dynamic\";i:3;N;i:4;a:1:{s:33:\"tcpfunc_58dc766f7194c2.46634029_1\";s:55068:\"\$tpl_funcs['tcpfunc_58dc766f7194c2.46634029_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc766f7194c2.46634029_1']=recall_named_function('58dc766f7197c5.67230370','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n\\\\n    /**\\\\n    * Initialise the various objects\\\\n    */\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n\\\\n// Module pattern\\\\n(function (win, doc, undefined)\\\\n{\\\\n    var RG = RGraph,\\\\n        ua = navigator.userAgent,\\\\n        ma = Math;\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the window click event listener. It redraws all canvas tags on the page.\\\\n    */\\\\n    RG.installWindowMousedownListener =\\\\n    RG.InstallWindowMousedownListener = function (obj)\\\\n    {\\\\n        if (!RG.window_mousedown_event_listener) {\\\\n\\\\n            RG.window_mousedown_event_listener = function (e)\\\\n            {\\\\n                /**\\\\n                * For firefox add the window.event object\\\\n                */\\\\n                if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;\\\\n                \\\\n                e = RG.fixEventObject(e);\\\\n    \\\\n\\\\n                if (RG.HideTooltip && RG.Registry.Get('chart.tooltip')) {\\\\n                    RG.clear(RG.Registry.Get('chart.tooltip').__canvas__);\\\\n                    RG.redraw();\\\\n                    RG.hideTooltip();\\\\n                }\\\\n            };\\\\n            win.addEventListener('mousedown', RG.window_mousedown_event_listener, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the window click event listener. It redraws all canvas tags on the page.\\\\n    */\\\\n    RG.installWindowMouseupListener =\\\\n    RG.InstallWindowMouseupListener = function (obj)\\\\n    {\\\\n        if (!RG.window_mouseup_event_listener) {\\\\n            RG.window_mouseup_event_listener = function (e)\\\\n            {\\\\n                /**\\\\n                * For firefox add the window.event object\\\\n                */\\\\n                if (navigator.userAgent.indexOf('Firefox') >= 0) win.event = e;\\\\n                \\\\n                e = RG.fixEventObject(e);\\\\n    \\\\n    \\\\n                /**\\\\n                * Stop any annotating that may be going on\\\\n                */\\\\n                if (RG.annotating_window_onmouseup) {\\\\n                    RG.annotating_window_onmouseup(e);\\\\n                    return;\\\\n                }\\\\n    \\\\n                /**\\\\n                * End adjusting\\\\n                */\\\\n                if (RG.Registry.Get('chart.adjusting') || RG.Registry.Get('chart.adjusting.gantt')) {\\\\n                \\\\n                    var obj = RG.Registry.Get('chart.adjusting');\\\\n                \\\\n                    // If it's a line chart update the data_arr variable\\\\n                    if (obj && obj.type === 'line') {\\\\n                        obj.data_arr = RG.arrayLinearize(obj.data);\\\\n                    }\\\\n\\\\n                    RG.fireCustomEvent(RG.Registry.Get('chart.adjusting'), 'onadjustend');\\\\n                }\\\\n    \\\\n                RG.Registry.set('chart.adjusting', null);\\\\n                RG.Registry.set('chart.adjusting.shape', null);\\\\n                RG.Registry.set('chart.adjusting.gantt', null);\\\\n    \\\\n    \\\\n                // ==============================================\\\\n                // Finally, redraw the chart\\\\n                // ==============================================\\\\n\\\\n                var tags = document.getElementsByTagName('canvas');\\\\n                for (var i=0; i<tags.length; ++i) {\\\\n                    if (tags[i].__object__ && tags[i].__object__.isRGraph) {\\\\n                        if (!tags[i].__object__.get('chart.annotatable')) {\\\\n                            if (!tags[i].__rgraph_trace_cover__ && !noredraw) {\\\\n                                RG.clear(tags[i]);\\\\n                            } else {\\\\n                                var noredraw = true;\\\\n                            }\\\\n                        }\\\\n                    }\\\\n                }\\\\n    \\\\n                if (!noredraw) {\\\\n                    RG.redraw();\\\\n                }\\\\n            };\\\\n            win.addEventListener('mouseup', RG.window_mouseup_event_listener, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the canvas mouseup event listener. It installs the mouseup event for the\\\\n    * canvas. The mouseup event then checks the relevant object.\\\\n    * \\\\n    * @param object obj The chart object\\\\n    * \\\\n    * RGraph.window_mouseup_event_listener\\\\n    */\\\\n    RG.installCanvasMouseupListener =\\\\n    RG.InstallCanvasMouseupListener = function (obj)\\\\n    {\\\\n        if (!obj.canvas.rgraph_mouseup_event_listener) {\\\\n            obj.canvas.rgraph_mouseup_event_listener = function (e)\\\\n            {\\\\n                /**\\\\n                * For firefox add the window.event object\\\\n                */\\\\n                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;\\\\n    \\\\n                e = RG.fixEventObject(e);\\\\n    \\\\n    \\\\n                // *************************************************************************\\\\n                // Tooltips\\\\n                // *************************************************************************\\\\n    \\\\n    \\\\n                // This causes things at the edge of the chart area - eg line chart hotspots - not to fire because the\\\\n                // cursor is out of the chart area\\\\n                var objects = RG.ObjectRegistry.getObjectsByXY(e);\\\\n                //var objects = RG.ObjectRegistry.getObjectsByCanvasID(e.target.id);\\\\n\\\\n                if (objects) {\\\\n                    for (var i=0,len=objects.length; i<len; i+=1) {\\\\n                        \\\\n                        var obj = objects[i],\\\\n                            id  = objects[i].id;\\\\n\\\\n    \\\\n                        // =========================================================================\\\\n                        // The drawing API text object supports chart.link\\\\n                        // ========================================================================\\\\n                        var link = obj.Get('link');\\\\n                        \\\\n                        if (obj.type == 'drawing.text' && typeof link === 'string') {\\\\n\\\\n                            var link_target  = obj.get('link.target');\\\\n                            var link_options = obj.get('link.options');\\\\n\\\\n                            window.open(link, link_target ? link_target : null, link_options);\\\\n                        }\\\\n\\\\n    \\\\n                        // ========================================================================\\\\n                        // Tooltips\\\\n                        // ========================================================================\\\\n    \\\\n\\\\n                        if (!RG.isNull(obj) && RG.tooltip) {\\\\n    \\\\n                            var shape = obj.getShape(e);\\\\n\\\\n                            if (shape && shape['tooltip']) {\\\\n    \\\\n                                var text = shape['tooltip'];\\\\n    \\\\n                                if (text) {\\\\n\\\\n                                    var type = shape['object'].type;\\\\n    \\\\n                                    RG.clear(obj.canvas);\\\\n                                    RG.redraw();\\\\n                                    RG.Registry.set('chart.tooltip.shape', shape);\\\\n                                    \\\\n                                    // Note that tooltips are positioned at the pointer\\\\n                                    // now; and thats done within the .tooltip() function\\\\n                                    RG.tooltip(obj, text, 0, 0, shape['index'], e);\\\\n\\\\n                                    obj.highlight(shape);\\\\n\\\\n                                    // Add the shape that triggered the tooltip\\\\n                                    if (RG.Registry.get('chart.tooltip')) {\\\\n                                        \\\\n                                        RG.Registry.get('chart.tooltip').__shape__ = shape;\\\\n    \\\\n                                        RG.evaluateCursor(e);\\\\n                                    }\\\\n    \\\\n                                    e.cancelBubble = true;\\\\n                                    e.stopPropagation();\\\\n                                    return false;\\\\n                                }\\\\n                            }\\\\n                        }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n    \\\\n                        // =========================================================================\\\\n                        // Adjusting\\\\n                        // ========================================================================\\\\n        \\\\n        \\\\n        \\\\n                        if (RG.Registry.get('chart.adjusting') || RG.Registry.get('chart.adjusting.gantt')) {\\\\n\\\\n                        //var obj = RG.Registry.get('chart.adjusting');\\\\n                    \\\\n                        // If it's a line chart update the data_arr variable\\\\n                        if (obj && obj.type === 'line') {\\\\n                            obj.data_arr = RG.arrayLinearize(obj.data);\\\\n                        }\\\\n\\\\n                            RG.fireCustomEvent(RG.Registry.get('chart.adjusting'), 'onadjustend');\\\\n                        }\\\\n        \\\\n                        RG.Registry.set('chart.adjusting', null);\\\\n                        RG.Registry.set('chart.adjusting.shape', null);\\\\n                        RG.Registry.set('chart.adjusting.gantt', null);\\\\n    \\\\n                        /**\\\\n                        * If the mouse pointer is over a \\\\\\\"front\\\\\\\" chart this prevents charts behind it\\\\n                        * from firing their events.\\\\n                        */\\\\n                        if (shape || (obj.overChartArea && obj.overChartArea(e)) ) {\\\\n                            break;\\\\n                        }\\\\n                    }\\\\n                }\\\\n            };\\\\n            obj.canvas.addEventListener('mouseup', obj.canvas.rgraph_mouseup_event_listener, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the canvas mousemove event listener.\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.installCanvasMousemoveListener =\\\\n    RG.InstallCanvasMousemoveListener = function (obj)\\\\n    {\\\\n        if (!obj.canvas.rgraph_mousemove_event_listener) {\\\\n            obj.canvas.rgraph_mousemove_event_listener = function (e)\\\\n            {\\\\n\\\\n                /**\\\\n                * For firefox add the window.event object\\\\n                */\\\\n                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;\\\\n                e = RG.fixEventObject(e);\\\\n\\\\n    \\\\n    \\\\n    \\\\n                /**\\\\n                * Go through all the objects and check them to see if anything needs doing\\\\n                */\\\\n                var objects = RG.OR.getObjectsByXY(e);\\\\n\\\\n                // Necessary to track which objects have had the mouseover\\\\n                // triggered on them\\\\n                var uids = [];\\\\n\\\\n                if (objects && objects.length > 0) {\\\\n\\\\n                    for (var i=0,len=objects.length; i<len; i+=1) {\\\\n\\\\n                        var obj = objects[i];\\\\n                        var id  = obj.id;\\\\n\\\\n\\\\n                        // Record the uid\\\\n                        uids[obj.uid] = true;\\\\n\\\\n\\\\n                        if (!obj.getShape) {\\\\n                            continue;\\\\n                        }\\\\n    \\\\n\\\\n                        var shape = obj.getShape(e);\\\\n                        \\\\n                        // Fire the onmouseout event if necessary\\\\n                        if (\\\\n                            (!shape && typeof obj.__mouseover_shape_index__ === 'number') ||\\\\n                            (shape && typeof obj.__mouseover_shape_index__ === 'number' && shape.index !== obj.__mouseover_shape_index__)\\\\n                            ) {\\\\n                            \\\\n                            RG.fireCustomEvent(obj, 'onmouseout');\\\\n                        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n                        //\\\\n                        // If the mouse is over a key element add the details\\\\n                        // of it to the Registry\\\\n                        //\\\\n                        if (obj.coords && obj.coords.key && obj.coords.key.length) {\\\\n                            \\\\n                            var mouseXY = RG.getMouseXY(e);\\\\n    \\\\n                            for (var i=0,overkey=false; i<obj.coords.key.length; ++i) {\\\\n                                        \\\\n                                if (\\\\n                                       mouseXY[0] >= obj.coords.key[i][0]\\\\n                                    && mouseXY[0] <= (obj.coords.key[i][0] + obj.coords.key[i][2])\\\\n                                    && mouseXY[1] >= obj.coords.key[i][1]\\\\n                                    && mouseXY[1] <= (obj.coords.key[i][1] + obj.coords.key[i][3])\\\\n                                   ) {\\\\n    \\\\n                                    RG.Registry.set('key-element', obj.coords.key[i]);\\\\n                                    overkey = true;\\\\n                                }\\\\n\\\\n                                if (!overkey) {\\\\n                                    RG.Registry.set('key-element', null);\\\\n                                }\\\\n                            }\\\\n                        }\\\\n\\\\n\\\\n\\\\n\\\\n                        // ================================================================================================ //\\\\n                        // This facilitates the chart.events.mousemove option\\\\n                        // ================================================================================================ //\\\\n                        \\\\n                        var func = obj.get('chart.events.mousemove');\\\\n    \\\\n                        if (!func && typeof obj.onmousemove == 'function') {\\\\n                            var func = obj.onmousemove;\\\\n                        }\\\\n\\\\n                        /**\\\\n                        * \\\\n                        */\\\\n                        if (shape) {\\\\n                            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];\\\\n                            if (typeof(obj['\\\\\\\$' + index]) == 'object' && typeof(obj['\\\\\\\$' + index].onmousemove) == 'function') {\\\\n                                var func2 = obj['\\\\\\\$' + index].onmousemove;\\\\n                            }\\\\n                        }\\\\n\\\\n                        /**\\\\n                        * This bit saves the current pointer style if there isn't one already saved\\\\n                        */\\\\n                        if (shape && (typeof(func) == 'function' || typeof(func2) == 'function' || typeof obj.Get('link') === 'string')) {\\\\n\\\\n                            if (obj.Get('chart.events.mousemove.revertto') == null) {\\\\n                                obj.Set('chart.events.mousemove.revertto', e.target.style.cursor);\\\\n                            }\\\\n\\\\n                            if (typeof(func)  == 'function')  RGraph.custom_events_mousemove_pointer = func(e, shape);\\\\n                            if (typeof(func2) == 'function') RGraph.custom_events_mousemove_pointer  = RGraph.custom_events_mousemove_pointer || func2(e, shape);\\\\n\\\\n                            // Go through the RGraph.events array looking for more\\\\n                            // event listeners\\\\n                            if (   typeof RG.events === 'object'\\\\n                                && typeof RG.events[obj.uid] === 'object') {\\\\n                                \\\\n                                for (i in RG.events[obj.uid]) {\\\\n                                \\\\n                                    if (   typeof i === 'string'\\\\n                                        && typeof RG.events[obj.uid][i] === 'object'\\\\n                                        && RG.events[obj.uid][i][1] === 'onmousemove'\\\\n                                        && typeof RG.events[obj.uid][i][2] === 'function') {\\\\n                                        \\\\n                                        (RG.events[obj.uid][i][2])(obj);\\\\n                                    }\\\\n                                }\\\\n                            }\\\\n                            //return;\\\\n    \\\\n                        } else if (typeof(obj.Get('chart.events.mousemove.revertto')) == 'string') {\\\\n            \\\\n                            RG.cursor.push('default');\\\\n                            obj.Set('chart.events.mousemove.revertto', null);\\\\n                        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n                        // ======================================================\\\\n                        // This bit of code facilitates the onmouseover event\\\\n                        // ======================================================\\\\n\\\\n\\\\n\\\\n                        var func = obj.properties['chart.events.mouseover'];\\\\n\\\\n                        if (!func && typeof obj.onmouseover === 'function') {\\\\n                            func = obj.onmouseover;\\\\n                        }\\\\n\\\\n\\\\n                        // Allow for individually index functions to be specified\\\\n                        if (shape) {\\\\n                        \\\\n                            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];\\\\n\\\\n                            if (typeof(obj['\\\\\\\$' + index]) == 'object' && typeof(obj['\\\\\\\$' + index].onmouseover) == 'function') {\\\\n                                var func2 = obj['\\\\\\\$' + index].onmouseover;\\\\n                            }\\\\n                        } else {\\\\n\\\\n                            obj.__mouseover_shape_index__ = null;\\\\n                            RG.__mouseover_objects__      = [];\\\\n                        }\\\\n\\\\n                        if (typeof RG.__mouseover_objects__ === 'undefined') {\\\\n                            RG.__mouseover_objects__ = [];\\\\n                        }\\\\n\\\\n\\\\n                        if (shape) {\\\\n                            if ((obj.__mouseover_shape_index__ === shape.index) === false) {\\\\n\\\\n                                obj.__mouseover_shape_index__ = shape.index;\\\\n                                RG.__mouseover_objects__.push(obj);\\\\n\\\\n                                if (func) func(e, shape);\\\\n                                if (func2) func2(e, shape);\\\\n\\\\n                                // Go through the RGraph.events array looking for more\\\\n                                // event listeners\\\\n                                if (   typeof RG.events === 'object'\\\\n                                    && typeof RG.events[obj.uid] === 'object') {\\\\n                                    \\\\n                                    for (i in RG.events[obj.uid]) {\\\\n                                    \\\\n                                        if (   typeof i === 'string'\\\\n                                            && typeof RG.events[obj.uid][i] === 'object'\\\\n                                            && RG.events[obj.uid][i][1] === 'onmouseover'\\\\n                                            && typeof RG.events[obj.uid][i][2] === 'function') {\\\\n                                            \\\\n                                            (RG.events[obj.uid][i][2])(obj);\\\\n                                        }\\\\n                                    }\\\\n                                }\\\\n                            }\\\\n                        } else {\\\\n                            obj.__mouseover_shape_index__ = null;\\\\n                            RG.__mouseover_objects__      = [];\\\\n                        }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n                        // ================================================================================================ //\\\\n                        // Tooltips\\\\n                        // ================================================================================================ //\\\\n                        var current_tooltip = RG.Registry.get('chart.tooltip');\\\\n                        var tooltips        = obj.get('chart.tooltips');\\\\n                        var tooltips_event  = obj.Get('chart.tooltips.event');\\\\n\\\\n\\\\n                        if (   shape\\\\n                            && (tooltips && tooltips[shape['index']] || shape['tooltip'])\\\\n                            && tooltips_event.indexOf('mousemove')  !== -1\\\\n                            && (   RG.isNull(current_tooltip) // Is there a tooltip being shown?\\\\n                                || obj.uid != current_tooltip.__object__.uid // Same object?\\\\n                                || (current_tooltip.__index__ != shape['index']) // Same tooltip index?\\\\n                                || (typeof shape['dataset'] === 'number' && shape['dataset'] != current_tooltip.__shape__['dataset'])\\\\n                                )\\\\n                           ) {\\\\n\\\\n                            RG.clear(obj.canvas);\\\\n                            RG.hideTooltip();\\\\n                            RG.redraw();\\\\n                            obj.canvas.rgraph_mouseup_event_listener(e);\\\\n    \\\\n                            return;\\\\n                        }\\\\n            \\\\n            \\\\n                        // ================================================================================================ //\\\\n                        // Adjusting\\\\n                        // ================================================================================================ //\\\\n            \\\\n\\\\n                        if (obj && obj.get('chart.adjustable')) {\\\\n                            obj.Adjusting_mousemove(e);\\\\n                        }\\\\n                    \\\\n    \\\\n                        /**\\\\n                        * This facilitates breaking out of the loop when a shape has been found - \\\\n                        * ie the cursor is over a shape an upper chart\\\\n                        */\\\\n                        if (shape || (obj.overChartArea && obj.overChartArea(e) )) {\\\\n                            break;\\\\n                        }\\\\n                    }\\\\n                    \\\\n                    //\\\\n                    // For all objects that are NOT mouseover'ed, reset the\\\\n                    // mouseover flag back to null\\\\n                    //\\\\n                    var objects = RG.OR.getObjectsByCanvasID(e.target.id);\\\\n\\\\n                    for (var i=0; i<objects.length; ++i) {\\\\n                        if (!uids[objects[i].uid]) {\\\\n                            objects[i].__mouseover_shape_index__ = null;\\\\n                        }\\\\n                    }\\\\n\\\\n                } else {\\\\n\\\\n                    // Reset the mouseover flag on all of this canvas tags objects\\\\n                    var objects = RG.OR.getObjectsByCanvasID(e.target.id);\\\\n\\\\n                    for (var i=0; i<objects.length; i++) {\\\\n\\\\n                        if (typeof objects[i].__mouseover_shape_index__ === 'number') {\\\\n                            RG.fireCustomEvent(objects[i], 'onmouseout');\\\\n                        }\\\\n\\\\n                        objects[i].__mouseover_shape_index__ = null;\\\\n                    }\\\\n\\\\n                    RG.__mouseover_objects__ = [];\\\\n                }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n                // ================================================================================================ //\\\\n                // Crosshairs\\\\n                // ================================================================================================ //\\\\n    \\\\n\\\\n                if (e.target && e.target.__object__ && e.target.__object__.get('chart.crosshairs')) {\\\\n                    RG.drawCrosshairs(e, e.target.__object__);\\\\n                }\\\\n            \\\\n            \\\\n                // ================================================================================================ //\\\\n                // Interactive key No LONGER REQUIRED\\\\n                // ================================================================================================ //\\\\n    \\\\n    \\\\n                //if (typeof InteractiveKey_line_mousemove == 'function') InteractiveKey_line_mousemove(e);\\\\n                //if (typeof InteractiveKey_pie_mousemove == 'function') InteractiveKey_pie_mousemove(e);\\\\n    \\\\n    \\\\n                // ================================================================================================ //\\\\n                // Annotating\\\\n                // ================================================================================================ //\\\\n    \\\\n    \\\\n                if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousemove) {\\\\n                    RG.annotating_canvas_onmousemove(e);\\\\n                }\\\\n    \\\\n    \\\\n    \\\\n                /**\\\\n                * Determine the pointer\\\\n                */\\\\n                RG.evaluateCursor(e);\\\\n            };\\\\n            obj.canvas.addEventListener('mousemove', obj.canvas.rgraph_mousemove_event_listener, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the canvas mousedown event listener.\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.installCanvasMousedownListener =\\\\n    RG.InstallCanvasMousedownListener = function (obj)\\\\n    {\\\\n        if (!obj.canvas.rgraph_mousedown_event_listener) {\\\\n            obj.canvas.rgraph_mousedown_event_listener = function (e)\\\\n            {\\\\n                /**\\\\n                * For firefox add the window.event object\\\\n                */\\\\n                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;\\\\n                \\\\n                e = RG.fixEventObject(e);\\\\n\\\\n    \\\\n                /**\\\\n                * Annotating\\\\n                */\\\\n                if (e.target.__object__ && e.target.__object__.get('chart.annotatable') && RG.annotating_canvas_onmousedown) {\\\\n                    RG.annotating_canvas_onmousedown(e);\\\\n                    return;\\\\n                }\\\\n    \\\\n                var obj = RG.ObjectRegistry.getObjectByXY(e);\\\\n\\\\n                if (obj) {\\\\n\\\\n                    var id = obj.id;\\\\n                    \\\\n\\\\n\\\\n                    /*************************************************************\\\\n                    * Handle adjusting for all object types\\\\n                    *************************************************************/\\\\n                    if (obj && obj.isRGraph && obj.get('chart.adjustable')) {\\\\n\\\\n                        /**\\\\n                        * Check the cursor is in the correct area\\\\n                        */\\\\n                        var obj = RG.OR.getObjectByXY(e);\\\\n    \\\\n                        if (obj && obj.isRGraph) {\\\\n                        \\\\n                            // If applicable, get the appropriate shape and store it in the registry\\\\n                            switch (obj.type) {\\\\n                                case 'bar':   var shape = obj.getShapeByX(e); break;\\\\n                                case 'gantt':\\\\n                                    \\\\n                                    var shape = obj.getShape(e);\\\\n                                    var data = typeof shape.subindex === 'number' ?  obj.data[shape.index][shape.subindex] : obj.data[shape.index];\\\\n\\\\n                                    if (shape) {\\\\n\\\\n                                        var mouseXY = RG.getMouseXY(e);\\\\n\\\\n                                        RG.Registry.set('chart.adjusting.gantt', {\\\\n                                            index: shape.index,\\\\n                                            subindex: shape.subindex,\\\\n                                            object: obj,\\\\n                                            mousex: mouseXY[0],\\\\n                                            mousey: mouseXY[1],\\\\n                                            event: data,\\\\n                                            event_start: data[0],\\\\n                                            event_duration: data[1],\\\\n                                            mode: (mouseXY[0] > (shape['x'] + shape['width'] - 5) ? 'resize' : 'move'),\\\\n                                            shape: shape\\\\n                                        });\\\\n                                    }\\\\n                                    break;\\\\n                                case 'line':  var shape = obj.getShape(e); break;\\\\n                                case 'hbar':  var shape = obj.getShapeByY(e); break;\\\\n                                default:      var shape = null;\\\\n                            }\\\\n                            \\\\n                            //\\\\n                            // Added 30/9/2016\\\\n                            // Now check the index in the chart.adjusting.limitto property\\\\n                            // If that property is an object and the appropriate index is\\\\n                            // truthy then allow adjusting, otherwise don't.\\\\n                            //\\\\n                            if (\\\\n                                   RG.isNull(obj.properties['chart.adjustable.only'])\\\\n                                || typeof obj.properties['chart.adjustable.only'] === 'undefined'\\\\n                                ||\\\\n                                   (\\\\n                                       RG.isArray(obj.properties['chart.adjustable.only'])\\\\n                                    && obj.isAdjustable\\\\n                                    && obj.isAdjustable(shape)\\\\n                                   )\\\\n                               ) {\\\\n\\\\n                                RG.Registry.set('chart.adjusting.shape', shape);\\\\n    \\\\n        \\\\n                                // Fire the onadjustbegin event\\\\n                                RG.fireCustomEvent(obj, 'onadjustbegin');\\\\n        \\\\n                                RG.Registry.set('chart.adjusting', obj);\\\\n            \\\\n        \\\\n                                // Liberally redraw the canvas\\\\n                                RG.clear(obj.canvas);\\\\n                                RG.redraw();\\\\n            \\\\n                                // Call the mousemove event listener so that the canvas\\\\n                                // is adjusted even though the mouse isn't moved\\\\n                                obj.canvas.rgraph_mousemove_event_listener(e);\\\\n                            }\\\\n                        }\\\\n                    }\\\\n    \\\\n    \\\\n                    RG.clear(obj.canvas);\\\\n                    RG.redraw();\\\\n                }\\\\n            };\\\\n            obj.canvas.addEventListener('mousedown', obj.canvas.rgraph_mousedown_event_listener, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This is the canvas click event listener. Used by the pseudo event listener\\\\n    * \\\\n    * @param object obj The chart object\\\\n    */\\\\n    RG.installCanvasClickListener =\\\\n    RG.InstallCanvasClickListener = function (obj)\\\\n    {\\\\n        if (!obj.canvas.rgraph_click_event_listener) {\\\\n            obj.canvas.rgraph_click_event_listener = function (e)\\\\n            {\\\\n                /**\\\\n                * For firefox add the window.event object\\\\n                */\\\\n                if (navigator.userAgent.indexOf('Firefox') >= 0) window.event = e;\\\\n                \\\\n                e = RG.fixEventObject(e);\\\\n    \\\\n                var objects = RG.ObjectRegistry.getObjectsByXY(e);\\\\n\\\\n                for (var i=0,len=objects.length; i<len; i+=1) {\\\\n\\\\n                    var obj   = objects[i];\\\\n                    var id    = obj.id;\\\\n                    var shape = obj.getShape(e);\\\\n\\\\n                    /**\\\\n                    * This bit saves the current pointer style if there isn't one already saved\\\\n                    */\\\\n                    var func = obj.get('chart.events.click');\\\\n                    \\\\n                    if (!func && typeof(obj.onclick) == 'function') {\\\\n                        func = obj.onclick;\\\\n                    }\\\\n\\\\n                    if (shape && typeof func == 'function') {\\\\n\\\\n                        func(e, shape);\\\\n\\\\n                        // Go through the RGraph.events array looking for more\\\\n                        // event listeners\\\\n\\\\n                        if (   typeof RG.events === 'object'\\\\n                            && typeof RG.events[obj.uid] === 'object') {\\\\n\\\\n                            for (i in RG.events[obj.uid]) {\\\\n\\\\n                                if (   typeof i === 'string'\\\\n                                    && typeof RG.events[obj.uid][i] === 'object'\\\\n                                    && RG.events[obj.uid][i][1] === 'onclick'\\\\n                                    && typeof RG.events[obj.uid][i][2] === 'function') {\\\\n                                    \\\\n                                    (RG.events[obj.uid][i][2])(obj);\\\\n                                }\\\\n                            }\\\\n                        }\\\\n                        \\\\n                        /**\\\\n                        * If objects are layered on top of each other this return\\\\n                        * stops objects underneath from firing once the \\\\\\\"top\\\\\\\"\\\\n                        * objects user event has fired\\\\n                        */\\\\n                        return;\\\\n                    }\\\\n                    \\\\n                    \\\\n                    \\\\n                    //\\\\n                    // Handle the key click event\\\\n                    //\\\\n                    var key = RG.Registry.get('key-element');\\\\n                    if (key) {\\\\n                        RG.fireCustomEvent(obj, 'onkeyclick');\\\\n                    }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n                    /**\\\\n                    * The property takes priority over this.\\\\n                    */\\\\n                    if (shape) {\\\\n    \\\\n                        var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];\\\\n        \\\\n                        if (typeof(index) == 'number' && obj['\\\\\\\$' + index]) {\\\\n                            \\\\n                            var func = obj['\\\\\\\$' + index].onclick;\\\\n\\\\n                            if (typeof(func) == 'function') {\\\\n                                \\\\n                                func(e, shape);\\\\n                                \\\\n                                /**\\\\n                                * If objects are layered on top of each other this return\\\\n                                * stops objects underneath from firing once the \\\\\\\"top\\\\\\\"\\\\n                                * objects user event has fired\\\\n                                */\\\\n                                return;\\\\n                            }\\\\n                        }\\\\n                    }\\\\n                    \\\\n                    /**\\\\n                    * This facilitates breaking out of the loop when a shape has been found - \\\\n                    * ie the cursor is over a shape an upper chart\\\\n                    */\\\\n                    if (shape || (obj.overChartArea && obj.overChartArea(e)) ) {\\\\n                        break;\\\\n                    }\\\\n                }\\\\n            };\\\\n            obj.canvas.addEventListener('click', obj.canvas.rgraph_click_event_listener, false);\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function evaluates the various cursor settings and if there's one for pointer, changes it to that\\\\n    */\\\\n    RG.evaluateCursor =\\\\n    RG.EvaluateCursor = function (e)\\\\n    {\\\\n        var obj     = null;\\\\n        var mouseXY = RG.getMouseXY(e);\\\\n        var mouseX  = mouseXY[0];\\\\n        var mouseY  = mouseXY[1];\\\\n        var canvas  = e.target;\\\\n\\\\n        /**\\\\n        * Tooltips cause the mouse pointer to change\\\\n        */\\\\n        var objects = RG.OR.getObjectsByCanvasID(canvas.id);\\\\n        \\\\n        for (var i=0,len=objects.length; i<len; i+=1) {\\\\n            if ((objects[i].getShape && objects[i].getShape(e)) || (objects[i].overChartArea && objects[i].overChartArea(e))) {\\\\n                var obj = objects[i];\\\\n                var id  = obj.id;\\\\n            }\\\\n        }\\\\n\\\\n        if (!RG.isNull(obj)) {\\\\n            if (obj.getShape && obj.getShape(e)) {\\\\n\\\\n                var shape = obj.getShape(e);\\\\n\\\\n                if (obj.get('chart.tooltips')) {\\\\n\\\\n                    var text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index']);\\\\n                    \\\\n                    if (!text && shape['object'].type == 'scatter' && shape['index_adjusted']) {\\\\n                        text = RG.parseTooltipText(obj.get('chart.tooltips'), shape['index_adjusted']);\\\\n                    }\\\\n\\\\n                    /**\\\\n                    * This essentially makes front charts \\\\\\\"hide\\\\\\\" the back charts\\\\n                    */\\\\n                    if (text) {\\\\n                        var pointer = true;\\\\n                    }\\\\n                }\\\\n            }\\\\n\\\\n            /**\\\\n            * Now go through the key coords and see if it's over that.\\\\n            */\\\\n            if (!RG.isNull(obj) && obj.Get('chart.key.interactive')) {\\\\n                for (var j=0; j<obj.coords.key.length; ++j) {\\\\n                    if (mouseX > obj.coords.key[j][0] && mouseX < (obj.coords.key[j][0] + obj.coords.key[j][2]) && mouseY > obj.coords.key[j][1] && mouseY < (obj.coords.key[j][1] + obj.coords.key[j][3])) {\\\\n                        var pointer = true;\\\\n                    }\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        /**\\\\n        * It can be specified in the user mousemove event - remember it can now\\\\n        * be specified in THREE ways\\\\n        */\\\\n        if (RGraph.custom_events_mousemove_pointer) {\\\\n            var pointer = true;\\\\n            RGraph.custom_events_mousemove_pointer = false;\\\\n        }\\\\n        /*\\\\n\\\\n            \\\\n            var index = shape['object'].type == 'scatter' ? shape['index_adjusted'] : shape['index'];\\\\n            if (!RG.isNull(obj['\\\\\\\$' + index]) && typeof(obj['\\\\\\\$' + index].onmousemove) == 'function') {\\\\n                var str = (obj['\\\\\\\$' + index].onmousemove).toString();\\\\n                if (str.match(/pointer/) && str.match(/cursor/) && str.match(/style/)) { \\\\n                    var pointer = true;\\\\n                }\\\\n            }\\\\n        }\\\\n        */\\\\n\\\\n        /**\\\\n        * Is the chart resizable? Go through all the objects again\\\\n        */\\\\n        var objects = RG.OR.objects.byCanvasID;\\\\n\\\\n        for (var i=0,len=objects.length; i<len; i+=1) {\\\\n            if (objects[i] && objects[i][1].Get('chart.resizable')) {\\\\n                var resizable = true;\\\\n            }\\\\n        }\\\\n\\\\n        if (resizable && mouseX > (e.target.width - 32) && mouseY > (e.target.height - 16)) {\\\\n            pointer = true;\\\\n        }\\\\n\\\\n\\\\n        if (pointer) {\\\\n            e.target.style.cursor = 'pointer';\\\\n        } else if (e.target.style.cursor == 'pointer') {\\\\n            e.target.style.cursor = 'default';\\\\n        } else {\\\\n            e.target.style.cursor = null;\\\\n        }\\\\n\\\\n        \\\\n\\\\n        // =========================================================================\\\\n        // Resize cursor - check mouseis in bottom left corner and if it is change it\\\\n        // =========================================================================\\\\n\\\\n\\\\n        if (resizable && mouseX >= (e.target.width - 15) && mouseY >= (e.target.height - 15)) {\\\\n            e.target.style.cursor = 'move';\\\\n        \\\\n        } else if (e.target.style.cursor === 'move') {\\\\n            e.target.style.cursor = 'default';\\\\n        }\\\\n\\\\n\\\\n        // =========================================================================\\\\n        // Interactive key\\\\n        // =========================================================================\\\\n\\\\n\\\\n\\\\n        if (typeof mouse_over_key == 'boolean' && mouse_over_key) {\\\\n            e.target.style.cursor = 'pointer';\\\\n        }\\\\n\\\\n        \\\\n        // =========================================================================\\\\n        // Gantt chart adjusting\\\\n        // =========================================================================\\\\n\\\\n        //if (obj && obj.type == 'gantt' && obj.get('chart.adjustable')) {\\\\n        //    if (obj.getShape && obj.getShape(e)) {\\\\n        //        e.target.style.cursor = 'ew-resize';\\\\n        //    } else {\\\\n        //        e.target.style.cursor = 'default';\\\\n        //    }\\\\n        //} else if (!obj || !obj.type) {\\\\n        //    e.target.style.cursor = cursor;\\\\n        //}\\\\n\\\\n        \\\\n        // =========================================================================\\\\n        // Line chart adjusting\\\\n        // =========================================================================\\\\n\\\\n\\\\n        if (obj && obj.type == 'line' && obj.get('chart.adjustable')) {\\\\n            if (obj.getShape) {\\\\n\\\\n                var shape = obj.getShape(e);\\\\n\\\\n                if (shape && obj.isAdjustable(shape)) {\\\\n                    e.target.style.cursor = 'ns-resize';\\\\n                }\\\\n            } else {\\\\n                e.target.style.cursor = 'default';\\\\n            }\\\\n        }\\\\n\\\\n        \\\\n        // =========================================================================\\\\n        // Annotatable\\\\n        // =========================================================================\\\\n\\\\n\\\\n        if (e.target.__object__ && e.target.__object__.get('chart.annotatable')) {\\\\n            e.target.style.cursor = 'crosshair';\\\\n        }\\\\n\\\\n        \\\\n        // =========================================================================\\\\n        // Drawing API link\\\\n        // =========================================================================\\\\n\\\\n\\\\n        if (obj && obj.type === 'drawing.text' && shape && typeof obj.get('link') === 'string') {\\\\n            e.target.style.cursor = 'pointer';\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * This function handles the tooltip text being a string, function\\\\n    * \\\\n    * @param mixed tooltip This could be a string or a function. If it's a function it's called and\\\\n    *                       the return value is used as the tooltip text\\\\n    * @param numbr idx The index of the tooltip.\\\\n    */\\\\n    RG.parseTooltipText = function (tooltips, idx)\\\\n    {\\\\n        // No tooltips\\\\n        if (!tooltips) {\\\\n            return null;\\\\n        }\\\\n\\\\n        // Get the tooltip text\\\\n        if (typeof tooltips == 'function') {\\\\n            var text = tooltips(idx);\\\\n\\\\n        // A single tooltip. Only supported by the Scatter chart\\\\n        } else if (typeof tooltips == 'string') {\\\\n            var text = tooltips;\\\\n\\\\n        } else if (typeof tooltips == 'object' && typeof tooltips[idx] == 'function') {\\\\n            var text = tooltips[idx](idx);\\\\n\\\\n        } else if (typeof tooltips[idx] == 'string' && tooltips[idx]) {\\\\n            var text = tooltips[idx];\\\\n\\\\n        } else {\\\\n            var text = '';\\\\n        }\\\\n\\\\n        if (text == 'undefined') {\\\\n            text = '';\\\\n        } else if (text == 'null') {\\\\n            text = '';\\\\n        }\\\\n\\\\n        // Conditional in case the tooltip file isn't included\\\\n        return RG.getTooltipTextFromDIV ? RG.getTooltipTextFromDIV(text) : text;\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    /**\\\\n    * Draw crosshairs if enabled\\\\n    * \\\\n    * @param object obj The graph object (from which we can get the context and canvas as required)\\\\n    */\\\\n    RG.drawCrosshairs =\\\\n    RG.DrawCrosshairs = function (e, obj)\\\\n    {\\\\n        var e            = RG.fixEventObject(e),\\\\n            width        = obj.canvas.width,\\\\n            height       = obj.canvas.height,\\\\n            mouseXY      = RG.getMouseXY(e),\\\\n            x            = mouseXY[0],\\\\n            y            = mouseXY[1],\\\\n            gutterLeft   = obj.gutterLeft,\\\\n            gutterRight  = obj.gutterRight,\\\\n            gutterTop    = obj.gutterTop,\\\\n            gutterBottom = obj.gutterBottom,\\\\n            Mathround    = Math.round,\\\\n            prop         = obj.properties,\\\\n            co           = obj.context,\\\\n            ca           = obj.canvas\\\\n\\\\n        RG.redrawCanvas(ca);\\\\n\\\\n        if (   x >= gutterLeft\\\\n            && y >= gutterTop\\\\n            && x <= (width - gutterRight)\\\\n            && y <= (height - gutterBottom)\\\\n           ) {\\\\n\\\\n            var linewidth = prop['chart.crosshairs.linewidth'] ? prop['chart.crosshairs.linewidth'] : 1;\\\\n            co.lineWidth = linewidth ? linewidth : 1;\\\\n\\\\n            co.beginPath();\\\\n            co.strokeStyle = prop['chart.crosshairs.color'];\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * The chart.crosshairs.snap option\\\\n            */\\\\n            if (prop['chart.crosshairs.snap']) {\\\\n            \\\\n                // Linear search for the closest point\\\\n                var point = null;\\\\n                var dist  = null;\\\\n                var len   = null;\\\\n                \\\\n                if (obj.type == 'line') {\\\\n            \\\\n                    for (var i=0; i<obj.coords.length; ++i) {\\\\n                    \\\\n                        var length = RG.getHypLength(obj.coords[i][0], obj.coords[i][1], x, y);\\\\n            \\\\n                        // Check the mouse X coordinate\\\\n                        if (typeof dist != 'number' || length < dist) {\\\\n                            var point = i;\\\\n                            var dist = length;\\\\n                        }\\\\n                    }\\\\n                \\\\n                    x = obj.coords[point][0];\\\\n                    y = obj.coords[point][1];\\\\n                    \\\\n                    // Get the dataset\\\\n                    for (var dataset=0; dataset<obj.coords2.length; ++dataset) {\\\\n                        for (var point=0; point<obj.coords2[dataset].length; ++point) {\\\\n                            if (obj.coords2[dataset][point][0] == x && obj.coords2[dataset][point][1] == y) {\\\\n                                ca.__crosshairs_snap_dataset__ = dataset;\\\\n                                ca.__crosshairs_snap_point__   = point;\\\\n                            }\\\\n                        }\\\\n                    }\\\\n\\\\n                } else {\\\\n            \\\\n                    for (var i=0; i<obj.coords.length; ++i) {\\\\n                        for (var j=0; j<obj.coords[i].length; ++j) {\\\\n                            \\\\n                            // Check the mouse X coordinate\\\\n                            var len = RG.getHypLength(obj.coords[i][j][0], obj.coords[i][j][1], x, y);\\\\n            \\\\n                            if (typeof(dist) != 'number' || len < dist) {\\\\n            \\\\n                                var dataset = i;\\\\n                                var point   = j;\\\\n                                var dist   = len;\\\\n                            }\\\\n                        }\\\\n            \\\\n                    }\\\\n                    ca.__crosshairs_snap_dataset__ = dataset;\\\\n                    ca.__crosshairs_snap_point__   = point;\\\\n\\\\n            \\\\n                    x = obj.coords[dataset][point][0];\\\\n                    y = obj.coords[dataset][point][1];\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            // Draw a top vertical line\\\\n            if (prop['chart.crosshairs.vline']) {\\\\n                co.moveTo(Mathround(x), Mathround(gutterTop));\\\\n                co.lineTo(Mathround(x), Mathround(height - gutterBottom));\\\\n            }\\\\n\\\\n            // Draw a horizontal line\\\\n            if (prop['chart.crosshairs.hline']) {\\\\n                co.moveTo(Mathround(gutterLeft), Mathround(y));\\\\n                co.lineTo(Mathround(width - gutterRight), Mathround(y));\\\\n            }\\\\n\\\\n            co.stroke();\\\\n            \\\\n            \\\\n            /**\\\\n            * Need to show the coords?\\\\n            */\\\\n            if (obj.type == 'scatter' && prop['chart.crosshairs.coords']) {\\\\n\\\\n                var xCoord = (((x - gutterLeft) / (width - gutterLeft - gutterRight)) * (prop['chart.xmax'] - prop['chart.xmin'])) + prop['chart.xmin'];\\\\n                    xCoord = xCoord.toFixed(prop['chart.scale.decimals']);\\\\n                var yCoord = obj.max - (((y - prop['chart.gutter.top']) / (height - gutterTop - gutterBottom)) * obj.max);\\\\n\\\\n                if (obj.type == 'scatter' && obj.properties['chart.xaxispos'] == 'center') {\\\\n                    yCoord = (yCoord - (obj.max / 2)) * 2;\\\\n                }\\\\n\\\\n                yCoord = yCoord.toFixed(prop['chart.scale.decimals']);\\\\n\\\\n                var div      = RG.Registry.get('chart.coordinates.coords.div');\\\\n                var mouseXY  = RG.getMouseXY(e);\\\\n                var canvasXY = RG.getCanvasXY(ca);\\\\n                \\\\n                if (!div) {\\\\n                    var div = document.createElement('DIV');\\\\n                        div.__object__               = obj;\\\\n                        div.style.position           = 'absolute';\\\\n                        div.style.backgroundColor    = 'white';\\\\n                        div.style.border             = '1px solid black';\\\\n                        div.style.fontFamily         = 'Arial, Verdana, sans-serif';\\\\n                        div.style.fontSize           = '10pt'\\\\n                        div.style.padding            = '2px';\\\\n                        div.style.opacity            = 1;\\\\n                        div.style.WebkitBorderRadius = '3px';\\\\n                        div.style.borderRadius       = '3px';\\\\n                        div.style.MozBorderRadius    = '3px';\\\\n                    document.body.appendChild(div);\\\\n                    \\\\n                    RG.Registry.set('chart.coordinates.coords.div', div);\\\\n                }\\\\n\\\\n                // Convert the X/Y pixel coords to correspond to the scale\\\\n                div.style.opacity = 1;\\\\n                div.style.display = 'inline';\\\\n\\\\n                if (!prop['chart.crosshairs.coords.fixed']) {\\\\n                    div.style.left = ma.max(2, (e.pageX - div.offsetWidth - 3)) + 'px';\\\\n                    div.style.top = ma.max(2, (e.pageY - div.offsetHeight - 3))  + 'px';\\\\n                } else {\\\\n                    div.style.left = canvasXY[0] + gutterLeft + 3 + 'px';\\\\n                    div.style.top  = canvasXY[1] + gutterTop + 3 + 'px';\\\\n                }\\\\n\\\\n                div.innerHTML = '<span style=\\\\\\\"color: #666\\\\\\\">' + prop['chart.crosshairs.coords.labels.x'] + ':</span> ' + xCoord + '<br><span style=\\\\\\\"color: #666\\\\\\\">' + prop['chart.crosshairs.coords.labels.y'] + ':</span> ' + yCoord;\\\\n\\\\n                obj.canvas.addEventListener('mouseout', RG.hideCrosshairCoords, false);\\\\n\\\\n                ca.__crosshairs_labels__ = div;\\\\n                ca.__crosshairs_x__ = xCoord;\\\\n                ca.__crosshairs_y__ = yCoord;\\\\n\\\\n            } else if (prop['chart.crosshairs.coords']) {\\\\n                alert('[RGRAPH] Showing crosshair coordinates is only supported on the Scatter chart');\\\\n            }\\\\n\\\\n            /**\\\\n            * Fire the oncrosshairs custom event\\\\n            */\\\\n            RG.fireCustomEvent(obj, 'oncrosshairs');\\\\n\\\\n        } else {\\\\n            RG.hideCrosshairCoords();\\\\n        }\\\\n    };\\\\n\\\\n\\\\n\\\\n\\\\n    //\\\\n    // Adds a mousemove event listener that highlights a segment based on th\\\\n    // mousemove event. Used in the Rose and the RScatter charts\\\\n    //\\\\n    //@param int segments The number of segments to allow\\\\n    //\\\\n    RG.allowSegmentHighlight = function (opt)\\\\n    {\\\\n        var obj    = opt.object,\\\\n            count  = opt.count,\\\\n            fill   = opt.fill,\\\\n            stroke = opt.stroke\\\\n\\\\n        if (!RG.segmentHighlightFunction) {\\\\n\\\\n            RG.segmentHighlightFunction = function (e)\\\\n            {\\\\n\\\\n                var mouseXY = RG.getMouseXY(e);\\\\n                var angle   = RG.getAngleByXY(obj.centerx, obj.centery, mouseXY[0], mouseXY[1]);\\\\n\\\\n                angle += RG.HALFPI;\\\\n\\\\n                if (angle > RG.TWOPI) {\\\\n                    angle -= RG.TWOPI;\\\\n                }\\\\n\\\\n                RG.redraw();\\\\n        \\\\n                var start = 0;\\\\n                var end   = 0;\\\\n                var a     = (ma.PI * 2) / count;\\\\n                \\\\n                //\\\\n                // Radius\\\\n                //\\\\n                var r = obj.radius;\\\\n\\\\n\\\\n                (function ()\\\\n                {\\\\n                    for (i=0; i<count; i+=1) {\\\\n                        if (angle < (a * (i + 1))) {\\\\n                            start = i * a;\\\\n                            end   = (i + 1) * a;\\\\n                            \\\\n                            return;\\\\n                        }\\\\n                    }\\\\n                })();\\\\n                \\\\n                start -= RG.HALFPI;\\\\n                end   -= RG.HALFPI;\\\\n                \\\\n\\\\n                RG.path2(\\\\n                    obj.context,\\\\n                    'b m % % a % % % % % false c s % f %',\\\\n                    obj.centerx, obj.centery,\\\\n                    obj.centerx,obj.centery,r,start,end,\\\\n                    stroke,\\\\n                    fill\\\\n                );\\\\n        \\\\n            };\\\\n            obj.canvas.addEventListener('mousemove', RG.segmentHighlightFunction, false);\\\\n        }\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n// End module pattern\\\\n})(window, document);\\\";\");\";}}");

?>