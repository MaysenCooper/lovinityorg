<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:1:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc7baa261fd0.33735250_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:12:\"RGraph.meter\";i:3;N;i:4;a:1:{s:33:\"tcpfunc_58dc7baa261fd0.33735250_1\";s:48965:\"\$tpl_funcs['tcpfunc_58dc7baa261fd0.33735250_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc7baa261fd0.33735250_1']=recall_named_function('58dc7baa2622a2.14597658','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n\\\\n    /**\\\\n    * The bar chart constructor\\\\n    * \\\\n    * @param string canvas The canvas ID\\\\n    * @param min    integer The minimum value\\\\n    * @param max    integer The maximum value\\\\n    * @param value  integer The indicated value\\\\n    */\\\\n    RGraph.Meter = function (conf)\\\\n    {\\\\n        /**\\\\n        * Allow for object config style\\\\n        */\\\\n        if (   typeof conf === 'object'\\\\n            && typeof conf.value !== 'undefined'\\\\n            && typeof conf.id === 'string') {\\\\n\\\\n            var id                        = conf.id\\\\n            var canvas                    = document.getElementById(id);\\\\n            var min                       = conf.min;\\\\n            var max                       = conf.max;\\\\n            var value                     = conf.value;\\\\n            var parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor)\\\\n\\\\n        } else {\\\\n        \\\\n            var id     = conf;\\\\n            var canvas = document.getElementById(id);\\\\n            var min    = arguments[1];\\\\n            var max    = arguments[2];\\\\n            var value  = arguments[3];\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // id, min, max, value\\\\n        // Get the canvas and context objects\\\\n        this.id                = id;\\\\n        this.canvas            = canvas;\\\\n        this.context           = this.canvas.getContext ? this.canvas.getContext(\\\\\\\"2d\\\\\\\", {alpha: (typeof id === 'object' && id.alpha === false) ? false : true}) : null;\\\\n        this.canvas.__object__ = this;\\\\n        this.type              = 'meter';\\\\n        this.min               = RGraph.stringsToNumbers(min);\\\\n        this.max               = RGraph.stringsToNumbers(max);\\\\n        this.value             = RGraph.stringsToNumbers(value);\\\\n        this.centerx           = null;\\\\n        this.centery           = null;\\\\n        this.radius            = null;\\\\n        this.isRGraph          = true;\\\\n        this.currentValue      = null;\\\\n        this.uid               = RGraph.CreateUID();\\\\n        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();\\\\n        this.colorsParsed      = false;\\\\n        this.coordsText        = [];\\\\n        this.original_colors   = [];\\\\n        this.firstDraw         = true; // After the first draw this will be false\\\\n\\\\n\\\\n        /**\\\\n        * Compatibility with older browsers\\\\n        */\\\\n        //RGraph.OldBrowserCompat(this.context);\\\\n\\\\n\\\\n        // Various config type stuff\\\\n        this.properties =\\\\n        {\\\\n            'chart.background.image.url':     null,\\\\n            'chart.background.image.offsetx': 0,\\\\n            'chart.background.image.offsety': 0,\\\\n            'chart.background.image.stretch': true,\\\\n            'chart.background.color':       'white',\\\\n            'chart.gutter.left':            15,\\\\n            'chart.gutter.right':           15,\\\\n            'chart.gutter.top':             15,\\\\n            'chart.gutter.bottom':          20,\\\\n            'chart.linewidth':              1,\\\\n            'chart.linewidth.segments':     0,\\\\n            'chart.strokestyle':            null,\\\\n            'chart.border':                 true,\\\\n            'chart.border.color':           'black',\\\\n            'chart.text.font':              'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.text.size':              12,\\\\n            'chart.text.color':             'black',\\\\n            'chart.text.valign':            'center',\\\\n            'chart.text.accessible':               false,\\\\n            'chart.text.accessible.overflow':      'visible',\\\\n            'chart.text.accessible.pointerevents': true,\\\\n            'chart.value.text.decimals':    0,\\\\n            'chart.value.text.units.pre':   '',\\\\n            'chart.value.text.units.post':  '',\\\\n            'chart.title':                  '',\\\\n            'chart.title.background':       null,\\\\n            'chart.title.hpos':             null,\\\\n            'chart.title.vpos':             null,\\\\n            'chart.title.color':            'black',\\\\n            'chart.title.bold':             true,\\\\n            'chart.title.font':             null,\\\\n            'chart.title.x':                null,\\\\n            'chart.title.y':                null,\\\\n            'chart.title.halign':           null,\\\\n            'chart.title.valign':           null,\\\\n            'chart.green.start':            ((this.max - this.min) * 0.35) + this.min,\\\\n            'chart.green.end':              this.max,\\\\n            'chart.green.color':            '#207A20',\\\\n            'chart.yellow.start':           ((this.max - this.min) * 0.1) + this.min,\\\\n            'chart.yellow.end':             ((this.max - this.min) * 0.35) + this.min,\\\\n            'chart.yellow.color':           '#D0AC41',\\\\n            'chart.red.start':              this.min,\\\\n            'chart.red.end':                ((this.max - this.min) * 0.1) + this.min,\\\\n            'chart.red.color':              '#9E1E1E',\\\\n            'chart.colors.ranges':          null,\\\\n            'chart.units.pre':              '',\\\\n            'chart.units.post':             '',\\\\n            'chart.contextmenu':            null,\\\\n            'chart.zoom.factor':            1.5,\\\\n            'chart.zoom.fade.in':           true,\\\\n            'chart.zoom.fade.out':          true,\\\\n            'chart.zoom.hdir':              'right',\\\\n            'chart.zoom.vdir':              'down',\\\\n            'chart.zoom.frames':            25,\\\\n            'chart.zoom.delay':             16.666,\\\\n            'chart.zoom.shadow':            true,\\\\n            'chart.zoom.background':        true,\\\\n            'chart.zoom.action':            'zoom',\\\\n            'chart.annotatable':            false,\\\\n            'chart.annotate.color':         'black',\\\\n            'chart.shadow':                 false,\\\\n            'chart.shadow.color':           'rgba(0,0,0,0.5)',\\\\n            'chart.shadow.blur':            3,\\\\n            'chart.shadow.offsetx':         3,\\\\n            'chart.shadow.offsety':         3,\\\\n            'chart.resizable':              false,\\\\n            'chart.resize.handle.adjust':   [0,0],\\\\n            'chart.resize.handle.background': null,\\\\n            'chart.tickmarks.small.num':      100,\\\\n            'chart.tickmarks.big.num':        10,\\\\n            'chart.tickmarks.small.color':    '#bbb',\\\\n            'chart.tickmarks.big.color':      'black',\\\\n            'chart.scale.decimals':           0,\\\\n            'chart.scale.point':              '.',\\\\n            'chart.scale.thousand':           ',',\\\\n            'chart.radius':                   null,\\\\n            'chart.centerx':                  null,\\\\n            'chart.centery':                  null,\\\\n            'chart.labels':                   true,\\\\n            'chart.labels.count':             10,\\\\n            'chart.labels.specific':          null,\\\\n            'chart.segment.radius.start':     0,\\\\n            'chart.needle.radius':            null,\\\\n            'chart.needle.tail':              false,\\\\n            'chart.needle.head':              true,\\\\n            'chart.needle.color':             'black',\\\\n            'chart.needle.image.url':         null,\\\\n            'chart.needle.image.offsetx':     0,\\\\n            'chart.needle.image.offsety':     0,\\\\n            'chart.adjustable':               false,\\\\n            'chart.angles.start':             RGraph.PI,\\\\n            'chart.angles.end':               RGraph.TWOPI,\\\\n            'chart.centerpin.stroke':         'black',\\\\n            'chart.centerpin.fill':           'white',\\\\n            'chart.clearto':   'rgba(0,0,0,0)'\\\\n        }\\\\n\\\\n\\\\n        // Check for support\\\\n        if (!this.canvas) {\\\\n            alert('[METER] No canvas support');\\\\n            return;\\\\n        }\\\\n\\\\n\\\\n\\\\n        /*\\\\n        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\\\\n        * done already\\\\n        */\\\\n        if (!this.canvas.__rgraph_aa_translated__) {\\\\n            this.context.translate(0.5,0.5);\\\\n            \\\\n            this.canvas.__rgraph_aa_translated__ = true;\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // Short variable names\\\\n        var RG   = RGraph,\\\\n            ca   = this.canvas,\\\\n            co   = ca.getContext('2d'),\\\\n            prop = this.properties,\\\\n            pa2  = RG.path2,\\\\n            win  = window,\\\\n            doc  = document,\\\\n            ma   = Math\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * \\\\\\\"Decorate\\\\\\\" the object with the generic effects if the effects library has been included\\\\n        */\\\\n        if (RG.Effects && typeof RG.Effects.decorate === 'function') {\\\\n            RG.Effects.decorate(this);\\\\n        }\\\\n\\\\n\\\\n    \\\\n        /**\\\\n        * A setter\\\\n        * \\\\n        * @param name  string The name of the property to set\\\\n        * @param value mixed  The value of the property\\\\n        */\\\\n        this.set =\\\\n        this.Set = function (name)\\\\n        {\\\\n            var value = arguments[1] || null;\\\\n\\\\n            /**\\\\n            * the number of arguments is only one and it's an\\\\n            * object - parse it for configuration data and return.\\\\n            */\\\\n            if (arguments.length === 1 && typeof name === 'object') {\\\\n                RG.parseObjectStyleConfig(this, name);\\\\n                return this;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            /**\\\\n            * This should be done first - prepend the propertyy name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            if (name == 'chart.value') {\\\\n                this.value = value;\\\\n                return;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            prop[name] = value;\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A getter\\\\n        * \\\\n        * @param name  string The name of the property to get\\\\n        */\\\\n        this.get =\\\\n        this.Get = function (name)\\\\n        {\\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n    \\\\n            if (name == 'chart.value') {\\\\n                return this.value;\\\\n            }\\\\n    \\\\n            return prop[name];\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The function you call to draw the bar chart\\\\n        */\\\\n        this.draw =\\\\n        this.Draw = function ()\\\\n        {\\\\n            /**\\\\n            * Fire the onbeforedraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'onbeforedraw');\\\\n    \\\\n            /**\\\\n            * Constrain the value to be within the min and max\\\\n            */\\\\n            if (this.value > this.max) this.value = this.max;\\\\n            if (this.value < this.min) this.value = this.min;\\\\n    \\\\n            /**\\\\n            * Set the current value\\\\n            */\\\\n            this.currentValue = this.value;\\\\n    \\\\n            /**\\\\n            * This is new in May 2011 and facilitates indiviual gutter settings,\\\\n            * eg chart.gutter.left\\\\n            */\\\\n            this.gutterLeft   = prop['chart.gutter.left'];\\\\n            this.gutterRight  = prop['chart.gutter.right'];\\\\n            this.gutterTop    = prop['chart.gutter.top'];\\\\n            this.gutterBottom = prop['chart.gutter.bottom'];\\\\n            \\\\n            this.centerx = ((ca.width - this.gutterLeft - this.gutterRight) / 2) + this.gutterLeft;\\\\n            this.centery = ca.height - this.gutterBottom;\\\\n            this.radius  = Math.min(\\\\n                                    (ca.width - this.gutterLeft - this.gutterRight) / 2,\\\\n                                    (ca.height - this.gutterTop - this.gutterBottom)\\\\n                                   );\\\\n                \\\\n            /**\\\\n            * Stop this growing uncontrollably\\\\n            */\\\\n            this.coordsText = [];\\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Custom centerx, centery and radius\\\\n            */\\\\n            if (typeof(prop['chart.centerx']) == 'number') this.centerx = prop['chart.centerx'];\\\\n            if (typeof(prop['chart.centery']) == 'number') this.centery = prop['chart.centery'];\\\\n            if (typeof(prop['chart.radius']) == 'number')  this.radius  = prop['chart.radius'];\\\\n    \\\\n    \\\\n            /**\\\\n            * Parse the colors for gradients. Its down here so that the center X/Y can be used\\\\n            */\\\\n            if (!this.colorsParsed) {\\\\n    \\\\n                this.parseColors();\\\\n    \\\\n                // Don't want to do this again\\\\n                this.colorsParsed = true;\\\\n            }\\\\n    \\\\n    \\\\n            this.drawBackground();\\\\n            this.drawLabels();\\\\n            this.drawNeedle();\\\\n            this.drawReadout();\\\\n            \\\\n            /**\\\\n            * Draw the title\\\\n            */\\\\n            RG.DrawTitle(this, prop['chart.title'], this.gutterTop, null, prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);\\\\n    \\\\n            /**\\\\n            * Setup the context menu if required\\\\n            */\\\\n            if (prop['chart.contextmenu']) {\\\\n                RG.ShowContext(this);\\\\n            }\\\\n    \\\\n            \\\\n            /**\\\\n            * This function enables resizing\\\\n            */\\\\n            if (prop['chart.resizable']) {\\\\n                RG.AllowResizing(this);\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * This installs the event listeners\\\\n            */\\\\n            RG.InstallEventListeners(this);\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Fire the onfirstdraw event\\\\n            */\\\\n            if (this.firstDraw) {\\\\n                RG.fireCustomEvent(this, 'onfirstdraw');\\\\n                this.firstDraw = false;\\\\n                this.firstDrawFunc();\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Fire the RGraph ondraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'ondraw');\\\\n\\\\n\\\\n\\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * Used in chaining. Runs a function there and then - not waiting for\\\\n        * the events to fire (eg the onbeforedraw event)\\\\n        * \\\\n        * @param function func The function to execute\\\\n        */\\\\n        this.exec = function (func)\\\\n        {\\\\n            func(this);\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the background of the chart\\\\n        */\\\\n        this.drawBackground =\\\\n        this.DrawBackground = function ()\\\\n        {\\\\n            /**\\\\n            * First draw the background image if it's defined\\\\n            */\\\\n            if (typeof prop['chart.background.image.url'] === 'string' && !this.__background_image__) {\\\\n                \\\\n                var x   = 0 + prop['chart.background.image.offsetx'];\\\\n                var y   = 0 + prop['chart.background.image.offsety'];\\\\n                var img = new Image();\\\\n\\\\n                this.__background_image__ = img;\\\\n                img.src = prop['chart.background.image.url'];\\\\n\\\\n                img.onload = function ()\\\\n                {\\\\n                    if (prop['chart.background.image.stretch']) {\\\\n                        co.drawImage(this, x,y,ca.width, ca.height);\\\\n                    } else {\\\\n                        co.drawImage(this, x,y);\\\\n                    }\\\\n                    RG.redraw();\\\\n                }\\\\n            \\\\n            } else if (this.__background_image__) {\\\\n            \\\\n                var x   = 0 + prop['chart.background.image.offsetx'];\\\\n                var y   = 0 + prop['chart.background.image.offsety'];\\\\n\\\\n                if (prop['chart.background.image.stretch']) {\\\\n                    co.drawImage(this.__background_image__, x,y,ca.width, ca.height);\\\\n                } else {\\\\n                    co.drawImage(this.__background_image__, x,y);\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Draw the white background\\\\n            */\\\\n            co.beginPath();\\\\n    \\\\n                co.fillStyle = prop['chart.background.color'];\\\\n                \\\\n                if (prop['chart.shadow']) {\\\\n                    RG.SetShadow(this, prop['chart.shadow.color'],prop['chart.shadow.offsetx'],prop['chart.shadow.offsety'], prop['chart.shadow.blur']);\\\\n                }\\\\n                co.moveTo(this.centerx,this.centery);\\\\n                co.arc(this.centerx,\\\\n                       this.centery,\\\\n                       this.radius,\\\\n                       prop['chart.angles.start'],\\\\n                       prop['chart.angles.end'],\\\\n                       false);\\\\n    \\\\n            co.fill();\\\\n            \\\\n            RG.NoShadow(this);\\\\n    \\\\n            \\\\n            // Draw the shadow\\\\n            if (prop['chart.shadow']) {\\\\n    \\\\n                co.beginPath();\\\\n                    var r = (this.radius * 0.06) > 40 ? 40 : (this.radius * 0.06);\\\\n                    co.arc(this.centerx, this.centery, r, 0, RG.TWOPI, 0);\\\\n                co.fill();\\\\n    \\\\n                RG.NoShadow(this);\\\\n            }\\\\n\\\\n\\\\n\\\\n            // First, draw the grey tickmarks\\\\n            if (prop['chart.tickmarks.small.num']) {\\\\n                for (var i=0; i<(prop['chart.angles.end'] - prop['chart.angles.start']); i+=(RG.PI / prop['chart.tickmarks.small.num'])) {\\\\n                    co.beginPath();\\\\n                        co.strokeStyle = prop['chart.tickmarks.small.color'];\\\\n                        co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);\\\\n                        co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.00001, 0);\\\\n                    co.stroke();\\\\n                }\\\\n    \\\\n                // Draw the semi-circle that makes the tickmarks\\\\n                co.beginPath();\\\\n                    co.fillStyle = prop['chart.background.color'];\\\\n                    co.arc(this.centerx, this.centery, this.radius - 4, prop['chart.angles.start'], prop['chart.angles.end'], false);\\\\n                co.closePath();\\\\n                co.fill();\\\\n            }\\\\n    \\\\n    \\\\n            // Second, draw the darker tickmarks. First run draws them in white to get rid of the existing tickmark,\\\\n            // then the second run draws them in the requested color\\\\n            \\\\n            \\\\n            if (prop['chart.tickmarks.big.num']) {\\\\n                var colors = ['white','white',prop['chart.tickmarks.big.color']];\\\\n                for (var j=0; j<colors.length; ++j) {\\\\n                    for (var i=0; i<(prop['chart.angles.end'] - prop['chart.angles.start']); i+=((prop['chart.angles.end'] - prop['chart.angles.start']) / prop['chart.tickmarks.big.num'])) {\\\\n                        co.beginPath();\\\\n                            co.strokeStyle = colors[j];\\\\n                            co.arc(this.centerx, this.centery, this.radius, prop['chart.angles.start'] +  i, prop['chart.angles.start'] + i + 0.001, 0);\\\\n                            co.arc(this.centerx, this.centery, this.radius - 5, prop['chart.angles.start'] + i, prop['chart.angles.start'] + i + 0.0001, 0);\\\\n                        co.stroke();\\\\n                    }\\\\n                }\\\\n            }\\\\n    \\\\n            // Draw the white circle that makes the tickmarks\\\\n            co.beginPath();\\\\n            co.fillStyle = prop['chart.background.color'];\\\\n            co.moveTo(this.centerx, this.centery);\\\\n            co.arc(this.centerx, this.centery, this.radius - 7, prop['chart.angles.start'], prop['chart.angles.end'], false);\\\\n            co.closePath();\\\\n            co.fill();\\\\n    \\\\n            /**\\\\n            * Color ranges - either green/yellow/red or an arbitrary number of ranges\\\\n            */\\\\n            var ranges = prop['chart.colors.ranges'];\\\\n    \\\\n            if (RG.is_array(prop['chart.colors.ranges'])) {\\\\n    \\\\n                var ranges = prop['chart.colors.ranges'];\\\\n    \\\\n                for (var i=0; i<ranges.length; ++i) {\\\\n    \\\\n                    co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : ranges[i][2];\\\\n                    co.fillStyle = ranges[i][2];\\\\n                    co.lineWidth = prop['chart.linewidth.segments'];\\\\n    \\\\n                    co.beginPath();\\\\n                        co.arc(this.centerx,\\\\n                               this.centery,\\\\n                               this.radius * 0.85,\\\\n                               (((ranges[i][0] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                               (((ranges[i][1] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                               false);\\\\n    \\\\n                        if (prop['chart.segment.radius.start'] > 0) {\\\\n                            co.arc(this.centerx,\\\\n                                   this.centery,\\\\n                                   prop['chart.segment.radius.start'],\\\\n                                   (((ranges[i][1] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                                   (((ranges[i][0] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                                   true);\\\\n                        } else {\\\\n                            co.lineTo(this.centerx, this.centery);\\\\n                        }\\\\n    \\\\n                    co.closePath();\\\\n                    co.stroke();\\\\n                    co.fill();\\\\n                }\\\\n    \\\\n                // Stops the last line from being changed to a big linewidth.\\\\n                co.beginPath();\\\\n    \\\\n            } else {\\\\n                co.lineWidth = prop['chart.linewidth'];\\\\n    \\\\n                // Draw the green area\\\\n                co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.green.color'];\\\\n                co.fillStyle   = prop['chart.green.color'];\\\\n                co.lineWidth   = prop['chart.linewidth.segments'];\\\\n                \\\\n                co.beginPath();\\\\n                    co.arc(this.centerx,\\\\n                           this.centery,\\\\n                           this.radius * 0.85,\\\\n                           (((prop['chart.green.start'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - this.properties['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                           (((prop['chart.green.end'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                           false);\\\\n    \\\\n                    if (prop['chart.segment.radius.start'] > 0) {\\\\n    \\\\n                        co.arc(this.centerx,\\\\n                               this.centery,\\\\n                               prop['chart.segment.radius.start'],\\\\n                               (((prop['chart.green.end'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                               (((prop['chart.green.start'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                               true);\\\\n                    } else {\\\\n                        co.lineTo(this.centerx, this.centery);\\\\n                    }\\\\n    \\\\n                co.closePath();\\\\n                co.stroke();\\\\n                co.fill();\\\\n                \\\\n                // Draw the yellow area\\\\n                co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.yellow.color'];\\\\n                co.fillStyle = prop['chart.yellow.color'];\\\\n                co.lineWidth = prop['chart.linewidth.segments'];\\\\n                co.beginPath();\\\\n                co.arc(this.centerx,\\\\n                       this.centery,\\\\n                       this.radius * 0.85,\\\\n                       (((prop['chart.yellow.start'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                       (((prop['chart.yellow.end'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                       false);\\\\n                \\\\n                if (prop['chart.segment.radius.start'] > 0) {\\\\n                    co.arc(this.centerx,\\\\n                           this.centery,\\\\n                           prop['chart.segment.radius.start'],\\\\n                           (((prop['chart.yellow.end'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                           (((prop['chart.yellow.start'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                           true);\\\\n                } else {\\\\n                    co.lineTo(this.centerx, this.centery);\\\\n                }\\\\n    \\\\n                co.closePath();\\\\n                co.stroke();\\\\n                co.fill();\\\\n                \\\\n                // Draw the red area\\\\n                co.strokeStyle = prop['chart.strokestyle'] ? prop['chart.strokestyle'] : prop['chart.red.color'];\\\\n                co.fillStyle = prop['chart.red.color'];\\\\n                co.lineWidth = prop['chart.linewidth.segments'];\\\\n                \\\\n                co.beginPath();\\\\n                    co.arc(this.centerx,\\\\n                           this.centery,this.radius * 0.85,\\\\n                           (((prop['chart.red.start'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                           (((prop['chart.red.end'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                           false);\\\\n        \\\\n                    if (prop['chart.segment.radius.start'] > 0) {\\\\n                        co.arc(this.centerx,\\\\n                               this.centery,\\\\n                               prop['chart.segment.radius.start'],\\\\n                               (((prop['chart.red.end'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                               (((prop['chart.red.start'] - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'],\\\\n                               true);\\\\n                    } else {\\\\n                        co.lineTo(this.centerx, this.centery);\\\\n                    }\\\\n    \\\\n                co.closePath();\\\\n                co.stroke();\\\\n                co.fill();\\\\n                \\\\n                // Revert the linewidth\\\\n                co.lineWidth = 1;\\\\n            }\\\\n    \\\\n            // Draw the outline\\\\n            if (prop['chart.border']) {\\\\n                co.strokeStyle = prop['chart.border.color'];\\\\n                co.lineWidth   = prop['chart.linewidth'];\\\\n                \\\\n                co.beginPath();\\\\n                    co.moveTo(this.centerx, this.centery);\\\\n                    co.arc(this.centerx,\\\\n                           this.centery,\\\\n                           this.radius,\\\\n                           prop['chart.angles.start'],\\\\n                           prop['chart.angles.end'],\\\\n                           false);\\\\n                co.closePath();\\\\n            }\\\\n    \\\\n            co.stroke();\\\\n            \\\\n            // Reset the linewidth back to 1\\\\n            co.lineWidth = 1;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the pointer\\\\n        */\\\\n        this.drawNeedle =\\\\n        this.DrawNeedle = function ()\\\\n        {\\\\n            /**\\\\n            * The angle that the needle is at\\\\n            */\\\\n            var a = (((this.value - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'];\\\\n\\\\n            /**\\\\n            * First draw the background image if it's defined\\\\n            */\\\\n            if (typeof prop['chart.needle.image.url'] === 'string' && !this.__needle_image__) {\\\\n                \\\\n                var img = new Image();\\\\n\\\\n                this.__needle_image__ = img;\\\\n                img.src = prop['chart.needle.image.url'];\\\\n\\\\n                img.onload = function ()\\\\n                {\\\\n                    co.save();\\\\n                        RG.rotateCanvas(ca, this.centerx, this.centery, a);\\\\n                        co.drawImage(this,\\\\n                                     this.centerx + prop['chart.needle.image.offsetx'],\\\\n                                     this.centery + prop['chart.needle.image.offsety']);\\\\n                    co.restore();\\\\n\\\\n                    RG.redraw();\\\\n                }\\\\n\\\\n            } else if (this.__needle_image__) {\\\\n\\\\n                co.save();\\\\n                    RG.rotateCanvas(ca, this.centerx, this.centery, a);\\\\n                    co.drawImage(this.__needle_image__,\\\\n                                 this.centerx + prop['chart.needle.image.offsetx'],\\\\n                                 this.centery + prop['chart.needle.image.offsety']);\\\\n                co.restore();\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            // Allow customising the needle radius\\\\n            var needleRadius = typeof(prop['chart.needle.radius']) == 'number' ? prop['chart.needle.radius'] : this.radius * 0.7;\\\\n    \\\\n            // First draw the circle at the bottom\\\\n            co.fillStyle = 'black';\\\\n            co.lineWidth = this.radius >= 200 ? 7 : 3;\\\\n            co.lineCap = 'round';\\\\n    \\\\n            // Now, draw the arm of the needle\\\\n            co.beginPath();\\\\n                co.strokeStyle = prop['chart.needle.color'];\\\\n                if (typeof(prop['chart.needle.linewidth']) == 'number') co.lineWidth = prop['chart.needle.linewidth'];\\\\n\\\\n    \\\\n                co.arc(this.centerx, this.centery, needleRadius, a, a + 0.001, false);\\\\n                co.lineTo(this.centerx, this.centery);\\\\n            co.stroke();\\\\n\\\\n            // Draw the triangular needle head\\\\n            if (prop['chart.needle.head']) {\\\\n\\\\n                co.fillStyle = prop['chart.needle.color'];\\\\n                co.beginPath();\\\\n                    co.lineWidth = 1;\\\\n                    //co.moveTo(this.centerx, this.centery);\\\\n                    co.arc(this.centerx, this.centery, needleRadius + 15, a, a + 0.001, 0);\\\\n                    co.arc(this.centerx, this.centery, needleRadius - 15, a + 0.087, a + 0.087999, 0);\\\\n                    co.arc(this.centerx, this.centery, needleRadius - 15, a - 0.087, a - 0.087999, 1);\\\\n                co.fill();\\\\n            }\\\\n\\\\n            // Draw the tail if requested\\\\n            if (prop['chart.needle.tail']) {\\\\n                co.beginPath();\\\\n                    co.strokeStyle = prop['chart.needle.color'];\\\\n                    if (typeof(prop['chart.needle.linewidth']) == 'number') co.lineWidth = prop['chart.needle.linewidth'];\\\\n\\\\n                    var a = ((this.value - this.min) / (this.max - this.min) * (this.properties['chart.angles.end'] - this.properties['chart.angles.start'])) + this.properties['chart.angles.start'] + RG.PI;\\\\n                    co.arc(this.centerx, this.centery, 25, a, a + 0.001, false);\\\\n                    co.lineTo(this.centerx, this.centery);\\\\n                co.stroke();\\\\n            }\\\\n\\\\n            // Draw the center circle (the stroke)\\\\n            var r = (this.radius * 0.06) > 40 ? 40 : (this.radius * 0.06);\\\\n    \\\\n            co.beginPath();\\\\n            co.fillStyle = prop['chart.centerpin.stroke'];\\\\n            co.arc(this.centerx, this.centery, r, 0 + 0.001, RG.TWOPI, 0);\\\\n            co.fill();\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            // Draw the centre bit of the circle (the fill)\\\\n            co.fillStyle = prop['chart.centerpin.fill'];\\\\n            co.beginPath();\\\\n            co.arc(this.centerx, this.centery, r - 2, 0 + 0.001, RG.TWOPI, 0);\\\\n            co.fill();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the labels\\\\n        */\\\\n        this.drawLabels =\\\\n        this.DrawLabels = function ()\\\\n        {\\\\n            if (!prop['chart.labels']) {\\\\n                return;\\\\n            }\\\\n\\\\n            var radius     = this.radius,\\\\n                text_size  = prop['chart.text.size'],\\\\n                text_font  = prop['chart.text.font'],\\\\n                units_post = prop['chart.units.post'],\\\\n                units_pre  = prop['chart.units.pre'],\\\\n                centerx    = this.centerx,\\\\n                centery    = this.centery,\\\\n                min        = this.min,\\\\n                max        = this.max,\\\\n                decimals   = prop['chart.scale.decimals'],\\\\n                numLabels  = prop['chart.labels.count'],\\\\n                specific   = prop['chart.labels.specific']\\\\n\\\\n\\\\n\\\\n\\\\n//\\\\n// Draw the specific labels if they're specifid\\\\n//\\\\n            if (specific) {\\\\n                for (var i=0; i<specific.length; ++i) {\\\\n            \\\\n                    var         angle = this.getAngle(specific[i][1]),\\\\n                        angle_degrees = angle * (180 / RG.PI),\\\\n                                text  = specific[i][0].toString(),\\\\n                                coords = RG.getRadiusEndPoint(this.centerx, this.centery, angle, this.radius * 0.925)\\\\n            \\\\n            \\\\n                    RG.text2(this, {\\\\n                        'font':text_font,\\\\n                        'size':text_size,\\\\n                        'x': coords[0],\\\\n                        'y': coords[1],\\\\n                        'text':text,\\\\n                        'halign':'center',\\\\n                        'valign':'center',\\\\n                        'angle':angle_degrees + 90,\\\\n                        'bounding': false,\\\\n                        'tag': 'labels-specific',\\\\n                        color: 'black'\\\\n                    });\\\\n                }\\\\n            \\\\n                return;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            co.fillStyle = prop['chart.text.color'];\\\\n            co.lineWidth = 1;\\\\n    \\\\n            co.beginPath();\\\\n    \\\\n            for (var i=0; i<=numLabels; ++i) {\\\\n            \\\\n                var angle      = ((prop['chart.angles.end'] - prop['chart.angles.start']) * (i / numLabels)) + prop['chart.angles.start'];\\\\n                var coords     = RG.getRadiusEndPoint(centerx, centery, angle + (((i == 0 || i == numLabels) && prop['chart.border']) ? (i == 0 ? 0.05 : -0.05) : 0), (this.radius * 0.925) - (prop['chart.text.valign'] === 'bottom' ? 15 : 0));\\\\n                \\\\n                var angleStart = prop['chart.angles.start'],\\\\n                    angleEnd   = prop['chart.angles.end'],\\\\n                    angleRange = angleEnd - angleStart,                \\\\n                    angleStart_degrees = angleStart * (180 / RG.PI),\\\\n                    angleEnd_degrees = angleEnd * (180 / RG.PI),\\\\n                    angleRange_degrees = angleRange * (180 / RG.PI)\\\\n\\\\n                // Vertical alignment\\\\n                valign = prop['chart.text.valign'];\\\\n    \\\\n                // Horizontal alignment\\\\n                if (prop['chart.border']) {\\\\n                    if (i == 0) {\\\\n                        halign = 'left';\\\\n                    } else if (i == numLabels) {\\\\n                        halign = 'right';\\\\n                    } else {\\\\n                        halign = 'center'\\\\n                    }\\\\n                } else {\\\\n                    halign = 'center';\\\\n                }\\\\n                \\\\n                var value = ((this.max - this.min) * (i / numLabels)) + this.min;\\\\n    \\\\n                RG.text2(this, {\\\\n                    'font':text_font,\\\\n                    'size':text_size,\\\\n                    'x':coords[0],\\\\n                    'y':coords[1],\\\\n                    'text':RG.numberFormat(this, (value).toFixed(value === 0 ? 0 : decimals),units_pre,units_post),\\\\n                    'halign':halign,\\\\n                    'valign':valign,\\\\n                    'angle':((angleRange_degrees * (1 / numLabels) * i) + angleStart_degrees) - 270,\\\\n                    'bounding':false,\\\\n                    'boundingFill':(i == 0 || i == numLabels) ? 'white': null,\\\\n                    'tag': 'scale'\\\\n                });\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the text readout if specified\\\\n        */\\\\n        this.drawReadout  =\\\\n        this.DrawReadout  = function ()\\\\n        {\\\\n            if (prop['chart.value.text']) {\\\\n                co.beginPath();\\\\n                co.fillStyle = prop['chart.text.color'];\\\\n                RG.Text2(this, {'font':prop['chart.text.font'],\\\\n                                'size':prop['chart.text.size'],\\\\n                                'x':this.centerx,\\\\n                                'y':this.centery - prop['chart.text.size'] - 15,\\\\n                                'text': prop['chart.value.text.units.pre'] + (this.value).toFixed(prop['chart.value.text.decimals']) + prop['chart.value.text.units.post'],\\\\n                                'halign':'center',\\\\n                                'valign':'bottom',\\\\n                                'bounding':true,\\\\n                                'boundingFill':'white',\\\\n                                'tag': 'value.text'\\\\n                               });\\\\n    \\\\n                co.stroke();\\\\n                co.fill();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A placeholder function\\\\n        * \\\\n        * @param object The event object\\\\n        */\\\\n        this.getShape = function (e) {};\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function returns the pertinent value for a particular click (or other mouse event)\\\\n        * \\\\n        * @param obj e The event object\\\\n        */\\\\n        this.getValue = function (e)\\\\n        {\\\\n            var mouseXY = RG.getMouseXY(e);\\\\n            var angle   = RG.getAngleByXY(this.centerx, this.centery, mouseXY[0], mouseXY[1]);\\\\n\\\\n            // Work out the radius\\\\n            var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);\\\\n            if (radius > this.radius) {\\\\n                return null;\\\\n            }\\\\n    \\\\n    \\\\n            if (angle < RG.HALFPI) {\\\\n                angle += RG.TWOPI;\\\\n            }\\\\n\\\\n            var value = (((angle - prop['chart.angles.start']) / (prop['chart.angles.end'] - prop['chart.angles.start'])) * (this.max - this.min)) + this.min;\\\\n\\\\n            value = Math.max(value, this.min);\\\\n            value = Math.min(value, this.max);\\\\n\\\\n            return value;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The getObjectByXY() worker method. Don't call this call:\\\\n        * \\\\n        * RGraph.ObjectRegistry.getObjectByXY(e)\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.getObjectByXY = function (e)\\\\n        {\\\\n            var mouseXY = RGraph.getMouseXY(e);\\\\n    \\\\n            // Work out the radius\\\\n            var radius = RG.getHypLength(this.centerx, this.centery, mouseXY[0], mouseXY[1]);\\\\n    \\\\n            if (\\\\n                   mouseXY[0] > (this.centerx - this.radius)\\\\n                && mouseXY[0] < (this.centerx + this.radius)\\\\n                && mouseXY[1] > (this.centery - this.radius)\\\\n                && mouseXY[1] < (this.centery + this.radius)\\\\n                && radius <= this.radius\\\\n                ) {\\\\n    \\\\n                return this;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This method handles the adjusting calculation for when the mouse is moved\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.adjusting_mousemove =\\\\n        this.Adjusting_mousemove = function (e)\\\\n        {\\\\n            /**\\\\n            * Handle adjusting for the Bar\\\\n            */\\\\n            if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {\\\\n                this.value = this.getValue(e);\\\\n                RG.clear(this.canvas);\\\\n                RG.redrawCanvas(this.canvas);\\\\n                RG.fireCustomEvent(this, 'onadjust');\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This method returns the appropriate angle for a value\\\\n        * \\\\n        * @param number value The value\\\\n        */\\\\n        this.getAngle = function (value)\\\\n        {\\\\n            // Higher than max\\\\n            if (value > this.max || value < this.min) {\\\\n                return null;\\\\n            }\\\\n    \\\\n            var angle = (((value - this.min) / (this.max - this.min)) * (prop['chart.angles.end'] - prop['chart.angles.start'])) + prop['chart.angles.start'];\\\\n    \\\\n            return angle;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This allows for easy specification of gradients\\\\n        */\\\\n        this.parseColors = function ()\\\\n        {\\\\n            // Save the original colors so that they can be restored when the canvas is reset\\\\n            if (this.original_colors.length === 0) {\\\\n                this.original_colors['chart.green.color']   = RG.array_clone(prop['chart.green.color']);\\\\n                this.original_colors['chart.yellow.color']  = RG.array_clone(prop['chart.yellow.color']);\\\\n                this.original_colors['chart.red.color']     = RG.array_clone(prop['chart.red.color']);\\\\n                this.original_colors['chart.colors.ranges'] = RG.array_clone(prop['chart.colors.ranges']);\\\\n            }\\\\n\\\\n            // Parse the basic colors\\\\n            prop['chart.green.color']  = this.parseSingleColorForGradient(prop['chart.green.color']);\\\\n            prop['chart.yellow.color'] = this.parseSingleColorForGradient(prop['chart.yellow.color']);\\\\n            prop['chart.red.color']    = this.parseSingleColorForGradient(prop['chart.red.color']);\\\\n    \\\\n            // Parse chart.colors.ranges\\\\n            var ranges = prop['chart.colors.ranges'];\\\\n            if (ranges && ranges.length) {\\\\n                for (var i=0; i<ranges.length; ++i) {\\\\n                    ranges[i][2] = this.parseSingleColorForGradient(ranges[i][2]);\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Use this function to reset the object to the post-constructor state. Eg reset colors if\\\\n        * need be etc\\\\n        */\\\\n        this.reset = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This parses a single color value\\\\n        */\\\\n        this.parseSingleColorForGradient = function (color)\\\\n        {            \\\\n            if (!color || typeof(color) != 'string') {\\\\n                return color;\\\\n            }\\\\n    \\\\n            if (color.match(/^gradient\\\\\\\\((.*)\\\\\\\\)\\\\\\\$/i)) {\\\\n    \\\\n                var parts = RegExp.\\\\\\\$1.split(':');\\\\n    \\\\n                // Create the gradient\\\\n                var grad = co.createRadialGradient(this.centerx, this.centery, prop['chart.segment.radius.start'], this.centerx, this.centery, this.radius * 0.85);\\\\n    \\\\n                var diff = 1 / (parts.length - 1);\\\\n    \\\\n                for (var j=0; j<parts.length; ++j) {\\\\n                    grad.addColorStop(j * diff, RG.trim(parts[j]));\\\\n                }\\\\n            }\\\\n    \\\\n            return grad ? grad : color;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Using a function to add events makes it easier to facilitate method chaining\\\\n        * \\\\n        * @param string   type The type of even to add\\\\n        * @param function func \\\\n        */\\\\n        this.on = function (type, func)\\\\n        {\\\\n            if (type.substr(0,2) !== 'on') {\\\\n                type = 'on' + type;\\\\n            }\\\\n            \\\\n            if (typeof this[type] !== 'function') {\\\\n                this[type] = func;\\\\n            } else {\\\\n                RG.addCustomEventListener(this, type, func);\\\\n            }\\\\n\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function runs once only\\\\n        * (put at the end of the file (before any effects))\\\\n        */\\\\n        this.firstDrawFunc = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Meter Grow\\\\n        * \\\\n        * This effect gradually increases the represented value\\\\n        * \\\\n        * @param              An object of options - eg: {frames: 60}\\\\n        * @param function     An optional callback function\\\\n        */\\\\n        this.grow = function ()\\\\n        {\\\\n            var obj = this;\\\\n\\\\n            obj.currentValue = obj.currentValue || obj.min;\\\\n\\\\n            var opt         = arguments[0] || {};\\\\n            var frames      = opt.frames || 30;\\\\n            var frame       = 0;\\\\n            var diff        = obj.value - obj.currentValue;\\\\n            var step        = diff / frames;\\\\n            var callback    = arguments[1] || function () {};\\\\n            var initial     = obj.currentValue;\\\\n\\\\n\\\\n\\\\n            function iterator ()\\\\n            {\\\\n                obj.value = initial + (frame++ * step);\\\\n    \\\\n                RG.clear(obj.canvas);\\\\n                RG.redrawCanvas(obj.canvas);\\\\n            \\\\n                if (frame <= frames) {\\\\n                    RG.Effects.updateCanvas(iterator);\\\\n                } else {\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n            \\\\n            iterator();\\\\n            \\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        \\\\n        \\\\n        RG.att(ca);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Register the object\\\\n        */\\\\n        RG.register(this);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This is the 'end' of the constructor so if the first argument\\\\n        * contains configuration data - handle that.\\\\n        */\\\\n        if (parseConfObjectForOptions) {\\\\n            RG.parseObjectStyleConfig(this, conf.options);\\\\n        }\\\\n    };\\\";\");\";}}");

?>