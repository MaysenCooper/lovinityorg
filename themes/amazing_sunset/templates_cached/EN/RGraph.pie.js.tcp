<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:1:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dc7c1708fd15.34600793_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:10:\"RGraph.pie\";i:3;N;i:4;a:1:{s:33:\"tcpfunc_58dc7c1708fd15.34600793_1\";s:85587:\"\$tpl_funcs['tcpfunc_58dc7c1708fd15.34600793_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dc7c1708fd15.34600793_1']=recall_named_function('58dc7c17090209.05841525','\$parameters,\$cl',\"echo \\\"// version: 2016-12-05\\\\n    /**\\\\n    * o--------------------------------------------------------------------------------o\\\\n    * | This file is part of the RGraph package - you can learn more at:               |\\\\n    * |                                                                                |\\\\n    * |                          http://www.rgraph.net                                 |\\\\n    * |                                                                                |\\\\n    * | RGraph is licensed under the Open Source MIT license. That means that it's     |\\\\n    * | totally free to use!                                                           |\\\\n    * o--------------------------------------------------------------------------------o\\\\n    */\\\\n\\\\n    RGraph = window.RGraph || {isRGraph: true};\\\\n\\\\n    /**\\\\n    * The pie chart constructor\\\\n    * \\\\n    * @param data array The data to be represented on the Pie chart\\\\n    */\\\\n    RGraph.Pie = function (conf)\\\\n    {\\\\n        /**\\\\n        * Allow for object config style\\\\n        */\\\\n        if (   typeof conf === 'object'\\\\n            && typeof conf.data === 'object'\\\\n            && typeof conf.id === 'string') {\\\\n\\\\n            var id                        = conf.id,\\\\n                canvas                    = document.getElementById(id),\\\\n                data                      = conf.data,\\\\n                parseConfObjectForOptions = true; // Set this so the config is parsed (at the end of the constructor\\\\n        \\\\n        } else {\\\\n        \\\\n            var id     = conf,\\\\n                canvas = document.getElementById(id),\\\\n                data   = arguments[1];\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // Get the canvas and context objects\\\\n        this.id                = id;\\\\n        this.canvas            = canvas;\\\\n        this.context           = this.canvas.getContext ? this.canvas.getContext(\\\\\\\"2d\\\\\\\", {alpha: (typeof id === 'object' && id.alpha === false) ? false : true}) : null;\\\\n        this.canvas.__object__ = this;\\\\n        this.total             = 0;\\\\n        this.subTotal          = 0;\\\\n        this.angles            = [];\\\\n        this.data              = data;\\\\n        this.properties        = [];\\\\n        this.type              = 'pie';\\\\n        this.isRGraph          = true;\\\\n        this.coords            = [];\\\\n        this.coords.key        = [];\\\\n        this.coordsSticks      = [];\\\\n        this.coordsText        = [];\\\\n        this.uid               = RGraph.CreateUID();\\\\n        this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();\\\\n        this.colorsParsed      = false;\\\\n        this.original_colors   = [];\\\\n        this.firstDraw         = true; // After the first draw this will be false\\\\n        this.exploding         = null;\\\\n\\\\n\\\\n        //\\\\n        // Go through the data and convert strings to numbers\\\\n        //\\\\n        for (var i=0; i<this.data.length; ++i) {\\\\n            if (typeof this.data[i] === 'string') {\\\\n                this.data[i] = parseFloat(this.data[i]);\\\\n            }\\\\n        }\\\\n\\\\n        this.properties =\\\\n        {\\\\n            'chart.centerx.adjust':         0,\\\\n            'chart.centery.adjust':         0,\\\\n            'chart.colors':                 ['red', '#ccc', '#cfc', 'blue', 'pink', 'yellow', 'black', 'orange', 'cyan', 'purple', '#78CAEA', '#E284E9', 'white', 'blue', '#9E7BF6'],\\\\n            'chart.strokestyle':            'white',\\\\n            'chart.linewidth':              3,\\\\n            'chart.labels':                 [],\\\\n            'chart.labels.bold':            false,\\\\n            'chart.labels.sticks':          false,\\\\n            'chart.labels.sticks.length':   7,\\\\n            'chart.labels.sticks.colors':   null,\\\\n            'chart.labels.sticks.usecolors': true,\\\\n            'chart.labels.sticks.linewidth': 1,\\\\n            'chart.labels.sticks.hlength':  5,\\\\n            'chart.labels.sticks.list':     false,\\\\n            'chart.labels.ingraph':         null,\\\\n            'chart.labels.ingraph.color':   null,\\\\n            'chart.labels.ingraph.font':    null,\\\\n            'chart.labels.ingraph.size':    null,\\\\n            'chart.labels.ingraph.bounding':true,\\\\n            'chart.labels.ingraph.bounding.fill':'white',\\\\n            'chart.labels.ingraph.specific':null,\\\\n            'chart.labels.ingraph.units.pre':'',\\\\n            'chart.labels.ingraph.units.post':'',\\\\n            'chart.labels.ingraph.radius':  null,\\\\n            'chart.labels.center':            null,\\\\n            'chart.labels.center.size':       26,\\\\n            'chart.labels.center.font':       'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.labels.center.color':      'black',\\\\n            'chart.labels.center.italic':     false,\\\\n            'chart.labels.center.bold':       false,\\\\n            'chart.labels.center.units.pre':  '',\\\\n            'chart.labels.center.units.post': '',\\\\n            'chart.gutter.left':            25,\\\\n            'chart.gutter.right':           25,\\\\n            'chart.gutter.top':             25,\\\\n            'chart.gutter.bottom':          25,\\\\n            'chart.title':                  '',\\\\n            'chart.title.background':       null,\\\\n            'chart.title.hpos':             null,\\\\n            'chart.title.vpos':             0.5,\\\\n            'chart.title.bold':             true,\\\\n            'chart.title.font':             null,\\\\n            'chart.title.x':                null,\\\\n            'chart.title.y':                null,\\\\n            'chart.title.halign':           null,\\\\n            'chart.title.valign':           null,\\\\n            'chart.shadow':                 true,\\\\n            'chart.shadow.color':           '#aaa',\\\\n            'chart.shadow.offsetx':         0,\\\\n            'chart.shadow.offsety':         0,\\\\n            'chart.shadow.blur':            15,\\\\n            'chart.text.size':              12,\\\\n            'chart.text.color':             'black',\\\\n            'chart.text.font':              'Segoe UI, Arial, Verdana, sans-serif',\\\\n            'chart.text.accessible':               true,\\\\n            'chart.text.accessible.overflow':      'visible',\\\\n            'chart.text.accessible.pointerevents': true,\\\\n            'chart.contextmenu':            null,\\\\n            'chart.tooltips':               null,\\\\n            'chart.tooltips.event':         'onclick',\\\\n            'chart.tooltips.effect':        'fade',\\\\n            'chart.tooltips.css.class':     'RGraph_tooltip',\\\\n            'chart.tooltips.highlight':     true,\\\\n            'chart.highlight.style':        '2d',\\\\n            'chart.highlight.style.twod.fill':   'rgba(255,255,255,0.7)',\\\\n            'chart.highlight.style.twod.stroke': 'rgba(255,255,255,0.7)',\\\\n            'chart.highlight.style.outline.width': null,\\\\n            'chart.centerx':                null,\\\\n            'chart.centery':                null,\\\\n            'chart.radius':                 null,\\\\n            'chart.border':                 false,\\\\n            'chart.border.color':           'rgba(255,255,255,0.5)',\\\\n            'chart.key':                    null,\\\\n            'chart.key.background':         'white',\\\\n            'chart.key.position':           'graph',\\\\n            'chart.key.halign':             'right',\\\\n            'chart.key.shadow':             false,\\\\n            'chart.key.shadow.color':       '#666',\\\\n            'chart.key.shadow.blur':        3,\\\\n            'chart.key.shadow.offsetx':     2,\\\\n            'chart.key.shadow.offsety':     2,\\\\n            'chart.key.position.gutter.boxed': false,\\\\n            'chart.key.position.x':         null,\\\\n            'chart.key.position.y':         null,\\\\n            'chart.key.color.shape':        'square',\\\\n            'chart.key.rounded':            true,\\\\n            'chart.key.linewidth':          1,\\\\n            'chart.key.colors':             null,\\\\n            'chart.key.interactive':        false,\\\\n            'chart.key.interactive.highlight.chart.stroke': 'black',\\\\n            'chart.key.interactive.highlight.chart.fill': 'rgba(255,255,255,0.7)',\\\\n            'chart.key.interactive.highlight.label': 'rgba(255,0,0,0.2)',\\\\n            'chart.key.text.color':         'black',\\\\n            'chart.annotatable':            false,\\\\n            'chart.annotate.color':         'black',\\\\n            'chart.zoom.factor':            1.5,\\\\n            'chart.zoom.fade.in':           true,\\\\n            'chart.zoom.fade.out':          true,\\\\n            'chart.zoom.hdir':              'right',\\\\n            'chart.zoom.vdir':              'down',\\\\n            'chart.zoom.frames':            25,\\\\n            'chart.zoom.delay':             16.666,\\\\n            'chart.zoom.shadow':            true,\\\\n            'chart.zoom.background':        true,\\\\n            'chart.zoom.action':            'zoom',\\\\n            'chart.resizable':              false,\\\\n            'chart.resize.handle.adjust':   [0,0],\\\\n            'chart.resize.handle.background': null,\\\\n            'chart.variant':                'pie',\\\\n            'chart.variant.donut.width':    null,\\\\n            'chart.variant.threed.depth':   20,\\\\n            'chart.exploded':               [],\\\\n            'chart.effect.roundrobin.multiplier': 1,\\\\n            'chart.events.click':             null,\\\\n            'chart.events.mousemove':         null,\\\\n            'chart.centerpin':                null,\\\\n            'chart.centerpin.fill':           'gray',\\\\n            'chart.centerpin.stroke':         'white',\\\\n            'chart.origin':                   0 - (Math.PI / 2),\\\\n            'chart.events':                   true,\\\\n            'chart.labels.colors':            [],\\\\n            'chart.clearto':   'rgba(0,0,0,0)'\\\\n        }\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Calculate the total\\\\n        */\\\\n        for (var i=0,len=data.length; i<len; i++) {\\\\n            this.total += data[i];\\\\n            \\\\n            // This loop also creates the \\\\\\\$xxx objects - this isn't related to\\\\n            // the code above but just saves doing another loop through the data\\\\n            this['\\\\\\\$' + i] = {};\\\\n        }\\\\n\\\\n\\\\n        /**\\\\n        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen\\\\n        * done already\\\\n        */\\\\n        if (!this.canvas.__rgraph_aa_translated__) {\\\\n            this.context.translate(0.5,0.5);\\\\n\\\\n            this.canvas.__rgraph_aa_translated__ = true;\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        // Short variable names\\\\n        var RG   = RGraph,\\\\n            ca   = this.canvas,\\\\n            co   = ca.getContext('2d'),\\\\n            prop = this.properties,\\\\n            pa2  = RG.path2,\\\\n            win  = window,\\\\n            doc  = document,\\\\n            ma   = Math\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * \\\\\\\"Decorate\\\\\\\" the object with the generic effects if the effects library has been included\\\\n        */\\\\n        if (RG.Effects && typeof RG.Effects.decorate === 'function') {\\\\n            RG.Effects.decorate(this);\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A generic setter\\\\n        */\\\\n        this.set =\\\\n        this.Set = function (name)\\\\n        {\\\\n            var value = typeof arguments[1] === 'undefined' ? null : arguments[1];\\\\n\\\\n            /**\\\\n            * the number of arguments is only one and it's an\\\\n            * object - parse it for configuration data and return.\\\\n            */\\\\n            if (arguments.length === 1 && typeof name === 'object') {\\\\n                RG.parseObjectStyleConfig(this, name);\\\\n                return this;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n\\\\n\\\\n\\\\n            if (name == 'chart.highlight.style.twod.color') {\\\\n                name = 'chart.highlight.style.twod.fill';\\\\n            }\\\\n    \\\\n    \\\\n            if (name == 'chart.labels.spaced') {\\\\n                name = 'chart.labels.sticks.list';\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    \\\\n            prop[name] = value;\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A generic getter\\\\n        */\\\\n        this.get =\\\\n        this.Get = function (name)\\\\n        {\\\\n            /**\\\\n            * This should be done first - prepend the property name with \\\\\\\"chart.\\\\\\\" if necessary\\\\n            */\\\\n            if (name.substr(0,6) != 'chart.') {\\\\n                name = 'chart.' + name;\\\\n            }\\\\n\\\\n            // Convert uppercase letters to dot+lower case letter\\\\n            while(name.match(/([A-Z])/)) {\\\\n                name = name.replace(/([A-Z])/, '.' + RegExp.\\\\\\\$1.toLowerCase());\\\\n            }\\\\n    \\\\n            if (name == 'chart.highlight.style.twod.color') {\\\\n                name = 'chart.highlight.style.twod.fill';\\\\n            }\\\\n    \\\\n            return prop[name];\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This draws the pie chart\\\\n        */\\\\n        this.draw =\\\\n        this.Draw = function ()\\\\n        {\\\\n            /**\\\\n            * Fire the onbeforedraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'onbeforedraw');\\\\n            \\\\n            // NB: Colors are parsed further down so that the center X/Y can be used\\\\n    \\\\n    \\\\n            /**\\\\n            * This is new in May 2011 and facilitates indiviual gutter settings,\\\\n            * eg chart.gutter.left\\\\n            */\\\\n            this.gutterLeft   = prop['chart.gutter.left'];\\\\n            this.gutterRight  = prop['chart.gutter.right'];\\\\n            this.gutterTop    = prop['chart.gutter.top'];\\\\n            this.gutterBottom = prop['chart.gutter.bottom'];\\\\n\\\\n            this.radius     = this.getRadius();// MUST be first\\\\n            this.centerx    = (this.graph.width / 2) + this.gutterLeft + prop['chart.centerx.adjust'];\\\\n            this.centery    = (this.graph.height / 2) + this.gutterTop + prop['chart.centery.adjust'];\\\\n            this.subTotal   = this.properties['chart.origin'];\\\\n            this.angles     = [];\\\\n            this.coordsText = [];\\\\n    \\\\n            /**\\\\n            * Allow specification of a custom radius & center X/Y\\\\n            */\\\\n            if (typeof prop['chart.radius'] === 'number')  this.radius  = prop['chart.radius'];\\\\n            if (typeof prop['chart.centerx'] === 'number') this.centerx = prop['chart.centerx'];\\\\n            if (typeof prop['chart.centery'] === 'number') this.centery = prop['chart.centery'];\\\\n    \\\\n    \\\\n            if (this.radius <= 0) {\\\\n                return;\\\\n            }\\\\n    \\\\n            /**\\\\n            * Parse the colors for gradients. Its down here so that the center X/Y can be used\\\\n            */\\\\n            if (!this.colorsParsed) {\\\\n    \\\\n                this.parseColors();\\\\n    \\\\n                // Don't want to do this again\\\\n                this.colorsParsed = true;\\\\n            }\\\\n\\\\n\\\\n    \\\\n    \\\\n            /**\\\\n            * This sets the label colors. Doing it here saves lots of if() conditions in the draw method\\\\n            */\\\\n            if (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\\\\n                while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\\\\n                    prop['chart.labels.colors'].push(prop['chart.labels.colors'][prop['chart.labels.colors'].length - 1]);\\\\n                }\\\\n            } else {\\\\n                if (typeof prop['chart.labels.colors'] === 'undefined') {\\\\n                    prop['chart.labels.colors'] = [];\\\\n                }\\\\n\\\\n                while (prop['chart.labels.colors'].length < prop['chart.labels'].length) {\\\\n                    prop['chart.labels.colors'].push(prop['chart.text.color']);\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            if (prop['chart.variant'].indexOf('3d') > 0) {\\\\n                return this.draw3d();\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Draw the title\\\\n            */\\\\n            RG.DrawTitle(\\\\n                this,\\\\n                prop['chart.title'],\\\\n                (ca.height / 2) - this.radius - 5,\\\\n                this.centerx,\\\\n                prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2\\\\n            );\\\\n    \\\\n            /**\\\\n            * Draw the shadow if required\\\\n            * \\\\n            * ???\\\\n            */\\\\n            //if (prop['chart.shadow'] && false) {\\\\n            //\\\\n            //    var offsetx = doc.all ? prop['chart.shadow.offsetx'] : 0;\\\\n            //    var offsety = doc.all ? prop['chart.shadow.offsety'] : 0;\\\\n            // \\\\n            //    co.beginPath();\\\\n            //   co.fillStyle = prop['chart.shadow.color'];\\\\n            //\\\\n            //    co.shadowColor   = prop['chart.shadow.color'];\\\\n            //    co.shadowBlur    = prop['chart.shadow.blur'];\\\\n            //    co.shadowOffsetX = prop['chart.shadow.offsetx'];\\\\n            //    co.shadowOffsetY = prop['chart.shadow.offsety'];\\\\n            //   \\\\n            //    co.arc(this.centerx + offsetx, this.centery + offsety, this.radius, 0, TWOPI, 0);\\\\n            //    \\\\n            //    co.fill();\\\\n            //    \\\\n            //    // Now turn off the shadow\\\\n            //    RG.NoShadow(this);\\\\n            //}\\\\n\\\\n            /**\\\\n            * The total of the array of values\\\\n            */\\\\n            this.total = RG.array_sum(this.data);\\\\n            var tot    = this.total;\\\\n            var data   = this.data;\\\\n\\\\n            for (var i=0,len=this.data.length; i<len; i++) {\\\\n                \\\\n                var angle = ((data[i] / tot) * RG.TWOPI);\\\\n    \\\\n                // Draw the segment\\\\n                this.DrawSegment(angle,prop['chart.colors'][i],i == (len - 1), i);\\\\n            }\\\\n\\\\n            RG.NoShadow(this);\\\\n\\\\n            /**\\\\n            * Redraw the seperating lines\\\\n            */\\\\n            if (prop['chart.linewidth'] > 0) {\\\\n                this.DrawBorders();\\\\n            }\\\\n\\\\n            /**\\\\n            * Now draw the segments again with shadow turned off. This is always performed,\\\\n            * not just if the shadow is on.\\\\n            */\\\\n            var len = this.angles.length;\\\\n            var r   = this.radius;\\\\n\\\\n            \\\\n            for (var action=0; action<2; action+=1) {\\\\n                for (var i=0; i<len; i++) {\\\\n    \\\\n                    co.beginPath();\\\\n     \\\\n                    var segment = this.angles[i];\\\\n            \\\\n                        if (action === 1) {\\\\n                            co.strokeStyle = typeof(prop['chart.strokestyle']) == 'object' ? prop['chart.strokestyle'][i] : prop['chart.strokestyle'];\\\\n                        }\\\\n                        prop['chart.colors'][i] ?  co.fillStyle = prop['chart.colors'][i] : null;\\\\n                        co.lineJoin = 'round';\\\\n                        \\\\n                        co.arc(segment[2],\\\\n                               segment[3],\\\\n                               r,\\\\n                               (segment[0]),\\\\n                               (segment[1]),\\\\n                               false);\\\\n                        if (prop['chart.variant'] == 'donut') {\\\\n        \\\\n                            co.arc(\\\\n                                segment[2],\\\\n                                segment[3],\\\\n                                typeof(prop['chart.variant.donut.width']) == 'number' ? r - prop['chart.variant.donut.width'] : r / 2,\\\\n                                (segment[1]),\\\\n                                (segment[0]),\\\\n                                true\\\\n                            );\\\\n                            \\\\n                        } else {\\\\n                            co.lineTo(segment[2], segment[3]);\\\\n                        }\\\\n                    co.closePath();\\\\n                    action === 0 ? co.fill() : co.stroke();\\\\n                }\\\\n            }\\\\n            \\\\n\\\\n    \\\\n\\\\n            /**\\\\n            * Draw label sticks\\\\n            */\\\\n            if (prop['chart.labels.sticks']) {\\\\n                \\\\n                this.DrawSticks();\\\\n    \\\\n                // Redraw the border going around the Pie chart if the stroke style is NOT white\\\\n                var strokeStyle = prop['chart.strokestyle'];\\\\n            }\\\\n\\\\n            /**\\\\n            * Draw the labels\\\\n            */\\\\n            if (prop['chart.labels']) {\\\\n                this.DrawLabels();\\\\n            }\\\\n            \\\\n            \\\\n            /**\\\\n            * Draw centerpin if requested\\\\n            */\\\\n            if (prop['chart.centerpin']) {\\\\n                this.DrawCenterpin();\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Draw ingraph labels\\\\n            */\\\\n            if (prop['chart.labels.ingraph']) {\\\\n                this.DrawInGraphLabels();\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * Draw the center label if requested\\\\n            */\\\\n            if (!RG.isNull(prop['chart.labels.center'])) {\\\\n                this.drawCenterLabel(prop['chart.labels.center']);\\\\n            }\\\\n    \\\\n            \\\\n            /**\\\\n            * Setup the context menu if required\\\\n            */\\\\n            if (prop['chart.contextmenu']) {\\\\n                RG.ShowContext(this);\\\\n            }\\\\n    \\\\n    \\\\n    \\\\n            /**\\\\n            * If a border is pecified, draw it\\\\n            */\\\\n            if (prop['chart.border']) {\\\\n                co.beginPath();\\\\n                co.lineWidth = 5;\\\\n                co.strokeStyle = prop['chart.border.color'];\\\\n    \\\\n                co.arc(this.centerx,\\\\n                       this.centery,\\\\n                       this.radius - 2,\\\\n                       0,\\\\n                       RG.TWOPI,\\\\n                       0);\\\\n    \\\\n                co.stroke();\\\\n            }\\\\n\\\\n            /**\\\\n            * Draw the kay if desired\\\\n            */\\\\n            if (prop['chart.key'] && prop['chart.key'].length) {\\\\n                RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);\\\\n            }\\\\n    \\\\n            RG.NoShadow(this);\\\\n    \\\\n            \\\\n            /**\\\\n            * This function enables resizing\\\\n            */\\\\n            if (prop['chart.resizable']) {\\\\n                RG.AllowResizing(this);\\\\n            }\\\\n    \\\\n    \\\\n            /**\\\\n            * This installs the event listeners\\\\n            */\\\\n            if (prop['chart.events'] == true) {\\\\n                RG.InstallEventListeners(this);\\\\n            }\\\\n    \\\\n\\\\n            /**\\\\n            * Fire the onfirstdraw event\\\\n            */\\\\n            if (this.firstDraw) {\\\\n                RG.fireCustomEvent(this, 'onfirstdraw');\\\\n                this.firstDraw = false;\\\\n                this.firstDrawFunc();\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n            /**\\\\n            * Fire the RGraph ondraw event\\\\n            */\\\\n            RG.FireCustomEvent(this, 'ondraw');\\\\n\\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        /**\\\\n        * Used in chaining. Runs a function there and then - not waiting for\\\\n        * the events to fire (eg the onbeforedraw event)\\\\n        * \\\\n        * @param function func The function to execute\\\\n        */\\\\n        this.exec = function (func)\\\\n        {\\\\n            func(this);\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws a single segment of the pie chart\\\\n        * \\\\n        * @param int degrees The number of degrees for this segment\\\\n        */\\\\n        this.drawSegment =\\\\n        this.DrawSegment = function (radians, color, last, index)\\\\n        {\\\\n            // IE7/8/ExCanvas fix (when there's only one segment the Pie chart doesn't display\\\\n            if (RGraph.ISOLD && radians == RG.TWOPI) {\\\\n                radians -= 0.0001;\\\\n            } else if (RGraph.ISOLD && radians == 0) {\\\\n                radians = 0.001;\\\\n            }\\\\n\\\\n            var subTotal = this.subTotal;\\\\n                radians  = radians * prop['chart.effect.roundrobin.multiplier'];\\\\n    \\\\n            co.beginPath();\\\\n    \\\\n                color ? co.fillStyle   = color : null;\\\\n                co.strokeStyle = prop['chart.strokestyle'];\\\\n                co.lineWidth   = 0;\\\\n    \\\\n                if (prop['chart.shadow']) {\\\\n                    RG.setShadow(\\\\n                        this,\\\\n                        prop['chart.shadow.color'],\\\\n                        prop['chart.shadow.offsetx'],\\\\n                        prop['chart.shadow.offsety'],\\\\n                        prop['chart.shadow.blur']\\\\n                    );\\\\n                }\\\\n    \\\\n                /**\\\\n                * Exploded segments\\\\n                */\\\\n                if ( (typeof(prop['chart.exploded']) == 'object' && prop['chart.exploded'][index] > 0) || typeof(prop['chart.exploded']) == 'number') {\\\\n                    \\\\n                    var explosion = typeof(prop['chart.exploded']) == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][index];\\\\n                    var x         = 0;\\\\n                    var y         = 0;\\\\n                    var h         = explosion;\\\\n                    var t         = subTotal + (radians / 2);\\\\n                    var x         = (Math.cos(t) * explosion);\\\\n                    var y         = (Math.sin(t) * explosion);\\\\n                    var r         = this.radius;\\\\n                \\\\n                    co.moveTo(this.centerx + x, this.centery + y);\\\\n                } else {\\\\n                    var x = 0;\\\\n                    var y = 0;\\\\n                    var r = this.radius;\\\\n                }\\\\n    \\\\n                /**\\\\n                * Calculate the angles\\\\n                */\\\\n                var startAngle = subTotal;\\\\n                var endAngle   = ((subTotal + radians));\\\\n    \\\\n                co.arc(this.centerx + x,\\\\n                       this.centery + y,\\\\n                       r,\\\\n                       startAngle,\\\\n                       endAngle,\\\\n                       0);\\\\n    \\\\n                if (prop['chart.variant'] == 'donut') {\\\\n    \\\\n                    co.arc(this.centerx + x,\\\\n                           this.centery + y,\\\\n                           typeof(prop['chart.variant.donut.width']) == 'number' ? r - prop['chart.variant.donut.width'] : r / 2,\\\\n                           endAngle,\\\\n                           startAngle,\\\\n                           true);\\\\n                } else {\\\\n                    co.lineTo(this.centerx + x, this.centery + y);\\\\n                }\\\\n    \\\\n            co.closePath();\\\\n    \\\\n    \\\\n            // Keep hold of the angles\\\\n            this.angles.push([subTotal, subTotal + radians, this.centerx + x, this.centery + y]);\\\\n    \\\\n    \\\\n            \\\\n            //co.stroke();\\\\n            co.fill();\\\\n    \\\\n            /**\\\\n            * Calculate the segment angle\\\\n            */\\\\n            this.subTotal += radians;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the graphs labels\\\\n        */\\\\n        this.drawLabels =\\\\n        this.DrawLabels = function ()\\\\n        {\\\\n            // New way of spacing labels out\\\\n            if (prop['chart.labels'].length && prop['chart.labels.sticks.list']) {\\\\n                return this.drawLabelsList();\\\\n            }\\\\n\\\\n            var hAlignment = 'left',\\\\n                vAlignment = 'center',\\\\n                labels     = prop['chart.labels'],\\\\n                context    = co,\\\\n                font       = prop['chart.text.font'],\\\\n                bold       = prop['chart.labels.bold'],\\\\n                text_size  = prop['chart.text.size'],\\\\n                cx         = this.centerx,\\\\n                cy         = this.centery,\\\\n                r          = this.radius;\\\\n    \\\\n            /**\\\\n            * Turn the shadow off\\\\n            */\\\\n            RG.noShadow(this);\\\\n            \\\\n            co.fillStyle = 'black';\\\\n            co.beginPath();\\\\n    \\\\n            /**\\\\n            * Draw the labels\\\\n            */\\\\n            if (labels && labels.length) {\\\\n    \\\\n                for (i=0; i<this.angles.length; ++i) {\\\\n                \\\\n                    var segment = this.angles[i];\\\\n                \\\\n                    if (typeof labels[i] != 'string' && typeof labels[i] != 'number') {\\\\n                        continue;\\\\n                    }\\\\n    \\\\n                    // Move to the centre\\\\n                    co.moveTo(cx,cy);\\\\n                    \\\\n                    var a     = segment[0] + ((segment[1] - segment[0]) / 2),\\\\n                        angle = ((segment[1] - segment[0]) / 2) + segment[0];\\\\n    \\\\n                    /**\\\\n                    * Handle the additional \\\\\\\"explosion\\\\\\\" offset\\\\n                    */\\\\n                    if (typeof prop['chart.exploded'] === 'object' && prop['chart.exploded'][i] || typeof prop['chart.exploded'] == 'number') {\\\\n    \\\\n                        var t          = ((segment[1] - segment[0]) / 2),\\\\n                            seperation = typeof(prop['chart.exploded']) == 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i];\\\\n    \\\\n                        // Adjust the angles\\\\n                        var explosion_offsetx = (Math.cos(angle) * seperation),\\\\n                            explosion_offsety = (Math.sin(angle) * seperation);\\\\n                    } else {\\\\n                        var explosion_offsetx = 0,\\\\n                            explosion_offsety = 0;\\\\n                    }\\\\n                    \\\\n                    /**\\\\n                    * Allow for the label sticks\\\\n                    */\\\\n                    if (prop['chart.labels.sticks']) {\\\\n                        explosion_offsetx += (ma.cos(angle) * (typeof prop['chart.labels.sticks.length'] === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']) );\\\\n                        explosion_offsety += (ma.sin(angle) * (typeof prop['chart.labels.sticks.length'] === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length']) );\\\\n                    }\\\\n    \\\\n                    /**\\\\n                    * Coords for the text\\\\n                    */\\\\n                    var x = cx + explosion_offsetx + ((r + 10)* Math.cos(a)) + (prop['chart.labels.sticks'] ? (a < RG.HALFPI || a > (RG.TWOPI + RG.HALFPI) ? 2 : -2) : 0),\\\\n                        y = cy + explosion_offsety + (((r + 10) * Math.sin(a)));\\\\n\\\\n\\\\n\\\\n\\\\n                    /**\\\\n                    *  If sticks are enabled use the endpoints that have been saved\\\\n                    */\\\\n                    if (this.coordsSticks && this.coordsSticks[i]) {\\\\n                        var x = this.coordsSticks[i][4][0] + (x < cx ? -5 : 5),\\\\n                            y = this.coordsSticks[i][4][1];\\\\n                    }\\\\n\\\\n\\\\n                    /**\\\\n                    * Alignment\\\\n                    */\\\\n                    //vAlignment = y < cy ? 'center' : 'center';\\\\n                    vAlignment = 'center';\\\\n                    hAlignment = x < cx ? 'right' : 'left';\\\\n    \\\\n                    co.fillStyle = prop['chart.text.color'];\\\\n                    if (   typeof prop['chart.labels.colors'] === 'object' && prop['chart.labels.colors'] && prop['chart.labels.colors'][i]) {\\\\n                        co.fillStyle = prop['chart.labels.colors'][i];\\\\n                    }\\\\n    \\\\n\\\\n                    RG.text2(this, {\\\\n                          font: font,\\\\n                          size: text_size,\\\\n                             x: x,\\\\n                             y: y,\\\\n                          text: labels[i],\\\\n                        valign: vAlignment,\\\\n                        halign: hAlignment,\\\\n                           tag: 'labels',\\\\n                          bold: bold,\\\\n                         color: prop['chart.labels.sticks.usecolors'] ? prop['chart.colors'][i] : 'black'\\\\n                    });\\\\n                }\\\\n                \\\\n                co.fill();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        //\\\\n        // A new way of spacing out labels\\\\n        //\\\\n        this.drawLabelsList = function ()\\\\n        {\\\\n            var segment      = this.angles[i],\\\\n                labels       = prop['chart.labels'],\\\\n                labels_right = [],\\\\n                labels_left  = [],\\\\n                text_font    = prop['chart.text.font'],\\\\n                text_size    = prop['chart.text.size'],\\\\n                text_color   = prop['chart.text.color'],\\\\n                left         = [],\\\\n                right        = [],\\\\n                centerx      = this.centerx,\\\\n                centery      = this.centery,\\\\n                radius       = this.radius,\\\\n                offset       = 50\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            //\\\\n            // Draw the right hand side labels first\\\\n            //\\\\n            for (var i=0; i<this.angles.length; ++i) {\\\\n\\\\n                var angle          = this.angles[i][0] + ((this.angles[i][1] - this.angles[i][0]) / 2), // Midpoint\\\\n                    endpoint_inner = RG.getRadiusEndPoint(centerx, centery, angle, radius + 5),\\\\n                    endpoint_outer = RG.getRadiusEndPoint(centerx, centery, angle, radius + 10),\\\\n                    explosion      = [\\\\n                        (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i]),\\\\n                        (ma.cos(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i])),\\\\n                        (ma.sin(angle) * (typeof prop['chart.exploded'] === 'number' ? prop['chart.exploded'] : prop['chart.exploded'][i]))\\\\n                    ]\\\\n\\\\n                \\\\n                //\\\\n                // Work out the color\\\\n                //\\\\n                if ( typeof prop['chart.labels.sticks.colors'] === 'object' && prop['chart.labels.sticks.colors'] && prop['chart.labels.sticks.colors'][i] ) {\\\\n                    var color = prop['chart.labels.sticks.colors'][i];\\\\n                } else if ( prop['chart.labels.sticks.usecolors'] && prop['chart.colors'][i] ) {\\\\n                    var color = prop['chart.colors'][i];\\\\n                } else {\\\\n                    var color = prop['chart.text.color'];\\\\n                }\\\\n\\\\n                \\\\n                \\\\n\\\\n                if (angle > (-1 * RG.HALFPI) && angle < RG.HALFPI) {\\\\n                    labels_right.push([\\\\n                        i,\\\\n                        angle,\\\\n                        labels[i] ? labels[i] : '',\\\\n                        endpoint_inner,\\\\n                        endpoint_outer,\\\\n                        color,\\\\n                        RG.arrayClone(explosion)\\\\n                    ]);\\\\n                } else {\\\\n                    labels_left.push([\\\\n                        i,\\\\n                        angle,\\\\n                        labels[i] ? labels[i] : '',\\\\n                        endpoint_inner,\\\\n                        endpoint_outer,\\\\n                        color,\\\\n                        RG.arrayClone(explosion)\\\\n                    ]);\\\\n                }\\\\n            }\\\\n\\\\n\\\\n            \\\\n            \\\\n            //\\\\n            // Draw the right hand side labels first\\\\n            //\\\\n\\\\n\\\\n            // Calculate how much space there is for each label\\\\n            var vspace_right = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_right.length\\\\n\\\\n            for (var i=0,y=(prop['chart.gutter.top'] + (vspace_right / 2)); i<labels_right.length; y+=vspace_right,i++) {\\\\n                \\\\n                if (labels_right[i][2]) {\\\\n\\\\n                    var x          = this.centerx + this.radius + offset,\\\\n                        idx        = labels_right[i][0],\\\\n                        explosionX = labels_right[i][6][0] ? labels_right[i][6][1] : 0,\\\\n                        explosionY = labels_right[i][6][0] ? labels_right[i][6][2] : 0\\\\n\\\\n                    var ret = RG.text2(this, {\\\\n                        font:   text_font,\\\\n                        size:   text_size,\\\\n                        x:      x + explosionX,\\\\n                        y:      y + explosionY,\\\\n                        text:   labels_right[i][2],\\\\n                        valign: 'center',\\\\n                        halign: 'left',\\\\n                        tag:    'labels',\\\\n                        color:  labels_right[i][5]\\\\n                    });\\\\n                    \\\\n                    if (ret && ret.node) {\\\\n                        ret.node.__index__ = labels_right[i][0];\\\\n                    }\\\\n\\\\n    \\\\n                    pa2(co, 'lc round lw % b m % % l % % l % % l % % s %',\\\\n                        \\\\n                        prop['chart.labels.sticks.linewidth'],\\\\n                        \\\\n                        labels_right[i][3][0] + explosionX,\\\\n                        labels_right[i][3][1] + explosionY,\\\\n    \\\\n                        labels_right[i][4][0] + explosionX,\\\\n                        labels_right[i][4][1] + explosionY,\\\\n                        \\\\n                        this.centerx + this.radius + 25 + explosionX,\\\\n                        ma.round(labels_right[i][4][1] + explosionY),\\\\n                        \\\\n                        ret.x - 5 ,\\\\n                        ret.y + (ret.height / 2),\\\\n    \\\\n                        labels_right[i][5]\\\\n                    );\\\\n                }\\\\n            }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n            //\\\\n            // Draw the left hand side labels\\\\n            //\\\\n            \\\\n            \\\\n            \\\\n            \\\\n            \\\\n            // Calculate how much space there is for each label\\\\n            var vspace_left = (ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / labels_left.length\\\\n\\\\n            for (var i=(labels_left.length - 1),y=(prop['chart.gutter.top'] + (vspace_left / 2)); i>=0; y+=vspace_left,i--) {\\\\n\\\\n                if (labels_left[i][2]) {\\\\n\\\\n                    var x = this.centerx - this.radius - offset,\\\\n                        idx        = labels_left[i][0],\\\\n                        explosionX = labels_left[i][6][0] ? labels_left[i][6][1] : 0,\\\\n                        explosionY = labels_left[i][6][0] ? labels_left[i][6][2] : 0\\\\n                    \\\\n                    var ret = RG.text2(this, {\\\\n                        font:   text_font,\\\\n                        size:   text_size,\\\\n                        x:      x + explosionX,\\\\n                        y:      y + explosionY,\\\\n                        text:   labels_left[i][2],\\\\n                        valign: 'center',\\\\n                        halign: 'right',\\\\n                        tag:    'labels',\\\\n                        color:  labels_left[i][5]\\\\n                    });\\\\n                    \\\\n                    if (ret && ret.node) {\\\\n                        ret.node.__index__ = labels_left[i][0];\\\\n                    }\\\\n    \\\\n                    pa2(co,\\\\n                        'lw % b m % % l % % l % % l % % s %',\\\\n                        \\\\n                        prop['chart.labels.sticks.linewidth'],\\\\n                        \\\\n                        labels_left[i][3][0] + explosionX,\\\\n                        labels_left[i][3][1] + explosionY,\\\\n    \\\\n                        labels_left[i][4][0] + explosionX,\\\\n                        labels_left[i][4][1] + explosionY,\\\\n                        \\\\n                        this.centerx - this.radius - 25 + explosionX,\\\\n                        ma.round(labels_left[i][4][1] + explosionY),\\\\n                        \\\\n                        ret.x + 5 + ret.width,\\\\n                        ret.y + (ret.height / 2),\\\\n    \\\\n                        labels_left[i][5]\\\\n                    );\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function draws the pie chart sticks (for the labels)\\\\n        */\\\\n        this.drawSticks =\\\\n        this.DrawSticks = function ()\\\\n        {\\\\n            var offset    = prop['chart.linewidth'] / 2,\\\\n                exploded  = prop['chart.exploded'],\\\\n                sticks    = prop['chart.labels.sticks'],\\\\n                colors    = prop['chart.colors'],\\\\n                cx        = this.centerx,\\\\n                cy        = this.centery,\\\\n                radius     = this.radius,\\\\n                points     = [],\\\\n                linewidth  = prop['chart.labels.sticks.linewidth']\\\\n\\\\n            for (var i=0,len=this.angles.length; i<len; ++i) {\\\\n            \\\\n                var segment = this.angles[i];\\\\n    \\\\n                // This allows the chart.labels.sticks to be an array as well as a boolean\\\\n                if (typeof sticks === 'object' && !sticks[i]) {\\\\n                    continue;\\\\n                }\\\\n    \\\\n                var radians = segment[1] - segment[0];\\\\n    \\\\n                co.beginPath();\\\\n                co.strokeStyle = typeof prop['chart.labels.sticks.colors'] === 'string' ? prop['chart.labels.sticks.colors'] : (!RG.isNull(prop['chart.labels.sticks.colors']) ? prop['chart.labels.sticks.colors'][i] : 'gray');\\\\n                co.lineWidth   = linewidth;\\\\n                \\\\n                if (typeof prop['chart.labels.sticks.color'] === 'string') {\\\\n                    co.strokeStyle = prop['chart.labels.sticks.color'];\\\\n                }\\\\n\\\\n                //\\\\n                // Allow for labelsSticksUseColors\\\\n                //\\\\n                if (prop['chart.labels.sticks.usecolors']) {\\\\n                    co.strokeStyle = prop['chart.colors'][i];\\\\n                }\\\\n    \\\\n                var midpoint = (segment[0] + (radians / 2));\\\\n    \\\\n                if (typeof exploded === 'object' && exploded[i]) {\\\\n                    var extra = exploded[i];\\\\n                } else if (typeof exploded === 'number') {\\\\n                    var extra = exploded;\\\\n                } else {\\\\n                    var extra = 0;\\\\n                }\\\\n                \\\\n                /**\\\\n                * Determine the stick length\\\\n                */\\\\n                var stickLength = typeof prop['chart.labels.sticks.length'] === 'object' ? prop['chart.labels.sticks.length'][i] : prop['chart.labels.sticks.length'];\\\\n                \\\\n                \\\\n                points[0] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + extra + offset);\\\\n                points[1] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra - 5);\\\\n                \\\\n                points[2] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);\\\\n                \\\\n                points[3] = RG.getRadiusEndPoint(cx, cy, midpoint, radius + stickLength + extra);\\\\n                points[3][0] += (points[3][0] > cx ? 5 : -5);\\\\n                \\\\n                points[4] = [\\\\n                    points[2][0] + (points[2][0] > cx ? 5 + prop['chart.labels.sticks.hlength'] : -5 - prop['chart.labels.sticks.hlength']),\\\\n                    points[2][1]\\\\n                ];\\\\n\\\\n                \\\\n                co.moveTo(points[0][0], points[0][1]);\\\\n                co.quadraticCurveTo(points[2][0], points[2][1], points[4][0], points[4][1]);\\\\n    \\\\n                co.stroke();\\\\n                \\\\n                /**\\\\n                * Save the stick end coords\\\\n                */\\\\n                this.coordsSticks[i] = [points[0],points[1], points[2], points[3], points[4]];\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The (now Pie chart specific) getSegment function\\\\n        * \\\\n        * @param object e The event object\\\\n        */\\\\n        this.getShape =\\\\n        this.getSegment = function (e)\\\\n        {\\\\n            RG.FixEventObject(e);\\\\n    \\\\n            // The optional arg provides a way of allowing some accuracy (pixels)\\\\n            var accuracy = arguments[1] ? arguments[1] : 0;\\\\n    \\\\n            var canvas      = ca;\\\\n            var context     = co;\\\\n            var mouseCoords = RG.getMouseXY(e);\\\\n            var mouseX      = mouseCoords[0];\\\\n            var mouseY      = mouseCoords[1];\\\\n            var r           = this.radius;\\\\n            var angles      = this.angles;\\\\n            var ret         = [];\\\\n    \\\\n            for (var i=0,len=angles.length; i<len; ++i) {\\\\n    \\\\n                // DRAW THE SEGMENT AGAIN SO IT CAN BE TESTED //////////////////////////\\\\n                co.beginPath();\\\\n                    co.strokeStyle = 'rgba(0,0,0,0)';\\\\n                    co.arc(angles[i][2], angles[i][3], this.radius, angles[i][0], angles[i][1], false);\\\\n                    \\\\n                    if (this.type == 'pie' && prop['chart.variant'] == 'donut') {\\\\n                        co.arc(angles[i][2], angles[i][3], (typeof(prop['chart.variant.donut.width']) == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2), angles[i][1], angles[i][0], true);\\\\n                    } else {\\\\n                        co.lineTo(angles[i][2], angles[i][3]);\\\\n                    }\\\\n                co.closePath();\\\\n                    \\\\n                if (!co.isPointInPath(mouseX, mouseY)) {\\\\n                    continue;\\\\n                }\\\\n    \\\\n                ////////////////////////////////////////////////////////////////////////\\\\n    \\\\n                ret[0] = angles[i][2];\\\\n                ret[1] = angles[i][3];\\\\n                ret[2] = this.radius;\\\\n                ret[3] = angles[i][0] - RG.TWOPI;\\\\n                ret[4] = angles[i][1];\\\\n                ret[5] = i;\\\\n    \\\\n    \\\\n                \\\\n                if (ret[3] < 0) ret[3] += RG.TWOPI;\\\\n                if (ret[4] > RG.TWOPI) ret[4] -= RG.TWOPI;\\\\n                \\\\n                /**\\\\n                * Add the tooltip to the returned shape\\\\n                */\\\\n                var tooltip = RG.parseTooltipText ? RG.parseTooltipText(prop['chart.tooltips'], ret[5]) : null;\\\\n                \\\\n                /**\\\\n                * Now return textual keys as well as numerics\\\\n                */\\\\n                ret['object']      = this;\\\\n                ret['x']           = ret[0];\\\\n                ret['y']           = ret[1];\\\\n                ret['radius']      = ret[2];\\\\n                ret['angle.start'] = ret[3];\\\\n                ret['angle.end']   = ret[4];\\\\n                ret['index']       = ret[5];\\\\n                ret['tooltip']     = tooltip;\\\\n    \\\\n                return ret;\\\\n            }\\\\n            \\\\n            return null;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        this.drawBorders =\\\\n        this.DrawBorders = function ()\\\\n        {\\\\n            if (prop['chart.linewidth'] > 0) {\\\\n    \\\\n                co.lineWidth = prop['chart.linewidth'];\\\\n                co.strokeStyle = prop['chart.strokestyle'];\\\\n                \\\\n                var r = this.radius;\\\\n    \\\\n                for (var i=0,len=this.angles.length; i<len; ++i) {\\\\n                \\\\n                    var segment = this.angles[i];\\\\n\\\\n                    co.beginPath();\\\\n                        co.arc(segment[2],\\\\n                               segment[3],\\\\n                               r,\\\\n                               (segment[0]),\\\\n                               (segment[0] + 0.001),\\\\n                               0);\\\\n                        co.arc(segment[2],\\\\n                               segment[3],\\\\n                               prop['chart.variant'] == 'donut' ? (typeof(prop['chart.variant.donut.width']) == 'number' ? this.radius - prop['chart.variant.donut.width'] : r / 2): r,\\\\n                               segment[0],\\\\n                               segment[0] + 0.0001,\\\\n                               0);\\\\n                    co.closePath();\\\\n                    co.stroke();\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Returns the radius of the pie chart\\\\n        * \\\\n        * [06-02-2012] Maintained for compatibility ONLY.\\\\n        */\\\\n        this.getRadius = function ()\\\\n        {\\\\n            this.graph = {width: ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], height: ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']}\\\\n    \\\\n            if (typeof(prop['chart.radius']) == 'number') {\\\\n                this.radius = prop['chart.radius'];\\\\n            } else {\\\\n                this.radius = Math.min(this.graph.width, this.graph.height) / 2;\\\\n            }\\\\n    \\\\n            return this.radius;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * A programmatic explode function\\\\n        * \\\\n        * @param object obj   The chart object\\\\n        * @param number index The zero-indexed number of the segment\\\\n        * @param number size  The size (in pixels) of the explosion\\\\n        */\\\\n        this.explodeSegment =\\\\n        this.Explode = function (index, size)\\\\n        {\\\\n            if (typeof this.exploding === 'number' && this.exploding === index) {\\\\n                return;\\\\n            }\\\\n\\\\n            //this.Set('chart.exploded', []);\\\\n            if (!prop['chart.exploded']) {\\\\n                prop['chart.exploded'] = [];\\\\n            }\\\\n            \\\\n            // If chart.exploded is a number - convert it to an array\\\\n            if (typeof(prop['chart.exploded']) == 'number') {\\\\n    \\\\n                var original_explode = prop['chart.exploded'];\\\\n                var exploded = prop['chart.exploded'];\\\\n    \\\\n                prop['chart.exploded'] = [];\\\\n                \\\\n                for (var i=0,len=this.data.length; i<len; ++i) {\\\\n                    prop['chart.exploded'][i] = exploded;\\\\n                }\\\\n            }\\\\n            \\\\n            prop['chart.exploded'][index] = typeof(original_explode) == 'number' ? original_explode : 0;\\\\n    \\\\n            this.exploding = index;\\\\n            var delay = RG.ISIE && !RG.ISIE10 ? 25 : 16.666;\\\\n\\\\n            for (var o=0; o<size; ++o) {\\\\n    \\\\n                setTimeout(\\\\n                    function ()\\\\n                    {\\\\n                        prop['chart.exploded'][index] += 1;\\\\n                        RG.Clear(ca);\\\\n                        RG.RedrawCanvas(ca);\\\\n                    }, o * delay);\\\\n            }\\\\n            \\\\n            var obj = this;\\\\n            setTimeout(function ()\\\\n            {\\\\n                obj.exploding = null;\\\\n            }, size * delay);\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function highlights a segment\\\\n        * \\\\n        * @param array segment The segment information that is returned by the pie.getSegment(e) function\\\\n        */\\\\n        this.highlight_segment = function (segment)\\\\n        {\\\\n            co.beginPath();\\\\n                co.strokeStyle = prop['chart.highlight.style.twod.stroke'];\\\\n                co.fillStyle   = prop['chart.highlight.style.twod.fill'];\\\\n                co.moveTo(segment[0], segment[1]);\\\\n                co.arc(segment[0], segment[1], segment[2], this.angles[segment[5]][0], this.angles[segment[5]][1], 0);\\\\n                co.lineTo(segment[0], segment[1]);\\\\n            co.closePath();\\\\n            \\\\n            co.stroke();\\\\n            co.fill();\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Each object type has its own Highlight() function which highlights\\\\n        * the appropriate shape\\\\n        * \\\\n        * @param object shape The shape to highlight\\\\n        */\\\\n        this.highlight =\\\\n        this.Highlight = function (shape)\\\\n        {\\\\n            if (prop['chart.tooltips.highlight']) {\\\\n                \\\\n                if (typeof prop['chart.highlight.style'] === 'function') {\\\\n                    (prop['chart.highlight.style'])(shape);\\\\n\\\\n                /**\\\\n                * 3D style of highlighting\\\\n                */\\\\n                } else if (prop['chart.highlight.style'] == '3d') {\\\\n\\\\n                    co.lineWidth = 1;\\\\n                    \\\\n                    // This is the extent of the 2D effect. Bigger values will give the appearance of a larger \\\\\\\"protusion\\\\\\\"\\\\n                    var extent = 2;\\\\n            \\\\n                    // Draw a white-out where the segment is\\\\n                    co.beginPath();\\\\n                        RG.NoShadow(this);\\\\n                        co.fillStyle   = 'rgba(0,0,0,0)';\\\\n                        co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);\\\\n                        if (prop['chart.variant'] == 'donut') {\\\\n                            co.arc(shape['x'], shape['y'], shape['radius'] / 5, shape['angle.end'], shape['angle.start'], true);\\\\n                        } else {\\\\n                            co.lineTo(shape['x'], shape['y']);\\\\n                        }\\\\n                    co.closePath();\\\\n                    co.fill();\\\\n        \\\\n                    // Draw the new segment\\\\n                    co.beginPath();\\\\n        \\\\n                        co.shadowColor   = '#666';\\\\n                        co.shadowBlur    = 3;\\\\n                        co.shadowOffsetX = 3;\\\\n                        co.shadowOffsetY = 3;\\\\n        \\\\n                        co.fillStyle   = prop['chart.colors'][shape['index']];\\\\n                        co.strokeStyle = prop['chart.strokestyle'];\\\\n                        co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'], shape['angle.start'], shape['angle.end'], false);\\\\n                        if (prop['chart.variant'] == 'donut') {\\\\n                            co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] / 2, shape['angle.end'], shape['angle.start'],  true)\\\\n                        } else {\\\\n                            co.lineTo(shape['x'] - extent, shape['y'] - extent);\\\\n                        }\\\\n                    co.closePath();\\\\n                    \\\\n                    co.stroke();\\\\n                    co.fill();\\\\n                    \\\\n                    // Turn off the shadow\\\\n                    RG.NoShadow(this);\\\\n        \\\\n                    /**\\\\n                    * If a border is defined, redraw that\\\\n                    */\\\\n                    if (prop['chart.border']) {\\\\n                        co.beginPath();\\\\n                        co.strokeStyle = prop['chart.border.color'];\\\\n                        co.lineWidth = 5;\\\\n                        co.arc(shape['x'] - extent, shape['y'] - extent, shape['radius'] - 2, shape['angle.start'], shape['angle.end'], false);\\\\n                        co.stroke();\\\\n                    }\\\\n                \\\\n\\\\n\\\\n\\\\n                // Outline style of highlighting\\\\n                } else if (prop['chart.highlight.style'] === 'outline') {\\\\n            \\\\n                    var tooltip = RG.Registry.get('chart.tooltip'),\\\\n                        index   = tooltip.__index__,\\\\n                        coords  = this.angles[index],\\\\n                        color   = this.get('colors')[index]\\\\n                        width   = this.radius / 12.5;\\\\n                    \\\\n                    // Allow custom setting of outline\\\\n                    if (typeof prop['chart.highlight.style.outline.width'] === 'number') {\\\\n                        width = prop['chart.highlight.style.outline.width'];\\\\n                    }\\\\n\\\\n\\\\n\\\\n                    RGraph.path2(\\\\n                        co,\\\\n                        'ga 0.25 b a % % % % % false a % % % % % true c f % ga 1',\\\\n                        coords[2],\\\\n                        coords[3],\\\\n                        this.radius + 2 + width,\\\\n                        coords[0],\\\\n                        coords[1],\\\\n                        \\\\n                        coords[2],\\\\n                        coords[3],\\\\n                        this.radius + 2,\\\\n                        coords[1],\\\\n                        coords[0],\\\\n                        color\\\\n                    );\\\\n        \\\\n        \\\\n        \\\\n        \\\\n        \\\\n        \\\\n                // Default 2D style of  highlighting\\\\n                } else {\\\\n\\\\n                    co.beginPath();\\\\n    \\\\n                        co.strokeStyle = prop['chart.highlight.style.twod.stroke'];\\\\n                        co.fillStyle   = prop['chart.highlight.style.twod.fill'];\\\\n\\\\n                        if (prop['chart.variant'].indexOf('donut') > -1) {\\\\n                            co.arc(shape['x'], shape['y'], shape['radius'], shape['angle.start'], shape['angle.end'], false);\\\\n                            co.arc(shape['x'], shape['y'], typeof(prop['chart.variant.donut.width']) == 'number' ? this.radius - prop['chart.variant.donut.width'] : shape['radius'] / 2, shape['angle.end'], shape['angle.start'], true);\\\\n                        } else {\\\\n                            co.arc(shape['x'], shape['y'], shape['radius'] + 1, shape['angle.start'], shape['angle.end'], false);\\\\n                            co.lineTo(shape['x'], shape['y']);\\\\n                        }\\\\n                    co.closePath();\\\\n        \\\\n                    co.stroke();\\\\n                    co.fill();\\\\n                }\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * The getObjectByXY() worker method. The Pie chart is able to use the\\\\n        * getShape() method - so it does.\\\\n        */\\\\n        this.getObjectByXY = function (e)\\\\n        {\\\\n            if (this.getShape(e)) {\\\\n                return this;\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Draws the centerpin if requested\\\\n        */\\\\n        this.drawCenterpin =\\\\n        this.DrawCenterpin = function ()\\\\n        {\\\\n            if (typeof(prop['chart.centerpin']) == 'number' && prop['chart.centerpin'] > 0) {\\\\n            \\\\n                var cx = this.centerx;\\\\n                var cy = this.centery;\\\\n            \\\\n                co.beginPath();\\\\n                    co.strokeStyle = prop['chart.centerpin.stroke'] ? prop['chart.centerpin.stroke'] : prop['chart.strokestyle'];\\\\n                    co.fillStyle = prop['chart.centerpin.fill'] ? prop['chart.centerpin.fill'] : prop['chart.strokestyle'];\\\\n                    co.moveTo(cx, cy);\\\\n                    co.arc(cx, cy, prop['chart.centerpin'], 0, RG.TWOPI, false);\\\\n                co.stroke();\\\\n                co.fill();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function positions a tooltip when it is displayed\\\\n        * \\\\n        * @param obj object    The chart object\\\\n        * @param int x         The X coordinate specified for the tooltip\\\\n        * @param int y         The Y coordinate specified for the tooltip\\\\n        * @param objec tooltip The tooltips DIV element\\\\n        *\\\\n        this.positionTooltip = function (obj, x, y, tooltip, idx)\\\\n        {\\\\n            var coordX      = obj.angles[idx][2];\\\\n            var coordY      = obj.angles[idx][3];\\\\n            var mouseXY     = RG.getMouseXY(window.event);\\\\n            var angleStart  = obj.angles[idx][0];\\\\n            var angleEnd    = obj.angles[idx][1];\\\\n            var angleCenter = ((angleEnd - angleStart) / 2) + angleStart;\\\\n            var canvasXY    = RGraph.getCanvasXY(obj.canvas);\\\\n            var gutterLeft  = prop['chart.gutter.left'];\\\\n            var gutterTop   = prop['chart.gutter.top'];\\\\n            var width       = tooltip.offsetWidth;\\\\n            var height      = tooltip.offsetHeight;\\\\n            var x           = canvasXY[0] + this.angles[idx][2] + (Math.cos(angleCenter) * (prop['chart.variant'] == 'donut' && typeof(prop['chart.variant.donut.width']) == 'number' ? ((this.radius - prop['chart.variant.donut.width']) + (prop['chart.variant.donut.width'] / 2)) : (this.radius * 0.5)));\\\\n            var y           = canvasXY[1] + this.angles[idx][3] + (Math.sin(angleCenter) * (prop['chart.variant'] == 'donut' && typeof(prop['chart.variant.donut.width']) == 'number' ? ((this.radius - prop['chart.variant.donut.width']) + (prop['chart.variant.donut.width'] / 2)) : (this.radius * 0.5)));\\\\n    \\\\n            \\\\n            // By default any overflow is hidden\\\\n            tooltip.style.overflow = '';\\\\n\\\\n            // Set the top position\\\\n            tooltip.style.left = 0;\\\\n            tooltip.style.top  = window.event.pageY - height - 5 + 'px';\\\\n\\\\n            \\\\n            // Reposition the tooltip if at the edges:\\\\n    \\\\n            // LEFT edge\\\\n            if (canvasXY[0] + mouseXY[0] - (width / 2) < 0) {\\\\n                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width * 0.1) + 'px';\\\\n    \\\\n            // RIGHT edge\\\\n            } else if (canvasXY[0] + mouseXY[0]  + (width / 2) > doc.body.offsetWidth) {\\\\n                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width * 0.9) + 'px';\\\\n    \\\\n            // Default positioning - CENTERED\\\\n            } else {\\\\n                tooltip.style.left = canvasXY[0] + mouseXY[0]  - (width / 2) + 'px';\\\\n            }\\\\n        };*/\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This draws Ingraph labels\\\\n        */\\\\n        this.drawInGraphLabels =\\\\n        this.DrawInGraphLabels = function ()\\\\n        {\\\\n            var context = co;\\\\n            var cx      = this.centerx;\\\\n            var cy      = this.centery;\\\\n            var radius  = prop['chart.labels.ingraph.radius'];\\\\n            \\\\n            //\\\\n            // Is the radius less than 2? If so then it's a factor and not n exact point\\\\n            //\\\\n            if (radius <= 2 && radius > 0) {\\\\n                radiusFactor = radius;\\\\n            } else {\\\\n                radiusFactor = 0.5;\\\\n            }\\\\n\\\\n            if (prop['chart.variant'] == 'donut') {\\\\n                var r = this.radius * (0.5 + (radiusFactor * 0.5));\\\\n                \\\\n                if (typeof(prop['chart.variant.donut.width']) == 'number') {\\\\n                    var r = (this.radius - prop['chart.variant.donut.width']) + (prop['chart.variant.donut.width'] / 2);\\\\n                }\\\\n            } else {\\\\n                var r = this.radius * radiusFactor;\\\\n            }\\\\n\\\\n            if (radius > 2) {\\\\n                r = radius;\\\\n            }\\\\n    \\\\n            for (var i=0,len=this.angles.length; i<len; ++i) {\\\\n    \\\\n                // This handles any explosion that the segment may have\\\\n                if (typeof(prop['chart.exploded']) == 'object' && typeof(prop['chart.exploded'][i]) == 'number') {\\\\n                    var explosion = prop['chart.exploded'][i];\\\\n                } else if (typeof(prop['chart.exploded']) == 'number') {\\\\n                    var explosion = parseInt(prop['chart.exploded']);\\\\n                } else {\\\\n                    var explosion = 0;\\\\n                }\\\\n    \\\\n                var angleStart  = this.angles[i][0];\\\\n                var angleEnd    = this.angles[i][1];\\\\n                var angleCenter = ((angleEnd - angleStart) / 2) + angleStart;\\\\n                var coords      = RG.getRadiusEndPoint(\\\\n                    this.centerx,\\\\n                    this.centery,\\\\n                    angleCenter,\\\\n                    r + (explosion ? explosion : 0)\\\\n                );\\\\n\\\\n                var x           = coords[0];\\\\n                var y           = coords[1];\\\\n    \\\\n                var text = prop['chart.labels.ingraph.specific'] && typeof(prop['chart.labels.ingraph.specific'][i]) == 'string' ? prop['chart.labels.ingraph.specific'][i] : RG.number_format(this, this.data[i], prop['chart.labels.ingraph.units.pre'] , prop['chart.labels.ingraph.units.post']);\\\\n    \\\\n                if (text) {\\\\n                    co.beginPath();\\\\n                        \\\\n                        var font = typeof prop['chart.labels.ingraph.font'] === 'string' ? prop['chart.labels.ingraph.font'] : prop['chart.text.font'];\\\\n                        var size = typeof prop['chart.labels.ingraph.size'] === 'number' ? prop['chart.labels.ingraph.size'] : prop['chart.text.size'] + 2;\\\\n                        \\\\n                        //\\\\n                        // Set the colors\\\\n                        //\\\\n                        co.fillStyle = prop['chart.labels.ingraph.color'] ? prop['chart.labels.ingraph.color'] : 'black';\\\\n    \\\\n                        RG.Text2(this, {\\\\n                            'font':font,\\\\n                            'size':size,\\\\n                            'x':x,\\\\n                            'y':y,\\\\n                            'text':text,\\\\n                            'valign':'center',\\\\n                            'halign':'center',\\\\n                            'bounding': prop['chart.labels.ingraph.bounding'],\\\\n                            'bounding.fill': prop['chart.labels.ingraph.bounding.fill'],\\\\n                            'tag':'labels.ingraph'\\\\n                        });\\\\n                    co.stroke();\\\\n                }\\\\n            }\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        \\\\n        //\\\\n        // Draws the center label if required\\\\n        //\\\\n        this.drawCenterLabel = function (label)\\\\n        {\\\\n            var font      = prop['chart.labels.center.font'],\\\\n                size      = prop['chart.labels.center.size'],\\\\n                color     = prop['chart.labels.center.color'],\\\\n                unitsPre  = prop['chart.labels.center.units.pre'],\\\\n                unitsPost = prop['chart.labels.center.units.post'],\\\\n                bold      = prop['chart.labels.center.bold'],\\\\n                italic    = prop['chart.labels.center.italic'];\\\\n\\\\n\\\\n            RG.text2(this, {\\\\n                color: color,\\\\n                bold: bold,\\\\n                italic: italic,\\\\n                font: font,\\\\n                size: size,\\\\n                x: this.centerx,\\\\n                y: this.centery,\\\\n                halign: 'center',\\\\n                valign: 'center',\\\\n                text: RG.numberFormat(this, label,unitsPre, unitsPost)\\\\n            });\\\\n        }\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This returns the angle for a value based around the maximum number\\\\n        * \\\\n        * @param number value The value to get the angle for\\\\n        */\\\\n        this.getAngle = function (value)\\\\n        {\\\\n            if (value > this.total) {\\\\n                return null;\\\\n            }\\\\n            \\\\n            var angle = (value / this.total) * RG.TWOPI;\\\\n    \\\\n            // Handle the origin (it can br -HALFPI or 0)\\\\n            angle += prop['chart.origin'];\\\\n    \\\\n            return angle;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This allows for easy specification of gradients\\\\n        */\\\\n        this.parseColors = function ()\\\\n        {\\\\n            // Save the original colors so that they can be restored when the canvas is reset\\\\n            if (this.original_colors.length === 0) {\\\\n                this.original_colors['chart.colors']                  = RG.arrayClone(prop['chart.colors']);\\\\n                this.original_colors['chart.key.colors']              = RG.arrayClone(prop['chart.key.colors']);\\\\n                this.original_colors['chart.strokestyle']             = RG.arrayClone(prop['chart.strokestyle']);\\\\n                this.original_colors['chart.highlight.stroke']        = RG.arrayClone(prop['chart.highlight.stroke']);\\\\n                this.original_colors['chart.highlight.style.twod.fill']   = RG.arrayClone(prop['chart.highlight.style.twod.fill']);\\\\n                this.original_colors['chart.highlight.style.twod.stroke'] = RG.arrayClone(prop['chart.highlight.style.twod.stroke']);\\\\n                this.original_colors['chart.ingraph.bounding.fill']   = RG.arrayClone(prop['chart.ingraph.bounding.fill']);\\\\n                this.original_colors['chart.ingraph.color']           = RG.arrayClone(prop['chart.ingraph.color']);\\\\n            }\\\\n\\\\n            for (var i=0; i<prop['chart.colors'].length; ++i) {\\\\n                prop['chart.colors'][i] = this.parseSingleColorForGradient(prop['chart.colors'][i]);\\\\n            }\\\\n    \\\\n            var keyColors = prop['chart.key.colors'];\\\\n            if (keyColors) {\\\\n                for (var i=0; i<keyColors.length; ++i) {\\\\n                    keyColors[i] = this.parseSingleColorForGradient(keyColors[i]);\\\\n                }\\\\n            }\\\\n    \\\\n            prop['chart.strokestyle']                  = this.parseSingleColorForGradient(prop['chart.strokestyle']);\\\\n            prop['chart.highlight.stroke']             = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);\\\\n            prop['chart.highlight.style.twod.fill']      = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.fill']);\\\\n            prop['chart.highlight.style.twod.stroke']    = this.parseSingleColorForGradient(prop['chart.highlight.style.twod.stroke']);\\\\n            prop['chart.labels.ingraph.bounding.fill'] = this.parseSingleColorForGradient(prop['chart.labels.ingraph.bounding.fill']);\\\\n            prop['chart.labels.ingraph.color']         = this.parseSingleColorForGradient(prop['chart.labels.ingraph.color']);\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Use this function to reset the object to the post-constructor state. Eg reset colors if\\\\n        * need be etc\\\\n        */\\\\n        this.reset = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This parses a single color value\\\\n        */\\\\n        this.parseSingleColorForGradient = function (color)\\\\n        {\\\\n\\\\n            if (!color || typeof(color) != 'string') {\\\\n                return color;\\\\n            }\\\\n    \\\\n            if (color.match(/^gradient\\\\\\\\((.*)\\\\\\\\)\\\\\\\$/i)) {\\\\n\\\\n                var parts = RegExp.\\\\\\\$1.split(':');\\\\n    \\\\n                // If the chart is a donut - the first width should half the total radius\\\\n                if (prop['chart.variant'] == 'donut') {\\\\n                    var radius_start = typeof(prop['chart.variant.donut.width']) == 'number' ? this.radius - prop['chart.variant.donut.width'] : this.radius / 2;\\\\n                } else {\\\\n                    var radius_start = 0;\\\\n                }\\\\n\\\\n                // Create the gradient\\\\n                var grad = co.createRadialGradient(this.centerx, this.centery, radius_start, this.centerx, this.centery, Math.min(ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'], ca.height - prop['chart.gutter.top'] - prop['chart.gutter.bottom']) / 2);\\\\n    \\\\n    \\\\n                var diff = 1 / (parts.length - 1);\\\\n    \\\\n                grad.addColorStop(0, RG.trim(parts[0]));\\\\n    \\\\n                for (var j=1; j<parts.length; ++j) {\\\\n                    grad.addColorStop(j * diff, RG.trim(parts[j]));\\\\n                }\\\\n            }\\\\n    \\\\n            return grad ? grad : color;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function handles highlighting an entire data-series for the interactive\\\\n        * key\\\\n        * \\\\n        * @param int index The index of the data series to be highlighted\\\\n        */\\\\n        this.interactiveKeyHighlight = function (index)\\\\n        {\\\\n            if (this.angles && this.angles[index]) {\\\\n\\\\n                var segment = this.angles[index];\\\\n                var x = segment[2];\\\\n                var y = segment[3];\\\\n                var start = segment[0];\\\\n                var end   = segment[1];\\\\n                \\\\n                co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];\\\\n                co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];\\\\n                co.lineWidth = 2;\\\\n                co.lineJoin = 'bevel';\\\\n                \\\\n                co.beginPath();\\\\n                co.moveTo(x, y);\\\\n                co.arc(x, y, this.radius, start, end, false);\\\\n                co.closePath();\\\\n                co.fill();\\\\n                co.stroke();\\\\n            }\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Using a function to add events makes it easier to facilitate method chaining\\\\n        * \\\\n        * @param string   type The type of even to add\\\\n        * @param function func \\\\n        */\\\\n        this.on = function (type, func)\\\\n        {\\\\n            if (type.substr(0,2) !== 'on') {\\\\n                type = 'on' + type;\\\\n            }\\\\n            \\\\n            if (typeof this[type] !== 'function') {\\\\n                this[type] = func;\\\\n            } else {\\\\n                RG.addCustomEventListener(this, type, func);\\\\n            }\\\\n    \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This function runs once only\\\\n        * (put at the end of the file (before any effects))\\\\n        */\\\\n        this.firstDrawFunc = function ()\\\\n        {\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        //\\\\n        // Draw a 3D Pie/Donut chart\\\\n        //\\\\n        this.draw3d = function ()\\\\n        {\\\\n            var scaleX            = 1.5,\\\\n                depth             = prop['chart.variant.threed.depth'],\\\\n                prop_shadow       = prop['chart.shadow'],\\\\n                prop_labels       = prop['chart.labels'],\\\\n                prop_labelsSticks = prop['chart.labels.sticks']\\\\n\\\\n            this.set({\\\\n                labels: [],\\\\n                labelsSticks: false,\\\\n                strokestyle: 'rgba(0,0,0,0)'\\\\n            });\\\\n            \\\\n            //\\\\n            // Change the variant so that the draw function doesn't keep\\\\n            // coming in here\\\\n            //\\\\n            this.set({\\\\n                variant: this.get('variant').replace(/3d/, '')\\\\n            });\\\\n            \\\\n            this.context.setTransform(scaleX, 0, 0, 1, (ca.width * (scaleX) - ca.width) * -0.5, 0);\\\\n            \\\\n            for (var i=depth; i>0; i-=1) {\\\\n                \\\\n                this.set({\\\\n                    centeryAdjust: i\\\\n                });\\\\n                \\\\n                if (i === parseInt(depth / 2) ) {\\\\n                    this.set({\\\\n                        labels: prop_labels,\\\\n                        labelsSticks: prop_labelsSticks\\\\n                    });\\\\n                }\\\\n                \\\\n                if (i === 0) {\\\\n                    this.set({\\\\n                        shadow: prop_shadow\\\\n                    });\\\\n                }\\\\n\\\\n                this.draw();\\\\n\\\\n                // Turn off the shadow after the bottom pie/donut has\\\\n                // been drawn\\\\n                this.set('shadow', false);\\\\n\\\\n                //\\\\n                // If on the middle pie/donut turn the labels and sticks off\\\\n                //\\\\n                if (i <= parseInt(depth / 2) ) {\\\\n                    this.set({\\\\n                        labels: [],\\\\n                        labelsSticks: false\\\\n                    });\\\\n                }\\\\n\\\\n                //\\\\n                // Make what we're drawng darker by going over\\\\n                // it in a semi-transparent dark color\\\\n                //\\\\n                if (i > 1) {\\\\n                    if (prop['chart.variant'].indexOf('donut') !== -1) {\\\\n\\\\n                        for (var j=0; j<this.angles.length; ++j) {\\\\n                            pa2(co,[\\\\n                                'b',\\\\n                                'a', this.angles[j][2], this.angles[j][3], this.radius + 1, this.angles[j][0], this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], false,\\\\n                                'a', this.angles[j][2], this.angles[j][3], this.radius / 2, this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'], this.angles[j][0], true,\\\\n                                'f', 'rgba(0,0,0,0.15)'\\\\n                            ]);\\\\n                        }\\\\n\\\\n                    // Draw the pie chart darkened segments\\\\n                    } else {\\\\n\\\\n                        for (var j=0; j<this.angles.length; ++j) {\\\\n\\\\n                            pa2(co,[\\\\n                                'b',\\\\n                                'm', this.angles[j][2], this.angles[j][3],\\\\n                                'a', this.angles[j][2],\\\\n                                     this.angles[j][3],\\\\n                                     this.radius + 1,\\\\n                                     this.angles[j][0],\\\\n                                     this.angles[j][1] * prop['chart.effect.roundrobin.multiplier'],\\\\n                                     false,\\\\n                                'c',\\\\n                                'f', 'rgba(0,0,0,0.15)'\\\\n                            ]);\\\\n                        }\\\\n                    }\\\\n                }\\\\n            }\\\\n\\\\n            //\\\\n            // Reset the variant by adding the 3d back on\\\\n            //\\\\n            this.set({\\\\n                variant: this.get('variant') + '3d',\\\\n                shadow: prop_shadow,\\\\n                labels: prop_labels,\\\\n                labelsSticks: prop_labelsSticks\\\\n            });\\\\n            \\\\n            // Necessary to allow method chaining\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Pie chart explode\\\\n        * \\\\n        * Explodes the Pie chart - gradually incrementing the size of the chart.explode property\\\\n        * \\\\n        * @param object     Options for the effect\\\\n        * @param function   An optional callback function to call when the animation completes\\\\n        */\\\\n        this.explode = function ()\\\\n        {\\\\n            var obj            = this;\\\\n            var opt            = arguments[0] ? arguments[0] : {};\\\\n            var callback       = arguments[1] ? arguments[1] : function () {};\\\\n            var frames         = opt.frames ? opt.frames : 30;\\\\n            var frame          = 0;\\\\n            var maxExplode     = Number(typeof opt.radius === 'number' ? opt.radius : ma.max(ca.width, ca.height));\\\\n            var currentExplode = Number(obj.get('exploded')) || 0;\\\\n            var step           = (maxExplode - currentExplode) / frames;\\\\n\\\\n            // chart.exploded\\\\n            var iterator = function ()\\\\n            {\\\\n                obj.set('exploded', currentExplode + (step * frame) );\\\\n\\\\n                RGraph.clear(obj.canvas);\\\\n                RGraph.redrawCanvas(obj.canvas);\\\\n    \\\\n                if (frame++ < frames) {\\\\n                    RGraph.Effects.updateCanvas(iterator);\\\\n                } else {\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n            \\\\n            iterator();\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Pie chart grow\\\\n        * \\\\n        * Gradually increases the pie chart radius\\\\n        * \\\\n        * @param object   OPTIONAL An object of options\\\\n        * @param function OPTIONAL A callback function\\\\n        */\\\\n        this.grow = function ()\\\\n        {\\\\n            var obj      = this;\\\\n            var canvas   = obj.canvas;\\\\n            var opt      = arguments[0] ? arguments[0] : {};\\\\n            var frames   = opt.frames || 30;\\\\n            var frame    = 0;\\\\n            var callback = arguments[1] ? arguments[1] : function () {};\\\\n            var radius   = obj.getRadius();\\\\n\\\\n\\\\n            prop['chart.radius'] = 0;\\\\n\\\\n            var iterator = function ()\\\\n            {\\\\n                obj.set('chart.radius', (frame / frames) * radius);\\\\n                \\\\n                RG.redrawCanvas(ca);\\\\n    \\\\n                if (frame++ < frames) {\\\\n                    RG.Effects.updateCanvas(iterator);\\\\n                \\\\n                } else {\\\\n\\\\n                    RG.redrawCanvas(obj.canvas);\\\\n\\\\n\\\\n                    callback(obj);\\\\n                }\\\\n            };\\\\n    \\\\n            iterator();\\\\n            \\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * RoundRobin\\\\n        * \\\\n        * This effect does two things:\\\\n        *  1. Gradually increases the size of each segment\\\\n        *  2. Gradually increases the size of the radius from 0\\\\n        * \\\\n        * @param object OPTIONAL Options for the effect\\\\n        * @param function OPTIONAL A callback function\\\\n        */\\\\n        this.roundrobin =\\\\n        this.roundRobin = function ()\\\\n        {\\\\n            var obj      = this,\\\\n                opt      = arguments[0] || {},\\\\n                callback = arguments[1] || function () {},\\\\n                frame    = 0,\\\\n                frames   = opt.frames || 30,\\\\n                radius   =  obj.getRadius(),\\\\n                labels   =  obj.get('labels')\\\\n            \\\\n            obj.Set('chart.events', false);\\\\n            obj.Set('chart.labels', []);\\\\n\\\\n            var iterator = function ()\\\\n            {                \\\\n                obj.set(\\\\n                    'effect.roundrobin.multiplier',\\\\n                    RG.Effects.getEasingMultiplier(frames, frame)\\\\n                );\\\\n\\\\n                RGraph.redrawCanvas(ca);\\\\n\\\\n                if (frame++ < frames) {\\\\n                    RGraph.Effects.updateCanvas(iterator);\\\\n                \\\\n                } else {\\\\n\\\\n                    obj.set({\\\\n                        events: true,\\\\n                        labels: labels\\\\n                    });\\\\n                    \\\\n                    RG.redrawCanvas(obj.canvas);\\\\n                    callback(obj);\\\\n                }\\\\n            };\\\\n    \\\\n            iterator();\\\\n            \\\\n            return this;\\\\n        };\\\\n        \\\\n        \\\\n        \\\\n        \\\\n        RG.att(ca);\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Pie chart implode\\\\n        * \\\\n        * Implodes the Pie chart - gradually decreasing the size of the chart.explode property. It starts at the largest of\\\\n        * the canvas width./height\\\\n        * \\\\n        * @param object     Optional options for the effect. You can pass in frames here - such as:\\\\n        *                   myPie.implode({frames: 60}; function () {alert('Done!');})\\\\n        * @param function   A callback function which is called when the effect is finished\\\\n        */\\\\n        this.implode = function ()\\\\n        {\\\\n            var obj         = this,\\\\n                opt         = arguments[0] || {},\\\\n                callback    = arguments[1] || function (){},\\\\n                frames      = opt.frames || 30,\\\\n                frame       = 0,\\\\n                explodedMax = ma.max(ca.width, ca.height),\\\\n                exploded    = explodedMax;\\\\n    \\\\n    \\\\n    \\\\n            function iterator ()\\\\n            {\\\\n                exploded =  explodedMax - ((frame / frames) * explodedMax);\\\\n\\\\n                // Set the new value\\\\n                obj.Set('exploded', exploded);\\\\n    \\\\n                RG.clear(ca);\\\\n                RG.redrawCanvas(ca);\\\\n\\\\n                if (frame++ < frames) {\\\\n                    RG.Effects.updateCanvas(iterator);\\\\n                } else {\\\\n                    RG.clear(obj.canvas);\\\\n                    RG.redrawCanvas(obj.canvas);\\\\n                    callback(obj);\\\\n                }\\\\n            }\\\\n            \\\\n            iterator();\\\\n\\\\n            return this;\\\\n        };\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * Now need to register all chart types. MUST be after the setters/getters are defined\\\\n        */\\\\n        RG.register(this);\\\\n\\\\n\\\\n\\\\n\\\\n        /**\\\\n        * This is the 'end' of the constructor so if the first argument\\\\n        * contains configuration data - handle that.\\\\n        */\\\\n        if (parseConfObjectForOptions) {\\\\n            RG.parseObjectStyleConfig(this, conf.options);\\\\n        }\\\\n    };\\\";\");\";}}");

?>