<?php
return unserialize("a:5:{i:0;a:1:{i:0;a:1:{i:0;a:5:{i:0;s:33:\"tcpfunc_58dd79883c97a5.80079000_1\";i:1;a:0:{}i:2;i:1;i:3;s:0:\"\";i:4;s:0:\"\";}}}i:1;a:0:{}i:2;s:6:\"base64\";i:3;N;i:4;a:1:{s:33:\"tcpfunc_58dd79883c97a5.80079000_1\";s:4881:\"\$tpl_funcs['tcpfunc_58dd79883c97a5.80079000_1']=\$KEEP_TPL_FUNCS['tcpfunc_58dd79883c97a5.80079000_1']=recall_named_function('58dd79883c9834.65823862','\$parameters,\$cl',\"echo \\\"/**/\\\\n/*no minify*/\\\\n\\\\n// Simple Base64 encoder/decoder\\\\n// Public Domain\\\\n\\\\nvar Base64 = {\\\\n\\\\n	encode : function (input) {\\\\n		// Converts each character in the input to its Unicode number, then writes\\\\n		// out the Unicode numbers in binary, one after another, into a string.\\\\n		// This string is then split up at every 6th character, these substrings\\\\n		// are then converted back into binary integers and are used to subscript\\\\n		// the \\\\\\\"swaps\\\\\\\" array.\\\\n		// Since this would create HUGE strings of 1s and 0s, the distinct steps\\\\n		// above are actually interleaved in the code below (ie. the long binary\\\\n		// string, called \\\\\\\"input_binary\\\\\\\", gets processed while it is still being\\\\n		// created, so that it never gets too big (in fact, it stays under 13\\\\n		// characters long no matter what).\\\\n\\\\n		// The indices of this array provide the map from numbers to base 64\\\\n		var swaps = [\\\\\\\"A\\\\\\\",\\\\\\\"B\\\\\\\",\\\\\\\"C\\\\\\\",\\\\\\\"D\\\\\\\",\\\\\\\"E\\\\\\\",\\\\\\\"F\\\\\\\",\\\\\\\"G\\\\\\\",\\\\\\\"H\\\\\\\",\\\\\\\"I\\\\\\\",\\\\\\\"J\\\\\\\",\\\\\\\"K\\\\\\\",\\\\\\\"L\\\\\\\",\\\\\\\"M\\\\\\\",\\\\\\\"N\\\\\\\",\\\\\\\"O\\\\\\\",\\\\\\\"P\\\\\\\",\\\\\\\"Q\\\\\\\",\\\\\\\"R\\\\\\\",\\\\\\\"S\\\\\\\",\\\\\\\"T\\\\\\\",\\\\\\\"U\\\\\\\",\\\\\\\"V\\\\\\\",\\\\\\\"W\\\\\\\",\\\\\\\"X\\\\\\\",\\\\\\\"Y\\\\\\\",\\\\\\\"Z\\\\\\\",\\\\\\\"a\\\\\\\",\\\\\\\"b\\\\\\\",\\\\\\\"c\\\\\\\",\\\\\\\"d\\\\\\\",\\\\\\\"e\\\\\\\",\\\\\\\"f\\\\\\\",\\\\\\\"g\\\\\\\",\\\\\\\"h\\\\\\\",\\\\\\\"i\\\\\\\",\\\\\\\"j\\\\\\\",\\\\\\\"k\\\\\\\",\\\\\\\"l\\\\\\\",\\\\\\\"m\\\\\\\",\\\\\\\"n\\\\\\\",\\\\\\\"o\\\\\\\",\\\\\\\"p\\\\\\\",\\\\\\\"q\\\\\\\",\\\\\\\"r\\\\\\\",\\\\\\\"s\\\\\\\",\\\\\\\"t\\\\\\\",\\\\\\\"u\\\\\\\",\\\\\\\"v\\\\\\\",\\\\\\\"w\\\\\\\",\\\\\\\"x\\\\\\\",\\\\\\\"y\\\\\\\",\\\\\\\"z\\\\\\\",\\\\\\\"0\\\\\\\",\\\\\\\"1\\\\\\\",\\\\\\\"2\\\\\\\",\\\\\\\"3\\\\\\\",\\\\\\\"4\\\\\\\",\\\\\\\"5\\\\\\\",\\\\\\\"6\\\\\\\",\\\\\\\"7\\\\\\\",\\\\\\\"8\\\\\\\",\\\\\\\"9\\\\\\\",\\\\\\\"+\\\\\\\",\\\\\\\"/\\\\\\\"];\\\\n		var input_binary = \\\\\\\"\\\\\\\";		// The input string, converted to Unicode numbers and written out in binary\\\\n		var output = \\\\\\\"\\\\\\\";		// The base 64 output\\\\n		var temp_binary;		// Used to ensure the binary numbers have 8 bits\\\\n		var index;		// Loop variable, for looping through input\\\\n		for (index=0; index < input.length; index++)\\\\n		{\\\\n			// Turn the next character of input into astring of 8-bit binary\\\\n			temp_binary = input.charCodeAt(index).toString(2);\\\\n			while (temp_binary.length < 8)\\\\n			{\\\\n				temp_binary = \\\\\\\"0\\\\\\\"+temp_binary;\\\\n			}\\\\n			// Stick this string on the end of the previous 8-bit binary strings to\\\\n			// get one big concatenated binary representation\\\\n			input_binary = input_binary + temp_binary;\\\\n			// Remove all 6-bit sequences from the start of the concatenated binary\\\\n			// string, convert them to a base 64 character and append to output.\\\\n			// Doing this here prevents input_binary from getting massive\\\\n			while (input_binary.length >= 6)\\\\n			{\\\\n				output = output + swaps[parseInt(input_binary.substring(0,6),2)];\\\\n				input_binary = input_binary.substring(6);\\\\n			}\\\\n		}\\\\n		// Handle any necessary padding\\\\n		if (input_binary.length == 4)\\\\n		{\\\\n			temp_binary = input_binary + \\\\\\\"00\\\\\\\";\\\\n			output = output + swaps[parseInt(temp_binary,2)];\\\\n			output = output + \\\\\\\"=\\\\\\\";\\\\n		}\\\\n		if (input_binary.length == 2)\\\\n		{\\\\n			temp_binary = input_binary + \\\\\\\"0000\\\\\\\";\\\\n			output = output + swaps[parseInt(temp_binary,2)];\\\\n			output = output + \\\\\\\"==\\\\\\\";\\\\n		}\\\\n		// Output now contains the input in base 64\\\\n		return output;\\\\n	},\\\\n\\\\n	decode : function (input) {\\\\n		// Takes a base 64 encoded string \\\\\\\"input\\\\\\\", strips any \\\\\\\"=\\\\\\\" or \\\\\\\"==\\\\\\\" padding\\\\n		// off it and converts its base 64 numerals into regular integers (using a\\\\n		// string as a lookup table). These are then written out as 6-bit binary\\\\n		// numbers and concatenated together. The result is split into 8-bit\\\\n		// sequences and these are converted to string characters, which are\\\\n		// concatenated and output.\\\\n		input = input.replace(\\\\\\\"=\\\\\\\",\\\\\\\"\\\\\\\");		// Padding characters are redundant\\\\n		// The index/character relationship in the following string acts as a\\\\n		// lookup table to convert from base 64 numerals to JavaScript integers\\\\n		var swaps = \\\\\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\\\\\";\\\\n		var output_binary = \\\\\\\"\\\\\\\";\\\\n		var output = \\\\\\\"\\\\\\\";\\\\n		var temp_bin = \\\\\\\"\\\\\\\";\\\\n		var index;\\\\n		for (index=0; index < input.length; index++)\\\\n		{\\\\n			temp_bin = swaps.indexOf(input.charAt(index)).toString(2);\\\\n			while (temp_bin.length < 6)\\\\n			{\\\\n				// Add significant zeroes\\\\n				temp_bin = \\\\\\\"0\\\\\\\"+temp_bin;\\\\n			}\\\\n			while (temp_bin.length > 6)\\\\n			{\\\\n				// Remove significant bits\\\\n				temp_bin = temp_bin.substring(1);\\\\n			}\\\\n			output_binary = output_binary + temp_bin;\\\\n			while (output_binary.length >= 8)\\\\n			{\\\\n				output = output + String.fromCharCode(parseInt(output_binary.substring(0,8),2));\\\\n				output_binary = output_binary.substring(8);\\\\n			}\\\\n		}\\\\n		return output;\\\\n	}\\\\n\\\\n};\\\\n\\\";\");\";}}");

?>